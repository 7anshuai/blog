<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>tanshuai.blog()</title>
    <link href="http://blog.tanshuai.me/feed.xml" rel="self" />
    <link href="http://blog.tanshuai.me/" />
    <id>http://blog.tanshuai.me/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[[译] 为 Node.js 包准备的 Makefile]]></title>
        <link href="http://blog.tanshuai.me/work/makefile-recipes-for-nodejs.html"/>
        <published>2015-04-12T00:00:00.000Z</published>
        <updated>2015-04-12T00:00:00.000Z</updated>
        <id>http://blog.tanshuai.me/work/makefile-recipes-for-nodejs.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 <code>make</code> 程序来完成这些任务，主要是因为它的简单明了。</p>
<p>要开始使用 <code>make</code> 你需要在项目根目录创建一个 <code>Makefile</code>。<code>Makefile</code> 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 <code>make &lt;task name&gt;</code>。简单吧！</p>
<p>以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 <code>Makefile</code> 文件。我会一步一步的完成它。</p>
<p>首先是定义一些有用的变量：我在 <code>src</code> 保存源码，编译过的代码放在 <code>lib</code>（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。</p>
<pre>BIN = ./node_modules/.bin
SRC = $(wildcard src/*.coffee)
LIB = $(SRC:src/%.coffee=lib/%.js)</pre><p><code>SRC</code> 将会包含一个 <code>src</code> 目录中的 <code>.coffee</code> 文件列表，然后 <code>LIB</code> － 一个相对应的 <code>.js</code> 文件列表（目前还不存在）。<code>$(VAR:pattern1=pattern2)</code> 使用来指定存储在变量中的每一个项的变换。</p>
<p>所以如果我们保存 <code>src/index.coffee src/mod.coffee</code> 在文件系统中， <code>SRC</code> 会捕获它们然后相应的使 <code>LIB</code> 保存 <code>lib/index.js lib/mod.js</code> 。</p>
<p><code>BIN</code> 指向 Node 本地可执行模块的安装目录。</p>
<h2 id="构建">构建</h2><p>现在让我们定义第一个任务构建并表明它依赖于存储在 <code>LIB</code> 变量的所有文件。</p>
<div class="highlight"><pre><code class="bash">build: $(LIB)</code></pre></div><p>很简单，对不对？<code>$(LIB)</code> 只是在 <code>make</code> 中间接引用变量的语法。</p>
<p>运行 <code>make build</code> 后，程序会尝试确保 <code>LIB</code> 中的所有文件都已就位并及时更新。但是我们如何让 <code>make</code> 知道怎样在 <code>SRC</code> 中获取相应的文件，处理并将所有的这些文件放入 <code>LIB</code> 中呢？</p>
<p>接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － <code>lib/%.js</code> － 正是这个模式将会在 <code>LIB</code> 变量中进行文件匹配。</p>
<div class="highlight"><pre><code class="bash">lib/%.js: src/%.coffee
  @mkdir -p $(@D)
  @$(BIN)/coffee -bcp $&lt; &gt; <span class="variable">$@</span></code></pre></div><p>这条规则告诉 <code>make</code> 那些 <code>lib/%.js</code> 文件依赖于相应的 <code>src/%.coffee</code> 文件，所以如果当后者发生改变时 <code>make</code> 会重新编译生成前者。</p>
<p>它是如何工作的？首先，它创建了一个目标文件的目录（<code>$(@D)</code> 表示这个目录，它是 <code>make</code> 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 <code>.coffee</code> 文件（通过 <code>$&lt;</code> 表示）并将结果写入目标文件（通过 <code>$@</code> 表示）。</p>
<p>注意 @ 前缀，默认的 <code>make</code> 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。</p>
<p>足够作为一个构建程序了，<code>make build</code> 会从 src 目录下将相应的文件重新构建到 lib 目录下。</p>
<h2 id="测试">测试</h2><p>测试任务很简单：</p>
<div class="highlight"><pre><code class="bash">test: build
  @$(BIN)/mocha -b specs</code></pre></div><p>我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。</p>
<h2 id="辅助任务">辅助任务</h2><p>接下来到辅助任务 － <code>clean</code> 用来清除所有编译生成的代码：</p>
<div class="highlight"><pre><code class="bash">clean:
  @rm <span class="operator">-f</span> $(LIB)</code></pre></div><p><code>install</code> 和 <code>link</code> 任务是简单的运行相应的 <code>npm</code> 子命令：</p>
<div class="highlight"><pre><code class="bash">install link:
  @npm <span class="variable">$@</span>;</code></pre></div><p>注音 <code>$@</code> 变量的使用技巧，它是如何传递任务名称作为 <code>npm</code> 的子命令。</p>
<h2 id="版本">版本</h2><p>下一个是版本任务。</p>
<p>下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。</p>
<div class="highlight"><pre><code class="bash">define release
  VERSION=`node -pe <span class="string">"require('./package.json').version"</span>` &amp;&amp; \
  NEXT_VERSION=`node -pe <span class="string">"require('semver').inc(\"$<span class="variable">$VERSION</span>\", '<span class="variable">$(1)</span>')"</span>` &amp;&amp; \
  node <span class="operator">-e</span> <span class="string">"\
    var j = require('./package.json');\
    j.version = \"$<span class="variable">$NEXT_VERSION</span>\";\
    var s = JSON.stringify(j, null, 2);\
    require('fs').writeFileSync('./package.json', s);"</span> &amp;&amp; \
  git commit -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span> -- package.json &amp;&amp; \
  git tag <span class="string">"$<span class="variable">$NEXT_VERSION</span>"</span> -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span>
endef</code></pre></div><p>简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 <code>$1</code> 变量定义的）重写了 <code>package.json</code>，然后创建了一个相应的 <code>git commit</code> 和 <code>git tag</code>。</p>
<p>接下啦只需要通过传递 <code>patch</code>，<code>minor</code> 或者 <code>major</code> 参数调用 <code>release</code> 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。</p>
<div class="highlight"><pre><code class="bash">release-patch: build test
  @$(call release,patch)

release-minor: build test
  @$(call release,minor)

release-major: build test
  @$(call release,major)</code></pre></div><p>最后一点是 <code>publish</code> 任务，它用来推送代码到仓库，并发布包到 npm。</p>
<div class="highlight"><pre><code class="bash">publish:
  git push --tags origin HEAD:master
  npm publish</code></pre></div><p>现在发布一个新的次要版本只需要在命令行执行 <code>make release-minor publish</code> － <code>package.json</code> 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。</p>
<p>完整的 <code>Makefile</code> 在 <a href="https://gist.github.com/5588256">这里</a>。</p>
<p>原文链接：<a href="https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html">Makefile recipes for Node.js packages</a></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[28 年华]]></title>
        <link href="http://blog.tanshuai.me/life/28-years-old.html"/>
        <published>2015-04-06T00:00:00.000Z</published>
        <updated>2015-04-06T00:00:00.000Z</updated>
        <id>http://blog.tanshuai.me/life/28-years-old.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>清明小假，昏昏沉沉的在房间宅了几天。真的挺浪费了外面的阳光。</p>
<p>最近一阵子的心情和状态都很低落的样子。工作上也是马马虎虎，或许停下来休息下是个不错的选择。这样可以回家住上几天，吃爸妈做的家常饭菜，看几本书，简单自然的。</p>
<p>今天28了，之前的这些年，感觉挺2B的。未来可以怎样，我无法知道。但不管18还是28，都应该好好珍惜才是。</p>
<p>祝自己生日快乐！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Node.js 中使用 Asset Pipeline]]></title>
        <link href="http://blog.tanshuai.me/work/assets-pipeline-on-nodejs.html"/>
        <published>2015-03-16T14:03:07.000Z</published>
        <updated>2015-03-16T14:03:07.000Z</updated>
        <id>http://blog.tanshuai.me/work/assets-pipeline-on-nodejs.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>-- Phil Karlton</p>
</blockquote>
<p>计算机科学只有两个难题：缓存失效和变量命名。</p>
<p><em>Coding</em> 中，这两道难题确实无处不在。难题之一缓存失效，Web 中的资源缓存涉及到服务器和浏览器两端的各种缓存机制（详情可阅读腾讯 AlloyTeam 的博客 <a href="http://alloyteam.com/2012/03/web-cache-1-web-cache-overview/">Web 缓存机制系列</a>）。当 Web 应用进行版本更新时，需要发布新的资源文件并更新缓存。那怎么让 Web 浏览器中原有的缓存失效，加载新的资源文件并缓存到客户端的计算机上呢？常见的两种做法是：</p>
<ul>
<li>传统手工作业</li>
<li>基于日期的请求字符串</li>
</ul>
<p>这两种方法都有明显的缺点，手动控制文件版本的做法通常是这样的：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.1/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.2/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>基于日期的请求字符串：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349480"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349481"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>这两种方法都有明显的缺点,传统手工作业是繁琐低效的，而基于日期的请求字符串的缓存并不可靠。在查看过 <a href="https://github.com/">GitHub</a> 的网页源码后，发现他们组织程序的静态资源方式有所不同：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://assets-cdn.github.com/assets/github-d869f6edeea2dbd9c7c3595e2f31cf8a1530bd36eaa84707461f65c5ee848853.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>文件名后面加上了一串字符串（基于MD5生成），顿觉莫名的高大上啊。偶尔在 <a href="https://ruby-china.org/">Ruby China</a> 闲逛得知，这是 Rails 3.1 版本开始引入的静态资源管理方式 <a href="http://guides.ruby-china.org/asset_pipeline.html">Asset Pipeline</a>。</p>
<h2 id="asset-pipeline-是什么？">Asset Pipeline 是什么？</h2><p>Rails 指南中提到，Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。它提供了三个主要功能：</p>
<ul>
<li>连接合并 JavaScript 和 CSS 文件，减少页面的 HTTP 请求。</li>
<li>压缩 JavaScript 和 CSS 文件（减重瘦身上前线）</li>
<li>高级语言及预处理器支持，允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript。</li>
</ul>
<p>在生产环境中，Rails 通过 Asset Pipeline 技术在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。</p>
<h2 id="md5-指纹">MD5 指纹</h2><p>Rails 指南中详细解释了指纹。指纹可以根据文件内容生成文件名，文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。</p>
<p>如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。</p>
<h2 id="connect-assets">connect-assets</h2><p>不同语言不同框架都有类似 Rails Asset Pipeline 的实现，<a href="https://github.com/adunkman/connect-assets">connect-assets</a> 是为 Node.js 打造的 Asset Pipeline。它也实现了以上所述的三个主要功能：合并，压缩 JavaScript/CSS 文件，高级语言预处理。在 Node.js 中也可以给静态资源添加指纹，使用更有效的缓存技术。</p>
<p>使用方法也很简单，第一步在项目中安装 connect-asset：</p>
<div class="highlight"><pre><code class="bash">npm install connect-assets</code></pre></div><p>第二步，在 Express 应用中添加配置代码：</p>
<div class="highlight"><pre><code class="javascript">app.use(require(<span class="string">'connect-assets'</span>)());</code></pre></div><p>最后，在项目中创建一个 <code>assets</code> 文件夹，并分别将 JavaScript 和 CSS 文件放入 <code>/assets/js</code> 和 <code>/assets/css</code>。</p>
<p>Node.js 应用就可以使用最基本的 connect-assets 功能了。</p>
<h3 id="标记函数">标记函数</h3><p>connect-assets 提供了三个名为 <code>js</code>，<code>css</code>, <code>assetPath</code> 的全局函数，可以在视图文件中使用它们。标记函数返回需要的包含最新版本的静态资源（或资源的路径）HTML 标记。例如，在一个 Jade 模板中的代码：</p>
<pre>!= css(&quot;normalize&quot;)
!= js(&quot;jquery&quot;)</pre><p><code>!=</code> 是 Jade 语法， 用于运行 JS 和显示输出，结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>你可以传递特殊属性给函数 <code>css</code> 或 <code>js</code>：</p>
<pre>!= css(&quot;normalize&quot;, {&quot;data-turbolinks-track&quot;: true})
!= js(&quot;jquery&quot;, {async: true})</pre><p>结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> <span class="attribute">data-turbolinks-track</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="sprockets-风格的合并">Sprockets 风格的合并</h3><p>可以在 <code>.js.coffee</code> 和 <code>.js</code> 文件中使用 Sprockets-style 语法指定依赖关系。</p>
<p>在 CoffeeScript 中：</p>
<div class="highlight"><pre><code class="coffeescript"><span class="comment">#= require dependency</span></code></pre></div><p>在 JavaScript 中：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">//= require dependency</span></code></pre></div><p>当你这样做并在 <code>js</code> 函数中指定该文件，会产生两个效果：</p>
<ul>
<li>默认的你会得到多个 <code>script</code>，按顺序输出你指定的所有依赖。</li>
<li>如果你传递 <code>build: true</code> 选项给 connect-assets（当 <code>env == &#39;production&#39;</code> 时默认开启），你会得到一个单独的标记，它指向一个将所有依赖目标都编译，合并，压缩（通过 UglifyJS）的 JavaScript 文件。</li>
</ul>
<p>如果你想包含整个文件夹的脚本，使用 <code>//= require_tree dir</code> 代替 <code>//= require file</code>。</p>
<p>一个使用 connect-assets 的 Node.js App <a href="http://node.tanshuai.me/">Node starter</a>，fork from <a href="https://github.com/sahat/hackathon-starter">Hackathon Starter</a>。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="http://code.google.com/speed/page-speed/docs/caching.html">Optimize caching</a></li>
<li><a href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Revving Filenames: dont&#39;t use querystring</a></li>
</ul>
<p>周末福利:</p>
<p>豆瓣女神，独立音乐人，北大美女才女 － 程璧的官方主页 <a href="http://www.annapatio.com/">Anna&#39;s Patio</a> 是基于 Ruby on Rails，真心很赞啊！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[基本的命令行编辑技巧]]></title>
        <link href="http://blog.tanshuai.me/work/the-basic-command-line-editing.html"/>
        <published>2015-01-26T14:46:54.000Z</published>
        <updated>2015-01-26T14:46:54.000Z</updated>
        <id>http://blog.tanshuai.me/work/the-basic-command-line-editing.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>GNU Bash shell 提供了 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html">Command line editing</a> 功能，它是由 <a href="http://tiswww.case.edu/php/chet/readline/rltop.html">Readline library</a> 实现的。Python 交互式命令行和 node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing 支持 Emacs-style 和 Vi-style 的命令风格，默认的是 Emacs-style。</p>
<h2 id="命令行编辑">命令行编辑</h2><p>基本上，Unix/Linux 系统默认就支持 Command line editing，所以打开终端，或者在终端运行 Python interactive 或者 Node REPL，都可以马上使用常规的 Emacs 的控制字符集 <code>Control-*</code> 了。</p>
<ul>
<li><code>C-a</code> （Control-a）移动光标到行首</li>
<li><code>C-e</code> 移动光标到行尾</li>
<li><code>C-b</code> 将光标往左移动一个位置</li>
<li><code>C-f</code> 将光标往右移动一个位置</li>
<li><code>Backspace</code> 你懂得</li>
<li><code>C-d</code> 删除光标右边的一个字符</li>
<li><code>C-k</code> 删除光标右边所有的字符</li>
<li><code>C-y</code> 拉回最后一次删除的字符</li>
<li><code>C-_</code> 撤销最后一次操作</li>
</ul>
<h2 id="历史替换">历史替换</h2><p>历史替换（History Subsititution）的工作原理如下。所有已运行的非空命令行，都会保存到历史缓冲区，当你在一个新的提示符后输入时，实际上是在缓冲区底部添加新的一行。
<code>C-p</code> 可以往上移动一行，<code>C-n</code> 往下移动一行，<code>C-R</code> 可以反向搜索， <code>C-s</code> 向前搜索。</p>
<h2 id="键值绑定">键值绑定</h2><p>可以在 <code>~/.inputrc</code> 文件中增加一些自定义的命令和功能。常见的形式是： <code>key-name: function-name</code> 或 <code>&quot;string&quot;: function-name</code>，还可以通过 <code>set option-name vale</code> 设置选项。
一个简单的例子：</p>
<div class="highlight"><pre><code class="bash"><span class="comment"># I prefer vi-style editing:</span>
<span class="keyword">set</span> editing-mode vi

<span class="comment"># Edit using a single line:</span>
<span class="keyword">set</span> horizontal-scroll-mode On

<span class="comment"># Rebind some keys:</span>
Meta-h: backward-kill-word
<span class="string">"\C-u"</span>: universal-argument
<span class="string">"\C-x\C-r"</span>: re-read-init-file</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[一个 JavaScript 控制台错误]]></title>
        <link href="http://blog.tanshuai.me/work/a-javascript-console-error.html"/>
        <published>2014-10-16T08:51:17.000Z</published>
        <updated>2014-10-16T08:51:17.000Z</updated>
        <id>http://blog.tanshuai.me/work/a-javascript-console-error.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现<code>ReferenceError: varialbe is not defined</code>错误，令我感到迷惑不解。场景大致如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> getSth = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    $.ajax({
        url: <span class="string">'/echo/json'</span>,
        type: <span class="string">'GET'</span>,
        data: {key: key},
        dataType: <span class="string">'json'</span>
    }).done(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        console.log(key)
    })
}</code></pre></div><p>AJAX请求成功执行匿名回调函数时，<code>console.log</code>语句会正常打印<code>key</code>值。但将<code>console.log(key)</code>改为 <code>console.log(data)</code>，通过开发工具在此处设置一个断点，代码执行在断点处时在控制台中打印<code>key</code>，则会报错<code>ReferenceError: key is not defined</code>。</p>
<p>一开始想当然的认为<code>key</code>变量是通过查找作用域链获得，反复调试后发现，如果在匿名回调函数的代码中引用<code>key</code>变量的话，则会在当前作用域创建一个闭包，而 JavaScript 是基于<a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>，闭包的创建是在词法分析阶段，所以在代码执行时通过控制台动态的引用<code>key</code>值会得到一个<code>ReferenceError</code>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Comment lines in vim]]></title>
        <link href="http://blog.tanshuai.me/work/comment-lines-in-vim.html"/>
        <published>2014-06-17T13:47:14.000Z</published>
        <updated>2014-06-17T13:47:14.000Z</updated>
        <id>http://blog.tanshuai.me/work/comment-lines-in-vim.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p><a href="http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim">What&#39;s a quick way to comment/uncomment lines in vim?</a> Stackoverflow 上的一个关于 Vim comments 的问题有很多不错的答案，记录第二个简单基础的方法。</p>
<p>首先，将光标移动到想要注释的代码块第一行，然后<code>Ctrl + V</code> （<code>Ctrl + Q</code> for Gvim）进入 Visual block mode，移动光标到要注释的代码末行，再 <code>Shift + i</code>，添加行注释<code>//</code>， 最后按下 <code>Esc</code>，Give it a second to work.</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Something to think about]]></title>
        <link href="http://blog.tanshuai.me/work/something-to-think-about.html"/>
        <published>2013-07-20T01:25:56.000Z</published>
        <updated>2013-07-20T01:25:56.000Z</updated>
        <id>http://blog.tanshuai.me/work/something-to-think-about.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies; the other is to make it so complicated that there are no obvious deficiencies.</p>
<p>Success in life is a matter not so much of talent and opportunity as of concentration and perserverance.</p>
<p>From <a href="http://swaroopch.com/notes/python/">A Byte of Python</a></p>
]]>
        </content>
    </entry>
</feed>