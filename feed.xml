<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>tanshuai.blog()</title>
    <link href="http://7anshuai.js.org/blog/feed.xml" rel="self" />
    <link href="http://7anshuai.js.org/blog/" />
    <id>http://7anshuai.js.org/blog/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[在 Chrome DevTools 中并行调试 Node.js 和 浏览器 JavaScript]]></title>
        <link href="http://7anshuai.js.org/blog/work/nodejs-debugging-with-chrome-devtools.html"/>
        <published>2017-02-09T00:00:00.000Z</published>
        <updated>2017-02-09T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/nodejs-debugging-with-chrome-devtools.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>Programmers make mistakes. For whimsical reasons, programming errors are called <strong>bugs</strong> and the process of tracking them down is called <strong>debugging</strong>.</p>
<p>-- Allen Downey</p>
</blockquote>
<p>最近读了 <a href="http://greenteapress.com/wp/think-python-2e/">Think Python</a>，书中对 Debugging 的描述很有趣：</p>
<blockquote>
<p>编写代码，特别是 debugging，有时会产生强烈的情绪。如果你在与一个困难的 bug 做斗争，你可能会感动愤怒，沮丧或者尴尬。</p>
<p>有证据表明，人们会很自然的把计算机当作人一样做出反应。当它们运转良好，我们认为它们是好队友，而当它们顽固或粗鲁时，我们也会像对待顽固，粗鲁的人一样回应它们。</p>
<p>做点准备可能会帮助你处理这些反应。一种方法是将计算机视为具有某些优势（如速度和精度）和特定弱点（例如缺乏同情心和无法掌握大局）的员工。</p>
<p>你的工作是做一个好的经理：找到方法来利用优势和缓解弱点。 并找到使用你的情绪来解决问题的方法，而不会让你的反应干扰你的有效工作能力。</p>
<p>学习 debug 可能令人沮丧，但它是一个有价值的技能，对于除了编程以外还有许多活动都是有用的。</p>
</blockquote>
<p>对于程序员来说最重要的技能是解决问题。善于 Debug 能极大的提高解决问题的效率和成功率。So, 做为 JS 开发者需要好好学习总结下 JavaScript 及 Node.js debug。</p>
<h2 id="javascript-debugger">JavaScript Debugger</h2><p>Web 浏览器附带一个通常被称为“开发者工具”的内置功能，它提供了更好的视角来观察运行在浏览器里的 JavaScript。虽然不是必须的，但当你调试代码错误时，你会发现开发者工具很有用。</p>
<p><a href="https://developers.google.cn/web/tools/chrome-devtools/">Chrome DevTools</a> 是 Google Chrome 中内置的一组网络制作和调试工具。 使用 DevTools 来迭代，调试和配置您的网站。具体的如何调试 JavaScript 代码可以参考<a href="https://developers.google.cn/web/tools/chrome-devtools/javascript/">官方文档</a>。</p>
<h2 id="node-debuggers">Node debuggers</h2><h3 id="debugger">Debugger</h3><p>服务器端的 JavaScript 运行时环境 Node.js 包含了一个基于 TCP 协议访问的进程外调试工具和内置的调试客户端。要使用它，使用debug参数启动Node.js，然后是要调试的脚本的路径; 将显示一个提示，指示调试器成功启动：</p>
<pre>$ node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(() =&gt; {
  3   debugger;
debug&gt;</pre><p>Node.js 的调试客户端不是一个全功能调试器，但简单的步骤和检查是可行的。</p>
<p>更多的详情及高级用法可参考<a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html">官方文档</a>。</p>
<h3 id="node-inspector">Node Inspector</h3><p>随着 Node.js 的大热，开源社区里的优秀开发者贡献了大量的 <a href="https://github.com/sindresorhus/awesome-nodejs#debugging--profiling">debugging 工具</a>，其中的佼佼者便是 <a href="https://github.com/node-inspector/node-inspector">node-inspector</a>。</p>
<p>Node Inspector 是 Node.js 应用程序的调试器接口，通过它可以使用 Blink（Chrome 浏览器内核）开发工具来进行 debugging。</p>
<h4 id="安装">安装</h4><p>通过 npm 安装 node-inspector：</p>
<pre>$ npm install -g node-inspector</pre><h4 id="启动">启动</h4><p>然后启动程序：</p>
<pre>$ node-debug app.js</pre><p>其中 <code>app.js</code> 是您的 Node 应用程序主要 JavaScript 文件的名称。</p>
<h4 id="调试">调试</h4><p><code>node-debug</code> 命令将在默认浏览器中加载 Node Inspector。</p>
<blockquote>
<p>⚠：Node Inspector 仅适用于 Chrome 和 Opera。 如果另一个浏览器是您的默认网络浏览器（例如 Safari 或 Internet Explorer），则必须在其中一个浏览器中重新打开检查器页面。</p>
</blockquote>
<p>Node Inspector 的工作方式几乎与 Chrome DevTools 完全相同。</p>
<h4 id="issues">issues</h4><p><a href="https://www.npmjs.com/package/node-inspector">Node Inspector</a> 目前最新的 package 版本是0.12.8，发布于10个月前。
而 Node.js 版本更新很快，v6.x 已经有十几个版本更新了。</p>
<p>在好几个月前，我开始使用 Node.js v6.4.0，同样的也安装了 Node Inspector 来进行 Debugging，然后就遇到了：<a href="https://github.com/node-inspector/node-inspector/issues/905">Throwing exception on simple use case</a>。</p>
<p>在好长一段时间，这个问题没有得到解决，相关讨论，PR也没有得到回应或者 Merge。直到最近，终于合并了一个 Pull Request：<a href="https://github.com/node-inspector/node-inspector/pull/914">Fix callback call in InjectorClient._findNMInScope</a>。然而 Node Inspector package 还没有发布 patch 更新，所以 <code>npm install -g node-inspector</code> 依然会遇到这个问题。</p>
<p>如果需要在 v6.4.0 以上版本使用 Node Inspector，可以直接从 github 下载安装 <code>npm install -g https://github.com/node-inspector/node-inspector</code>，或者手动修改 <a href="https://github.com/node-inspector/node-inspector/pull/914/files">InjectorClient.js</a>。</p>
<h3 id="node-js-集成-v8-inspector">Node.js 集成 V8 Inspector</h3><p>在 Node Inspector issues里看到了很多讨论，有开发者提出了使用 <code>node --inspect app.js</code> 来替代 node-inspector。
原来 Node.js v6.3.0+ 已经内置支持了 <a href="https://github.com/nodejs/node/pull/6792">V8 Inspector</a>。</p>
<p><a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html#debugger_v8_inspector_integration_for_node_js">Node.js debugger docs</a> 文档也增加了这部分内容：</p>
<blockquote>
<p>⚠：这是一个实验特性。</p>
</blockquote>
<p>V8 Inspector 集成允许将 Chrome 开发工具通过 <a href="https://developer.chrome.com/devtools/docs/debugger-protocol">Chrome Debugging Protocol</a> 连接到 Node.js 实例以进行调试和分析。</p>
<p>V8 Inspector 可以通过在启动 Node.js 应用程序时传递 <code>--inspect</code> 标志来启用。 也可以提供具有该标志的自定义端口，例如， <code>--inspect=9222</code> 将接受端口9222上的 DevTools 连接。</p>
<p>如需在应用的第一行代码添加断点，在 <code>--inspect</code> 之外增加 <code>--debug-brk</code> 标志。</p>
<div class="highlight"><pre><code class="bash">$ node --inspect index.js
Debugger listening on port <span class="number">9229</span>.
Warning: This is an experimental feature and could change at any time.
To start debugging, open the following URL <span class="keyword">in</span> Chrome:
    chrome-devtools://devtools/remote/serve_file/@<span class="number">60</span><span class="built_in">cd</span>6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=<span class="literal">true</span>&amp;v8only=<span class="literal">true</span>&amp;ws=localhost:<span class="number">9229</span>/node</code></pre></div><h2 id="node-js-与浏览器-javascript-并行调试">Node.js 与浏览器 JavaScript 并行调试</h2><p>Chrome DevTools 已经进一步发展，打开具有特定网址的单独页面以调试 Node.js 代码的步骤已非必须。</p>
<p>这意味着，今天你可以在同一个 DevTools 窗口中并行调试浏览器 JavaScript 文件和 Node.js，这有着完美的意义。</p>
<h3 id="开启-devtools-实验特性">开启 DevTools 实验特性</h3><p>目前 Chrome 浏览器 JavaScript 和 Node.js 代码的并行调试是一个实验性的新功能。</p>
<p>要启用它，您必须执行以下操作：</p>
<ul>
<li>打开 <a href="chrome://flags/#enable-devtools-experiments">chrome://flags/#enable-devtools-experiments</a> URL</li>
<li>启用 <code>Developer Tools experiments</code> 标志</li>
<li>重启 Chrome</li>
<li>打开 DevTools 设置 -&gt; Experiments 选项（在重启之后它开始可见）</li>
<li>按6次 &quot;SHIFT&quot; 以显示隐藏的实验功能</li>
<li>选中 &quot;Node debugging&quot;</li>
<li>打开/关闭 DevTools</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/6b4c087fgy1fcoxl9cy10j20zk10sn1m.jpg" alt="Enable DevTools Experiments"></p>
<h3 id="debug">Debug</h3><p>开始 debugging，像上面一样以 debug mode 启动 Node.js：</p>
<pre>node --inspect server.js</pre><p>像平时一样在 Chrome 打开您的页面和 DevTools，选择 Sources -&gt; 按 <code>ESC</code> 开启 Console -&gt; 在 debugger 面板中点击 connect 连接 <code>NodeJS Main Context</code>：
<img src="http://wx3.sinaimg.cn/mw690/6b4c087fgy1fcoxlafw3fj20zk0yyaha.jpg" alt="Node.js debugging"></p>
<p>如果您的 Node.js 应用有 console.log 或类似输出，您会看到，它们已经出现在 Chrome DevTools console。然后，你可以同时给浏览器和 Node.js 文件设置断点进行 debug。</p>
<h2 id="总结">总结</h2><p>如果您的项目使用 Node.js，现在您可以从一个地方调试和更改所有 JavaScript - Chrome DevTools。</p>
<p>您还可以将 Chrome DevTools 的所有强大功能应用于 Node.js 代码。</p>
<h2 id="参考链接">参考链接</h2><ul>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html">Node.js Debugger</a></li>
<li><a href="https://github.com/nodejs/node/pull/6792">Add V8_inspector support</a></li>
<li><a href="https://github.com/node-inspector/node-inspector">Node Inspector</a></li>
<li><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27#.fuwv7r5ex">Debugging Node.js with Chrome DevTools</a></li>
<li><a href="https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools">Node.js debugging with Chrome DevTools (in parallel with browser JavaScript)</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[[译] 使用 bash shell 编写脚本的快速指南（翻译中...）]]></title>
        <link href="http://7anshuai.js.org/blog/work/bash-tute.html"/>
        <published>2017-02-06T00:00:00.000Z</published>
        <updated>2017-02-06T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/bash-tute.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <h2 id="简单的-shell-脚本">简单的 shell 脚本</h2><p>A shell script is little more than a list of commands that are run in sequence. Conventionally, a shellscript should start with a line such as the following:</p>
<pre>#!/bin/bash</pre><p>This indicates that the script should be run in the bash shell regardless of which interactive shell the user has chosen. This is very important, since the syntax of different shells can vary greatly.</p>
<h3 id="a-simple-example">A simple example</h3><p>Here&#39;s a very simple example of a shell script. It just runs a few simple commands</p>
<pre>#!/bin/bash
echo &quot;hello, $USER. I wish to list some files of yours&quot;
echo &quot;listing files in the current directory, $PWD&quot;
ls  # list files</pre><p>Firstly, notice the comment on line 4. In a bash script, anything following a pound sign # (besides the shell name on the first line) is treated as a comment. ie the shell ignores it. It is there for the benifit of people reading the script.</p>
<p><code>$USER</code> and <code>$PWD</code> are <em>variables</em>. These are standard variables defined by the bash shell itself, they needn&#39;t be defined in the script. Note that the variables are <em>expanded</em> when the variable name is inside double quotes. Expanded is a very appropriate word: the shell basically sees the string $USER and replaces it with the variable&#39;s value then executes the command.</p>
<p>We continue the discussion on variables below ...</p>
<h2 id="variables">Variables</h2><p>Any programming language needs variables. You define a variable as follows:</p>
<pre>X=&quot;hello&quot;</pre><p>and refer to it as follows:</p>
<pre>$X</pre><p>More specifically, <code>$X</code> is used to denote the value of the variable <code>X</code>. Some things to take note of regarding semantics:</p>
<ul>
<li>bash gets unhappy if you leave a space on either side of the <code>=</code> sign. For example, the following gives an error message:<pre>X = hello</pre></li>
<li>while I have quotes in my example, they are not always necessary. where you need quotes is when your variable names include spaces. For example,<pre>X=hello world # error
X=&quot;hello world&quot; # OK</pre></li>
</ul>
<p>This is because the shell essentially sees the command line as a pile of commands and command arguments seperated by spaces. <code>foo=baris</code> considered a command. The problem with <code>foo = bar</code> is the shell sees the word <code>foo</code> seperated by spaces and interprets it as a command. Likewise, the problem with the command <code>X=hello world</code> is that the shell interprets <code>X=hello</code> as a command, and the word &quot;world&quot; does not make any sense (since the assignment command doesn&#39;t take arguments).</p>
<h3 id="single-quotes-versus-double-quotes">Single Quotes versus double quotes</h3><p>Basically, variable names are exapnded within double quotes, but not single quotes. If you do not need to refer to variables, single quotes are good to use as the results are more predictable.</p>
<p>An example</p>
<pre>#!/bin/bash
echo -n &#39;$USER=&#39; # -n option stops echo from breaking the line
echo &quot;$USER&quot;
echo &quot;\$USER=$USER&quot;  # this does the same thing as the first two lines</pre><p>The output looks like this (assuming your username is elflord)</p>
<pre>$USER=elflord

$USER=elflord</pre><p>so the double quotes still have a work around. Double quotes are more flexible, but less predictable. Given the choice between single quotes and double quotes, use single quotes.</p>
<h3 id="using-quotes-to-enclose-your-variables">Using Quotes to enclose your variables</h3><p>Sometimes, it is a good idea to protect variable names in double quotes. This is usually the most important if your variables value either (a) contains spaces or (b) is the empty string. An example is as follows:</p>
<pre>#!/bin/bash
X=&quot;&quot;
if [ -n $X ]; then  # -n tests to see if the argument is non empty
  echo &quot;the variable X is not the empty string&quot;
fi</pre><p>This script will give the following output:
the variable X is not the empty string
Why ? because the shell expands $X to the empty string. The expression [ -n ] returns true (since it is not provided with an argument). A better script would have been:</p>
<pre>#!/bin/bash
X=&quot;&quot;
if [ -n &quot;$X&quot; ]; then  # -n tests to see if the argument is non empty
  echo &quot;the variable X is not the empty string&quot;
fi</pre><p>In this example, the expression expands to [ -n &quot;&quot; ] which returns false, since the string enclosed in inverted commas is clearly empty.</p>
<h3 id="variable-expansion-in-action">Variable Expansion in action</h3><p>Just to convince you that the shell really does &quot;expand&quot; variables in the sense I mentioned before, here is an example:</p>
<pre>#!/bin/bash
LS=&quot;ls&quot;
LS_FLAGS=&quot;-al&quot;

$LS $LS_FLAGS $HOME</pre><p>This looks a little enigmatic. What happens with the last line is that it actually executes the command
ls -al /home/elflord
(assuming that /home/elflord is your home directory). That is, the shell simply replaces the variables with their values, and then executes the command.
Using Braces to Protect Your Variables</p>
<p>OK. Here&#39;s a potential problem situation. Suppose you want to echo the value of the variable X, followed immediately by the letters &quot;abc&quot;. Question: how do you do this ? Let&#39;s have a try:</p>
<pre>#!/bin/bash
X=ABC
echo &quot;$Xabc&quot;</pre><p>THis gives no output. What went wrong ? The answer is that the shell thought that we were asking for the variable Xabc, which is uninitialised. The way to deal with this is to put braces around X to seperate it from the other characters. The following gives the desired result:</p>
<pre>#!/bin/bash
X=ABC
echo &quot;${X}abc&quot;</pre><h2 id="conditionals-if-then-elif">Conditionals, if/then/elif</h2><p>Sometimes, it&#39;s necessary to check for certain conditions. Does a string have 0 length ? does the file &quot;foo&quot; exist, and is it a symbolic link , or a real file ? Firstly, we use the if command to run a test. The syntax is as follows:
if condition
then
  statement1
  statement2
  ..........
fi
Sometimes, you may wish to specify an alternate action when the condition fails. Here&#39;s how it&#39;s done.
if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi
alternatively, it is possible to test for another condition if the first &quot;if&quot; fails. Note that any number of elifs can be added.
if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........<br>elif condition3
then
  statement5
  statement6
  ........    </p>
<p>fi
The statements inside the block between if/elif and the next elif or fi are executed if the corresponding condition is true. Actually, any command can go in place of the conditions, and the block will be executed if and only if the command returns an exit status of 0 (in other words, if the command exits &quot;succesfully&quot; ). However, in the course of this document, we will be only interested in using &quot;test&quot; or &quot;[ ]&quot; to evaluate conditions.</p>
<h2 id="the-test-command-and-operators">The Test Command and Operators</h2><p>The command used in conditionals nearly all the time is the test command. Test returns true or false (more accurately, exits with 0 or non zero status) depending respectively on whether the test is passed or failed. It works like this:
test operand1 operator operand2
for some tests, there need be only one operand (operand2) The test command is typically abbreviated in this form:
[ operand1 operator operand2 ]
To bring this discussion back down to earth, we give a few examples:</p>
<pre>#!/bin/bash
X=3
Y=4
empty_string=&quot;&quot;
if [ $X -lt $Y ]  # is $X less than $Y ?
then
  echo &quot;\$X=${X}, which is smaller than \$Y=${Y}&quot;
fi

if [ -n &quot;$empty_string&quot; ]; then
  echo &quot;empty string is non_empty&quot;
fi

if [ -e &quot;${HOME}/.fvwmrc&quot; ]; then       # test to see if ~/.fvwmrc exists
  echo &quot;you have a .fvwmrc file&quot;
  if [ -L &quot;${HOME}/.fvwmrc&quot; ]; then     # is it a symlink ?  
    echo &quot;it&#39;s a symbolic link
  elif [ -f &quot;${HOME}/.fvwmrc&quot; ]; then   # is it a regular file ?
    echo &quot;it&#39;s a regular file&quot;
  fi
else
  echo &quot;you have no .fvwmrc file&quot;
fi</pre><p>Some pitfalls to be wary of</p>
<p>The test command needs to be in the form &quot;operand1<space>operator<space>operand2&quot; or operator<space>operand2 , in other words you really need these spaces, since the shell considers the first block containing no spaces to be either an operator (if it begins with a &#39;-&#39;) or an operand (if it doesn&#39;t). So for example; this</p>
<p>if [ 1=2 ]; then
  echo &quot;hello&quot;
fi
gives exactly the &quot;wrong&quot; output (ie it echos &quot;hello&quot;, since it sees an operand but no operator.)
Another potential trap comes from not protecting variables in quotes. We have already given an example as to why you must wrap anything you wish to use for a -n test with quotes. However, there are a lot of good reasons for using quotes all the time, or almost all of the time. Failing to do this when you have variables expanded inside tests can result in very wierd bugs. Here&#39;s an example: For example,</p>
<pre>#!/bin/bash
X=&quot;-n&quot;
Y=&quot;&quot;
if [ $X = $Y ] ; then
  echo &quot;X=Y&quot;
fi</pre><p>This will give misleading output since the shell expands our expression to
[ -n = ]
and the string &quot;=&quot; has non zero length.</p>
<h3 id="a-brief-summary-of-test-operators">A brief summary of test operators</h3><p>Here&#39;s a quick list of test operators. It&#39;s by no means comprehensive, but its likely to be all you&#39;ll need to remember (if you need anything else, you can always check the bash manpage ... )
operator  produces true if... number of operands
-n  operand non zero length 1
-z  operand has zero length 1
-d  there exists a directory whose name is operand  1
-f  there exists a file whose name is operand 1
-eq the operands are integers and they are equal  2
-neq  the opposite of -eq 2
= the operands are equal (as strings) 2
!=  opposite of = 2
-lt operand1 is strictly less than operand2 (both operands should be integers)  2
-gt operand1 is strictly greater than operand2 (both operands should be integers) 2
-ge operand1 is greater than or equal to operand2 (both operands should be integers)  2
-le operand1 is less than or equal to operand2 (both operands should be integers) 2</p>
<h2 id="loops">Loops</h2><p>Loops are constructions that enable one to reiterate a procedure or perform the same procedure on several different items. There are the following kinds of loops available in bash</p>
<ul>
<li>for loops</li>
<li>while loops</li>
</ul>
<h3 id="for-loops">For loops</h3><p>The syntax for the for loops is best demonstrated by example.</p>
<pre>#!/bin/bash
for X in red green blue
do
  echo $X
done</pre><p>THe for loop iterates the loop over the space seperated items. Note that if some of the items have embedded spaces, you need to protect them with quotes. Here&#39;s an example:</p>
<pre>#!/bin/bash
colour1=&quot;red&quot;
colour2=&quot;light blue&quot;
colour3=&quot;dark green&quot;
for X in &quot;$colour1&quot; $colour2&quot; $colour3&quot;
do
  echo $X
done</pre><p>Can you guess what would happen if we left out the quotes in the for statement ? This indicates that variable names should be protected with quotes unless you are pretty sure that they do not contain any spaces.
Globbing in for loops</p>
<p>The shell expands a string containing a <em> to all filenames that &quot;match&quot;. A filename matches if and only if it is identical to the match string after replacing the stars </em> with arbitrary strings. For example, the character &quot;*&quot; by itself expands to a space seperated list of all files in the working directory (excluding those that start with a dot &quot;.&quot; ) So</p>
<p>echo <em>
lists all the files and directories in the current directory.
echo </em>.jpg
lists all the jpeg files.
echo ${HOME}/public_html/*.jpg
lists all jpeg files in your public_html directory.
As it happens, this turns out to be very useful for performing operations on the files in a directory, especially used in conjunction with a for loop. For example:</p>
<pre>#!/bin/bash
for X in *.html
do
    grep -L &#39;&lt;UL&gt;&#39; &quot;$X&quot;
done</pre><h3 id="while-loops">While Loops</h3><p>While loops iterate &quot;while&quot; a given condition is true. An example of this:</p>
<pre>#!/bin/bash
X=0
while [ $X -le 20 ]
do
  echo $X
  X=$((X+1))
done</pre><p>This raises a natural question: why doesn&#39;t bash allow the C like for loops</p>
<p>for (X=1,X&lt;10; X++)
As it happens, this is discouraged for a reason: bash is an interpreted language, and a rather slow one for that matter. For this reason, heavy iteration is discouraged.
Command Substitution</p>
<p>Command Substitution is a very handy feature of the bash shell. It enables you to take the output of a command and treat it as though it was written on the command line. For example, if you want to set the variable X to the output of a command, the way you do this is via command substitution.</p>
<p>There are two means of command substitution: brace expansion and backtick expansion.</p>
<p>Brace expansion workls as follows: $(commands) expands to the output of commands This permits nesting, so commands can include brace expansions</p>
<p>Backtick expansion expands <code>commands</code> to the output of commands</p>
<p>An example is given;:</p>
<pre>#!/bin/bash
files=&quot;$(ls)&quot;
web_files=`ls public_html`
echo &quot;$files&quot;      # we need the quotes to preserve embedded newlines in $files
echo &quot;$web_files&quot;  # we need the quotes to preserve newlines
X=`expr 3 \* 2 + 4` # expr evaluate arithmatic expressions. man expr for details.
echo &quot;$X&quot;</pre><p>The advantage of the $() substitution method is almost self evident: it is very easy to nest. It is supported by most of the bourne shell varients (the POSIX shell or better is OK). However, the backtick substitution is slightly more readable, and is supported by even the most basic shells (any #!/bin/sh version is just fine)</p>
<p>Note that if strings are not quote-protected in the above echo statement, new lines are replaced by spaces in the output.</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[通过 Nginx 给本地应用取个漂亮域名]]></title>
        <link href="http://7anshuai.js.org/blog/work/nginx-and-pretty-domains.html"/>
        <published>2016-09-19T00:00:00.000Z</published>
        <updated>2016-09-19T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/nginx-and-pretty-domains.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>简单记录下之前看到并实践的一篇文章 <a href="http://zaiste.net/2013/03/serving_apps_locally_with_nginx_and_pretty_domains/">Serving Apps Locally with Nginx and Pretty Domains</a>。在 Mac OS X 上通过配置 Nginx 实现本地应用可以通过漂亮的域名来访问，比如 <code>http://anapp.dev/</code>。类似的解决方案有 <a href="http://pow.cx">pow</a> - Mac OS X 上的零配置 Rake Server。</p>
<h2 id="nginx">Nginx</h2><p>首先需要关掉 Apache 进程（Mac OS X 上默认启动 Apache 监听 <code>80</code> 端口）：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist</code></pre></div><p>使用 Homebrew 安装 Nginx ：</p>
<div class="highlight"><pre><code class="bash">brew install nginx</code></pre></div><p>Nginx 监听 <code>80</code>（或任何小于 <code>1024</code> 的）端口需要使用 <code>sudo</code> 命令，否则会启动失败。对于大于 <code>1024</code> 的端口，如下直接为启动脚本建立一个符号链接：</p>
<div class="highlight"><pre><code class="bash">ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist</code></pre></div><p>对于 HTTP 默认端口，需要在 <code>/usr/local/etc/nginx.conf</code> 中将 <code>listen</code> 的值从 <code>8080</code> 修改为 <code>80</code>。</p>
<pre>server {
     …
     listen 80;
     server_name localhost;
     …
}</pre><p>小于 <code>1024</code> 的端口不能为启动脚本建立符号链接，必须将脚本拷贝到 <code>/Library/LaunchAgents</code>。</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist /Library/LaunchAgents</code></pre></div><p>在 <code>homebrew.mxcl.nginx.plist</code> 中，需要将 <code>UserName</code> 项修改为 <code>root</code>。为了方便，还可以将 <code>Label</code> 项修改为 <code>nginx</code>，这样就可以使用</p>
<div class="highlight"><pre><code class="bash">launchctl start nginx</code></pre></div><p>代替</p>
<div class="highlight"><pre><code class="bash">launchctl start homebrew.mxcl.nginx</code></pre></div><h2 id="本地-dns">本地 DNS</h2><p>接下来是设置一个本地的 DNS。因为不能在 <code>/etc/hosts</code> 文件中使用通配符，无法实现类似功能：</p>
<pre>127.0.0.1      *.dev.</pre><p>为了解决这个问题，需要安装一个叫做 <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">DNSMasq</a> 的 DNS 代理：</p>
<div class="highlight"><pre><code class="bash">brew install dnsmasq</code></pre></div><p>配置文件存储在 <code>/usr/local/etc/</code> 下的 <code>dnsmasq.conf</code> ：</p>
<div class="highlight"><pre><code class="bash">touch /usr/local/etc/dnsmasq.conf</code></pre></div><p>在文件中写入：</p>
<pre>address=/.dev/127.0.0.1</pre><p>这样所有 <code>*.dev</code> 的站点会被重定向到本地 IP，即 <code>127.0.0.1</code>。
类似 Nginx 进程，<code>dnsmasq</code> 需要 <code>root</code> 权限：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> cp -fv /usr/local/opt/dnsmasq/*.plist /Library/LaunchDaemons
<span class="built_in">sudo</span> launchctl load /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist</code></pre></div><p>然后，需要配置 OSX 使用本地系统作为首要 DNS 服务器。进入系统设置 -&gt; 网络，在 DNS 配置中将回环 IP (即 <code>127.0.0.1</code>)作为第一行，然后是惯例的 DNS IP：</p>
<pre>127.0.0.1
8.8.8.8
8.8.4.4</pre><p>现在，试着 <code>ping</code> 任何以 <code>.dev</code> 结尾的地址，应该返回的 IP 地址是 <code>127.0.0.1</code>：</p>
<div class="highlight"><pre><code class="bash">$ ping example.dev
PING example.dev (<span class="number">127.0</span>.<span class="number">0.1</span>): <span class="number">56</span> data bytes</code></pre></div><h2 id="虚拟主机">虚拟主机</h2><p>关于虚拟主机配置，按照惯例在 <code>/usr/local/etc/nginx/</code> 下创建两个目录 <code>sites-enabled</code> 和 <code>sites-available</code>：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">cd</span> /usr/local/etc/nginx
mkdir sites-available
mkdir sites-enabled</code></pre></div><p>在 <code>nginx.conf</code> 中的 <code>http</code> 部分，需要加入以下行：</p>
<pre>include sites-enabled/*.dev;</pre><h3 id="后端参与的项目配置">后端参与的项目配置</h3><p>现在可以指定每一个 app 的配置了。看一下配置模板文件：</p>
<pre>upstream NAME {
    server 127.0.0.1:3000;
}

server {
    listen 80;
    server_name NAME.dev;
    root PATH_TO_PUBLIC;

    try_files $uri/index.html $uri.html $uri @app;

    location @app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;

      proxy_pass http://NAME;
    }
}</pre><p>为了使它工作起来，至少需要修改两个地方，即 <code>NAME</code> 和 <code>PATH_TO_PUBLIC</code>。 <code>NAME</code> 可以是应用程序名称。 <code>PATH_TO_PUBLIC</code> 则指定项目静态资源目录，例如在 Express 中的路径为 <code>public</code>。
配置文件需要放在 <code>sites-available</code> 下，然后需要链接到 <code>sites-enabled</code>，例如：</p>
<div class="highlight"><pre><code class="bash">ln <span class="operator">-s</span> /usr/local/etc/nginx/sites-available/anapp.dev \
  /usr/local/etc/nginx/sites-enabled/anapp.dev</code></pre></div><p>建立链接后，需要重启 Nginx：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> launchctl stop nginx
<span class="built_in">sudo</span> launchctl start nginx</code></pre></div><h3 id="无后端参与的项目配置">无后端参与的项目配置</h3><p>以上的配置文件对于纯静态的项目来说是不必要的。可以通过位于 <code>/usr/local/etc/nginx/nginx.conf</code> 中默认的 <code>server</code> 指令设置一个动态的应用程序分发。Nginx 会在定义的基础路径中查找匹配被请求的域名目录。如在以下例子中， <code>appname.dev</code> 会匹配 <code>/Users/zaiste/dev</code> 下一个叫做 <code>appname</code> 的目录：</p>
<pre>server {
    listen       80;
    server_name  app localhost .dev;

    set $basepath &quot;/Users/zaiste/dev&quot;;

    set $domain $host;
    if ($domain ~ &quot;^(.*)\.dev$&quot;) {
        set $domain $1;
    }
    set $rootpath &quot;${domain}&quot;;
    if (-d $basepath/$domain/public) {
        set $rootpath &quot;${domain}/public&quot;;
    }
    if (-f $basepath/$domain/index.html) {
        set $rootpath $domain;
    }

    root $basepath/$rootpath;

    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}</pre><p>现在，只需要在 <code>/Users/zaiste/dev</code> 创建一个新的目录及相应的 HTML 文件，剩下的事情就交给 Nginx 了。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://zaiste.net/2013/03/serving_apps_locally_with_nginx_and_pretty_domains/">Serving Apps Locally with Nginx and Pretty Domains</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Bash 中解析命令行参数]]></title>
        <link href="http://7anshuai.js.org/blog/work/parse-command-line-arguments-in-bash.html"/>
        <published>2016-04-22T00:00:00.000Z</published>
        <updated>2016-04-22T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/parse-command-line-arguments-in-bash.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>最近的一个前端小项目是智能 Wi-Fi 音箱 <a href="http://sugrsugr.com">Sugr Cube</a> 中的 Web 上传歌曲界面，使用了 Require.js 组织代码，文件上传部分基于 <a href="https://github.com/blueimp/jQuery-File-Upload">jQuery File Upload</a>。Web page 编写完后需要使用 r.js 打包处理下，并将生成的文件上传到硬件设备里的 <a href="https://github.com/ankushagarwal/nweb">Nweb</a> 目录下。</p>
<h2 id="项目结构">项目结构</h2><pre>|--node_modules
|  |-- blueimp-file-upload-node
|  |  本地文件上传服务器
|  |-- requirejs
|  |  requirejs optimizer (r.js)
|  |-- inliner
|  |  Node utility to inline images, CSS and JavaScript for a web page
|--public
|  静态文件（css，js，images等）
|-- package.json
|  npm 项目配置
|-- index.html</pre><h2 id="npm-scripts">npm scripts</h2><p>编写 <a href="https://docs.npmjs.com/misc/scripts">npm scripts</a> 用来运行相关脚本：</p>
<div class="highlight"><pre><code class="javascript">{
  ...,
  <span class="string">"scripts"</span>: {
    <span class="string">"build"</span>: <span class="string">"r.js -o baseUrl=public/js paths.requireLib=require paths.jquery=jquery name=app include=requireLib out=public/js/app-built.js"</span>,
    <span class="string">"inliner"</span>: <span class="string">"inliner -vs index.html &gt; www/index.html"</span>,
    <span class="string">"server"</span>: <span class="string">"node node_modules/blueimp-file-upload-node/server.js"</span>,
    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  },
  ...
}</code></pre></div><p>OK，页面开发完后运行相应的命令 <code>npm run build</code>，<code>npm run inliner</code> 之后，再将生成好的单一 HTML 文件（www/index.html）scp 到硬件设备的文件 www 目录下。那么问题来了，调试过程中需要频繁的重复这一过程，而且硬件设备的局域网 IP 地址也常会发生变化，我需要个一键部署的 shell 脚本，比如这样：</p>
<pre>./publish --user root --host 192.168.1.99</pre><h2 id="bash-script">Bash script</h2><p>如何编写一个能接受命令行参数的 Bash 脚本？在 stackoverflow 上找到大家推荐的方法：使用没有 getopt[s] 的 straight bash。</p>
<h3 id="空格分离的-straight-bash">空格分离的 Straight Bash</h3><p>使用方法：<code>./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts</code></p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="comment"># Use -gt 1 to consume two arguments per pass in the loop (e.g. each</span>
<span class="comment"># argument has a corresponding value to go with it).</span>
<span class="comment"># Use -gt 0 to consume one or more arguments per pass in the loop (e.g.</span>
<span class="comment"># some arguments don't have a corresponding value to go with it such</span>
<span class="comment"># as in the --default example).</span>
<span class="comment"># note: if this is set to -gt 0 the /etc/hosts part is not recognized ( may be a bug )</span>
<span class="keyword">while</span> [[ <span class="variable">$#</span> <span class="operator">-gt</span> <span class="number">1</span> ]]
<span class="keyword">do</span>
key=<span class="string">"<span class="variable">$1</span>"</span>

<span class="keyword">case</span> <span class="variable">$key</span> <span class="keyword">in</span>
    <span class="operator">-e</span>|--extension)
    EXTENSION=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    <span class="operator">-s</span>|--searchpath)
    SEARCHPATH=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    <span class="operator">-l</span>|--lib)
    LIBPATH=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    --default)
    DEFAULT=YES
    ;;
    *)
            <span class="comment"># unknown option</span>
    ;;
<span class="keyword">esac</span>
shift <span class="comment"># past argument or value</span>
<span class="keyword">done</span>
<span class="built_in">echo</span> FILE EXTENSION  = <span class="string">"<span class="variable">${EXTENSION}</span>"</span>
<span class="built_in">echo</span> SEARCH PATH     = <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>
<span class="built_in">echo</span> LIBRARY PATH    = <span class="string">"<span class="variable">${LIBPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"Number files in SEARCH PATH with EXTENSION:"</span> $(ls -<span class="number">1</span> <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>/*.<span class="string">"<span class="variable">${EXTENSION}</span>"</span> | wc <span class="operator">-l</span>)
<span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"Last line of file specified as non-opt/last argument:"</span>
    tail -<span class="number">1</span> <span class="variable">$1</span>
<span class="keyword">fi</span></code></pre></div><h3 id="等号分离的-straight-bash">等号分离的 Straight Bash</h3><p>使用方法：<code>./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts</code></p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash
</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>
<span class="keyword">do</span>
<span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span>
    <span class="operator">-e</span>=*|--extension=*)
    EXTENSION=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    <span class="operator">-s</span>=*|--searchpath=*)
    SEARCHPATH=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    <span class="operator">-l</span>=*|--lib=*)
    LIBPATH=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    --default)
    DEFAULT=YES
    shift <span class="comment"># past argument with no value</span>
    ;;
    *)
            <span class="comment"># unknown option</span>
    ;;
<span class="keyword">esac</span>
<span class="keyword">done</span>
<span class="built_in">echo</span> <span class="string">"FILE EXTENSION  = <span class="variable">${EXTENSION}</span>"</span>
<span class="built_in">echo</span> <span class="string">"SEARCH PATH     = <span class="variable">${SEARCHPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"LIBRARY PATH    = <span class="variable">${LIBPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"Number files in SEARCH PATH with EXTENSION:"</span> $(ls -<span class="number">1</span> <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>/*.<span class="string">"<span class="variable">${EXTENSION}</span>"</span> | wc <span class="operator">-l</span>)
<span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"Last line of file specified as non-opt/last argument:"</span>
    tail -<span class="number">1</span> <span class="variable">$1</span>
<span class="keyword">fi</span></code></pre></div><p>为了更好的理解 <code>${i#*=}</code> 可在<a href="http://tldp.org/LDP/abs/html/string-manipulation.html">这篇指南</a>中查找 &quot;Substring Removal&quot;。它的功能等同于 <code>sed &#39;s/[^=]*=//&#39; &lt;&lt;&lt; &quot;$i&quot;</code>（调用了一个不必要的子进程）或者 <code>echo &quot;$i&quot; | sed &#39;s/[^=]*=//&#39;</code>（调用了两个不必要的子进程）。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://www.panix.com/~elflord/unix/bash-tute.html">A quick guide to writing scripts using the bash shell</a></li>
<li><a href="http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash">How do I parse command line arguments in bash?</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[[译] 为 Node.js 包准备的 Makefile]]></title>
        <link href="http://7anshuai.js.org/blog/work/makefile-recipes-for-nodejs.html"/>
        <published>2015-04-12T00:00:00.000Z</published>
        <updated>2015-04-12T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/makefile-recipes-for-nodejs.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 <code>make</code> 程序来完成这些任务，主要是因为它的简单明了。</p>
<p>要开始使用 <code>make</code> 你需要在项目根目录创建一个 <code>Makefile</code>。<code>Makefile</code> 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 <code>make &lt;task name&gt;</code>。简单吧！</p>
<p>以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 <code>Makefile</code> 文件。我会一步一步的完成它。</p>
<p>首先是定义一些有用的变量：我在 <code>src</code> 保存源码，编译过的代码放在 <code>lib</code>（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。</p>
<pre>BIN = ./node_modules/.bin
SRC = $(wildcard src/*.coffee)
LIB = $(SRC:src/%.coffee=lib/%.js)</pre><p><code>SRC</code> 将会包含一个 <code>src</code> 目录中的 <code>.coffee</code> 文件列表，然后 <code>LIB</code> － 一个相对应的 <code>.js</code> 文件列表（目前还不存在）。<code>$(VAR:pattern1=pattern2)</code> 使用来指定存储在变量中的每一个项的变换。</p>
<p>所以如果我们保存 <code>src/index.coffee src/mod.coffee</code> 在文件系统中， <code>SRC</code> 会捕获它们然后相应的使 <code>LIB</code> 保存 <code>lib/index.js lib/mod.js</code> 。</p>
<p><code>BIN</code> 指向 Node 本地可执行模块的安装目录。</p>
<h2 id="构建">构建</h2><p>现在让我们定义第一个任务构建并表明它依赖于存储在 <code>LIB</code> 变量的所有文件。</p>
<div class="highlight"><pre><code class="bash">build: $(LIB)</code></pre></div><p>很简单，对不对？<code>$(LIB)</code> 只是在 <code>make</code> 中间接引用变量的语法。</p>
<p>运行 <code>make build</code> 后，程序会尝试确保 <code>LIB</code> 中的所有文件都已就位并及时更新。但是我们如何让 <code>make</code> 知道怎样在 <code>SRC</code> 中获取相应的文件，处理并将所有的这些文件放入 <code>LIB</code> 中呢？</p>
<p>接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － <code>lib/%.js</code> － 正是这个模式将会在 <code>LIB</code> 变量中进行文件匹配。</p>
<div class="highlight"><pre><code class="bash">lib/%.js: src/%.coffee
  @mkdir -p $(@D)
  @$(BIN)/coffee -bcp $&lt; &gt; <span class="variable">$@</span></code></pre></div><p>这条规则告诉 <code>make</code> 那些 <code>lib/%.js</code> 文件依赖于相应的 <code>src/%.coffee</code> 文件，所以如果当后者发生改变时 <code>make</code> 会重新编译生成前者。</p>
<p>它是如何工作的？首先，它创建了一个目标文件的目录（<code>$(@D)</code> 表示这个目录，它是 <code>make</code> 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 <code>.coffee</code> 文件（通过 <code>$&lt;</code> 表示）并将结果写入目标文件（通过 <code>$@</code> 表示）。</p>
<p>注意 @ 前缀，默认的 <code>make</code> 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。</p>
<p>足够作为一个构建程序了，<code>make build</code> 会从 src 目录下将相应的文件重新构建到 lib 目录下。</p>
<h2 id="测试">测试</h2><p>测试任务很简单：</p>
<div class="highlight"><pre><code class="bash">test: build
  @$(BIN)/mocha -b specs</code></pre></div><p>我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。</p>
<h2 id="辅助任务">辅助任务</h2><p>接下来到辅助任务 － <code>clean</code> 用来清除所有编译生成的代码：</p>
<div class="highlight"><pre><code class="bash">clean:
  @rm <span class="operator">-f</span> $(LIB)</code></pre></div><p><code>install</code> 和 <code>link</code> 任务是简单的运行相应的 <code>npm</code> 子命令：</p>
<div class="highlight"><pre><code class="bash">install link:
  @npm <span class="variable">$@</span>;</code></pre></div><p>注音 <code>$@</code> 变量的使用技巧，它是如何传递任务名称作为 <code>npm</code> 的子命令。</p>
<h2 id="版本">版本</h2><p>下一个是版本任务。</p>
<p>下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。</p>
<div class="highlight"><pre><code class="bash">define release
  VERSION=`node -pe <span class="string">"require('./package.json').version"</span>` &amp;&amp; \
  NEXT_VERSION=`node -pe <span class="string">"require('semver').inc(\"$<span class="variable">$VERSION</span>\", '<span class="variable">$(1)</span>')"</span>` &amp;&amp; \
  node <span class="operator">-e</span> <span class="string">"\
    var j = require('./package.json');\
    j.version = \"$<span class="variable">$NEXT_VERSION</span>\";\
    var s = JSON.stringify(j, null, 2);\
    require('fs').writeFileSync('./package.json', s);"</span> &amp;&amp; \
  git commit -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span> -- package.json &amp;&amp; \
  git tag <span class="string">"$<span class="variable">$NEXT_VERSION</span>"</span> -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span>
endef</code></pre></div><p>简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 <code>$1</code> 变量定义的）重写了 <code>package.json</code>，然后创建了一个相应的 <code>git commit</code> 和 <code>git tag</code>。</p>
<p>接下啦只需要通过传递 <code>patch</code>，<code>minor</code> 或者 <code>major</code> 参数调用 <code>release</code> 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。</p>
<div class="highlight"><pre><code class="bash">release-patch: build test
  @$(call release,patch)

release-minor: build test
  @$(call release,minor)

release-major: build test
  @$(call release,major)</code></pre></div><p>最后一点是 <code>publish</code> 任务，它用来推送代码到仓库，并发布包到 npm。</p>
<div class="highlight"><pre><code class="bash">publish:
  git push --tags origin HEAD:master
  npm publish</code></pre></div><p>现在发布一个新的次要版本只需要在命令行执行 <code>make release-minor publish</code> － <code>package.json</code> 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。</p>
<p>完整的 <code>Makefile</code> 在 <a href="https://gist.github.com/5588256">这里</a>。</p>
<p>原文链接：<a href="https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html">Makefile recipes for Node.js packages</a></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[28 年华]]></title>
        <link href="http://7anshuai.js.org/blog/life/28-years-old.html"/>
        <published>2015-04-06T00:00:00.000Z</published>
        <updated>2015-04-06T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/life/28-years-old.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>清明小假，昏昏沉沉的在房间宅了几天。真的挺浪费了外面的阳光。</p>
<p>最近一阵子的心情和状态都很低落的样子。工作上也是马马虎虎，或许停下来休息下是个不错的选择。这样可以回家住上几天，吃爸妈做的家常饭菜，看几本书，简单自然的。</p>
<p>今天28了，之前的这些年，感觉挺2B的。未来可以怎样，我无法知道。但不管18还是28，都应该好好珍惜才是。</p>
<p>祝自己生日快乐！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Node.js 中使用 Asset Pipeline]]></title>
        <link href="http://7anshuai.js.org/blog/work/assets-pipeline-on-nodejs.html"/>
        <published>2015-03-16T14:03:07.000Z</published>
        <updated>2015-03-16T14:03:07.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/assets-pipeline-on-nodejs.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>-- Phil Karlton</p>
</blockquote>
<p>计算机科学只有两个难题：缓存失效和变量命名。</p>
<p><em>Coding</em> 中，这两道难题确实无处不在。难题之一缓存失效，Web 中的资源缓存涉及到服务器和浏览器两端的各种缓存机制（详情可阅读腾讯 AlloyTeam 的博客 <a href="http://alloyteam.com/2012/03/web-cache-1-web-cache-overview/">Web 缓存机制系列</a>）。当 Web 应用进行版本更新时，需要发布新的资源文件并更新缓存。那怎么让 Web 浏览器中原有的缓存失效，加载新的资源文件并缓存到客户端的计算机上呢？常见的两种做法是：</p>
<ul>
<li>传统手工作业</li>
<li>基于日期的请求字符串</li>
</ul>
<p>这两种方法都有明显的缺点，手动控制文件版本的做法通常是这样的：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.1/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.2/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>基于日期的请求字符串：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349480"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349481"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>这两种方法都有明显的缺点,传统手工作业是繁琐低效的，而基于日期的请求字符串的缓存并不可靠。在查看过 <a href="https://github.com/">GitHub</a> 的网页源码后，发现他们组织程序的静态资源方式有所不同：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://assets-cdn.github.com/assets/github-d869f6edeea2dbd9c7c3595e2f31cf8a1530bd36eaa84707461f65c5ee848853.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>文件名后面加上了一串字符串（基于MD5生成），顿觉莫名的高大上啊。偶尔在 <a href="https://ruby-china.org/">Ruby China</a> 闲逛得知，这是 Rails 3.1 版本开始引入的静态资源管理方式 <a href="http://guides.ruby-china.org/asset_pipeline.html">Asset Pipeline</a>。</p>
<h2 id="asset-pipeline-是什么？">Asset Pipeline 是什么？</h2><p>Rails 指南中提到，Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。它提供了三个主要功能：</p>
<ul>
<li>连接合并 JavaScript 和 CSS 文件，减少页面的 HTTP 请求。</li>
<li>压缩 JavaScript 和 CSS 文件（减重瘦身上前线）</li>
<li>高级语言及预处理器支持，允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript。</li>
</ul>
<p>在生产环境中，Rails 通过 Asset Pipeline 技术在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。</p>
<h2 id="md5-指纹">MD5 指纹</h2><p>Rails 指南中详细解释了指纹。指纹可以根据文件内容生成文件名，文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。</p>
<p>如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。</p>
<h2 id="connect-assets">connect-assets</h2><p>不同语言不同框架都有类似 Rails Asset Pipeline 的实现，<a href="https://github.com/adunkman/connect-assets">connect-assets</a> 是为 Node.js 打造的 Asset Pipeline。它也实现了以上所述的三个主要功能：合并，压缩 JavaScript/CSS 文件，高级语言预处理。在 Node.js 中也可以给静态资源添加指纹，使用更有效的缓存技术。</p>
<p>使用方法也很简单，第一步在项目中安装 connect-asset：</p>
<div class="highlight"><pre><code class="bash">npm install connect-assets</code></pre></div><p>第二步，在 Express 应用中添加配置代码：</p>
<div class="highlight"><pre><code class="javascript">app.use(require(<span class="string">'connect-assets'</span>)());</code></pre></div><p>最后，在项目中创建一个 <code>assets</code> 文件夹，并分别将 JavaScript 和 CSS 文件放入 <code>/assets/js</code> 和 <code>/assets/css</code>。</p>
<p>Node.js 应用就可以使用最基本的 connect-assets 功能了。</p>
<h3 id="标记函数">标记函数</h3><p>connect-assets 提供了三个名为 <code>js</code>，<code>css</code>, <code>assetPath</code> 的全局函数，可以在视图文件中使用它们。标记函数返回需要的包含最新版本的静态资源（或资源的路径）HTML 标记。例如，在一个 Jade 模板中的代码：</p>
<pre>!= css(&quot;normalize&quot;)
!= js(&quot;jquery&quot;)</pre><p><code>!=</code> 是 Jade 语法， 用于运行 JS 和显示输出，结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>你可以传递特殊属性给函数 <code>css</code> 或 <code>js</code>：</p>
<pre>!= css(&quot;normalize&quot;, {&quot;data-turbolinks-track&quot;: true})
!= js(&quot;jquery&quot;, {async: true})</pre><p>结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> <span class="attribute">data-turbolinks-track</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="sprockets-风格的合并">Sprockets 风格的合并</h3><p>可以在 <code>.js.coffee</code> 和 <code>.js</code> 文件中使用 Sprockets-style 语法指定依赖关系。</p>
<p>在 CoffeeScript 中：</p>
<div class="highlight"><pre><code class="coffeescript"><span class="comment">#= require dependency</span></code></pre></div><p>在 JavaScript 中：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">//= require dependency</span></code></pre></div><p>当你这样做并在 <code>js</code> 函数中指定该文件，会产生两个效果：</p>
<ul>
<li>默认的你会得到多个 <code>script</code>，按顺序输出你指定的所有依赖。</li>
<li>如果你传递 <code>build: true</code> 选项给 connect-assets（当 <code>env == &#39;production&#39;</code> 时默认开启），你会得到一个单独的标记，它指向一个将所有依赖目标都编译，合并，压缩（通过 UglifyJS）的 JavaScript 文件。</li>
</ul>
<p>如果你想包含整个文件夹的脚本，使用 <code>//= require_tree dir</code> 代替 <code>//= require file</code>。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="http://code.google.com/speed/page-speed/docs/caching.html">Optimize caching</a></li>
<li><a href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Revving Filenames: dont&#39;t use querystring</a></li>
</ul>
<p>周末福利:</p>
<p>豆瓣女神，独立音乐人，北大美女才女 － 程璧的官方主页 <a href="http://www.annapatio.com/">Anna&#39;s Patio</a> 是基于 Ruby on Rails，真心很赞啊！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[基本的命令行编辑技巧]]></title>
        <link href="http://7anshuai.js.org/blog/work/the-basic-command-line-editing.html"/>
        <published>2015-01-26T14:46:54.000Z</published>
        <updated>2015-01-26T14:46:54.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/the-basic-command-line-editing.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>GNU Bash shell 提供了 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html">Command line editing</a> 功能，它是由 <a href="http://tiswww.case.edu/php/chet/readline/rltop.html">Readline library</a> 实现的。Python 交互式命令行和 node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing 支持 Emacs-style 和 Vi-style 的命令风格，默认的是 Emacs-style。</p>
<h2 id="命令行编辑">命令行编辑</h2><p>基本上，Unix/Linux 系统默认就支持 Command line editing，所以打开终端，或者在终端运行 Python interactive 或者 Node REPL，都可以马上使用常规的 Emacs 的控制字符集 <code>Control-*</code> 了。</p>
<ul>
<li><code>C-a</code> （Control-a）移动光标到行首</li>
<li><code>C-e</code> 移动光标到行尾</li>
<li><code>C-b</code> 将光标往左移动一个位置</li>
<li><code>C-f</code> 将光标往右移动一个位置</li>
<li><code>Backspace</code> 你懂得</li>
<li><code>C-d</code> 删除光标右边的一个字符</li>
<li><code>C-k</code> 删除光标右边所有的字符</li>
<li><code>C-y</code> 拉回最后一次删除的字符</li>
<li><code>C-_</code> 撤销最后一次操作</li>
</ul>
<h2 id="历史替换">历史替换</h2><p>历史替换（History Subsititution）的工作原理如下。所有已运行的非空命令行，都会保存到历史缓冲区，当你在一个新的提示符后输入时，实际上是在缓冲区底部添加新的一行。
<code>C-p</code> 可以往上移动一行，<code>C-n</code> 往下移动一行，<code>C-R</code> 可以反向搜索， <code>C-s</code> 向前搜索。</p>
<h2 id="键值绑定">键值绑定</h2><p>可以在 <code>~/.inputrc</code> 文件中增加一些自定义的命令和功能。常见的形式是： <code>key-name: function-name</code> 或 <code>&quot;string&quot;: function-name</code>，还可以通过 <code>set option-name vale</code> 设置选项。
一个简单的例子：</p>
<div class="highlight"><pre><code class="bash"><span class="comment"># I prefer vi-style editing:</span>
<span class="keyword">set</span> editing-mode vi

<span class="comment"># Edit using a single line:</span>
<span class="keyword">set</span> horizontal-scroll-mode On

<span class="comment"># Rebind some keys:</span>
Meta-h: backward-kill-word
<span class="string">"\C-u"</span>: universal-argument
<span class="string">"\C-x\C-r"</span>: re-read-init-file</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[一个 JavaScript 控制台错误]]></title>
        <link href="http://7anshuai.js.org/blog/work/a-javascript-console-error.html"/>
        <published>2014-10-16T08:51:17.000Z</published>
        <updated>2014-10-16T08:51:17.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/a-javascript-console-error.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现<code>ReferenceError: varialbe is not defined</code>错误，令我感到迷惑不解。场景大致如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> getSth = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    $.ajax({
        url: <span class="string">'/echo/json'</span>,
        type: <span class="string">'GET'</span>,
        data: {key: key},
        dataType: <span class="string">'json'</span>
    }).done(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        console.log(key)
    })
}</code></pre></div><p>AJAX请求成功执行匿名回调函数时，<code>console.log</code>语句会正常打印<code>key</code>值。但将<code>console.log(key)</code>改为 <code>console.log(data)</code>，通过开发工具在此处设置一个断点，代码执行在断点处时在控制台中打印<code>key</code>，则会报错<code>ReferenceError: key is not defined</code>。</p>
<p>一开始想当然的认为<code>key</code>变量是通过查找作用域链获得，反复调试后发现，如果在匿名回调函数的代码中引用<code>key</code>变量的话，则会在当前作用域创建一个闭包，而 JavaScript 是基于<a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>，闭包的创建是在词法分析阶段，所以在代码执行时通过控制台动态的引用<code>key</code>值会得到一个<code>ReferenceError</code>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Vim 中多行注释]]></title>
        <link href="http://7anshuai.js.org/blog/work/comment-lines-in-vim.html"/>
        <published>2014-06-17T13:47:14.000Z</published>
        <updated>2014-06-17T13:47:14.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/comment-lines-in-vim.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p><a href="http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim">What&#39;s a quick way to comment/uncomment lines in vim?</a></p>
<p>Stackoverflow 上的一个关于 Vim comments 的问题有很多不错的答案，记录其中一个简单基础的方法。</p>
<ul>
<li>首先，将光标移动到想要注释的代码块第一行</li>
<li>然后 <code>Ctrl + V</code> （<code>Ctrl + Q</code> for Gvim）进入 Visual block mode</li>
<li>移动光标到要注释的代码末行</li>
<li><code>Shift + i</code>（大写 I）</li>
<li>添加行注释 <code>//</code> 或 <code>#</code></li>
<li>最后按下 <code>Esc</code></li>
</ul>
<p>Give it a second to work.</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Something to think about]]></title>
        <link href="http://7anshuai.js.org/blog/work/something-to-think-about.html"/>
        <published>2013-07-20T01:25:56.000Z</published>
        <updated>2013-07-20T01:25:56.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/something-to-think-about.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies; the other is to make it so complicated that there are no obvious deficiencies.</p>
<p>Success in life is a matter not so much of talent and opportunity as of concentration and perserverance.</p>
<p>From <a href="http://swaroopch.com/notes/python/">A Byte of Python</a></p>
]]>
        </content>
    </entry>
</feed>