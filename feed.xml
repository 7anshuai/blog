<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>tanshuai.blog()</title>
    <link href="http://7anshuai.js.org/blog/feed.xml" rel="self" />
    <link href="http://7anshuai.js.org/blog/" />
    <id>http://7anshuai.js.org/blog/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[[译] 使用 bash shell 编写脚本的快速指南]]></title>
        <link href="http://7anshuai.js.org/blog/work/bash-tute.html"/>
        <published>2017-05-04T00:00:00.000Z</published>
        <updated>2017-05-04T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/bash-tute.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>原文链接：<a href="http://www.panix.com/~elflord/unix/bash-tute.html">A quick guide to writing scripts using the bash shell</a></p>
</blockquote>
<h2 id="简单的-shell-脚本">简单的 shell 脚本</h2><p>一个简单的 shell 脚本只是一点点按顺序执行的命令列表。通常，一个 shell 脚本应该从如下面的一行开始：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span></code></pre></div><p>这表示脚本应该在 bash shell 中运行，无论用户选择了哪个交互式 shell。这是非常重要的，因为不同 shell 的语法可能有很大差异。</p>
<h3 id="简单的例子">简单的例子</h3><p>这是一个非常简单的 shell 脚本示例。 它只是运行一些简单的命令：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"hello, <span class="variable">$USER</span>. I wish to list some files of yours"</span>
<span class="built_in">echo</span> <span class="string">"listing files in the current directory, <span class="variable">$PWD</span>"</span>
ls  <span class="comment"># list files</span></code></pre></div><p>首先，请注意第4行的注释。在一个 bash 脚本中，任何一个 <code>#</code>（除了第一行的 <a href="https://zh.wikipedia.org/zh-hans/Shebang">shebang</a> 之外）都被视为注释。 即 shell 解释器会忽略它。而对于人们阅读脚本是有益的。</p>
<p><code>$USER</code> 和 <code>$PWD</code> 是<em>变量</em>。这些是由 bash shell 本身定义的标准变量，它们不需要在脚本中定义。请注意，当变量名称在双引号内时，变量是<em>展开的</em>（<code>expanded</code>）。展开（<code>expand</code>）是一个非常合适的词：shell 看到字符串 <code>$USER</code>，并用变量的值替换它，然后执行命令。</p>
<p>下面我们来继续讨论变量...</p>
<h2 id="变量">变量</h2><p>任何编程语言都需要变量。如下定义一个变量：</p>
<div class="highlight"><pre><code class="bash">X=<span class="string">"hello"</span></code></pre></div><p>然后引用它：</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$X</span></code></pre></div><p>更具体地说，<code>$X</code> 用于表示变量 <code>X</code> 的值。 一些要注意的语义：</p>
<ul>
<li>如果你在 <code>=</code> 标志的两边留下空格，bash就会变得不快乐。 例如，以下内容导致了一个错误：<div class="highlight"><pre><code class="bash">X = hello</code></pre></div></li>
</ul>
<ul>
<li>虽然在我的例子中有引号，但并不总是必需的。 当变量的值包含空格时需要引号。 例如：<div class="highlight"><pre><code class="bash">X=hello world <span class="comment"># error</span>
X=<span class="string">"hello world"</span> <span class="comment"># OK</span></code></pre></div></li>
</ul>
<p>这是因为 shell 本质上将命令行看作一堆由空格分隔的命令和命令参数。 <code>foo=baris</code> 被认为是一个命令。 <code>foo = bar</code>的问题是 shell 看到由空格分隔的单词 <code>foo</code>，并把它解释为一个命令。 同样，命令 <code>X=hello world</code> 的问题是 shell 将 <code>X=hello</code> 解释为一个命令，而 <code>world</code> 这个词没有任何意义（因为赋值命令不能携带参数）。</p>
<h3 id="单引号与双引号">单引号与双引号</h3><p>基本上，变量名称只在双引号内展开，单引号里不展开。如果不需要引用变量，单引号很好用，因为结果更可预测。</p>
<p>一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> -n <span class="string">'$USER='</span> <span class="comment"># -n option stops echo from breaking the line</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>"</span>
<span class="built_in">echo</span> <span class="string">"\$USER=<span class="variable">$USER</span>"</span>  <span class="comment"># this does the same thing as the first two lines</span></code></pre></div><p>输出看起来像这样（假设你的用户名是 elflord）:</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$USER</span>=elflord

<span class="variable">$USER</span>=elflord</code></pre></div><p>双引号更灵活，但是可预测性较低。如果可以在两者之间选择的话，使用单引号。</p>
<h3 id="使用引号括起变量">使用引号括起变量</h3><p>有时，使用双引号保护变量名是个好主意。 如果您的变量值包含空格或是空字符串，则这是很重要的。 一个例子如下：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="variable">$X</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>这段脚本会输出：<code>the variable X is not the empty string</code>。
因为 shell 将 <code>$X</code> 展开为空字符串。 表达式 <code>[ -n ]</code> 返回 <code>true</code>（因为它没有提供参数）。 一个更好的脚本将是：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$X</span>"</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>在这个例子中，表达式展开为 <code>[ -n &quot;&quot; ]</code>，返回 <code>false</code>。因为用双引号括起来的字符串显然是空的。</p>
<h3 id="变量展开实战">变量展开实战</h3><p>只是为了说服你，shell 真的像我之前提到的那样在 “展开” 变量，这里是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
LS=<span class="string">"ls"</span>
LS_FLAGS=<span class="string">"-al"</span>

<span class="variable">$LS</span> <span class="variable">$LS_FLAGS</span> <span class="variable">$HOME</span></code></pre></div><p>这看起来有点神秘。 最后一行会发生什么，它实际上是执行命令
<code>ls -al /home/elflord</code>（假设 <code>/home/elflord</code> 是你的主目录）。 也就是说，shell 只是用它们的值替换变量，然后执行命令。</p>
<h3 id="使用大括号来保护变量">使用大括号来保护变量</h3><p>好了，这里有一个潜在的问题。 假设要 <code>echo</code> 变量 <code>X</code> 的值，紧接着是字母 <code>abc</code>。 问题：你怎么做的？ 我们来试一试：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">$Xabc</span>"</span></code></pre></div><p>这样没有得到输出。哪里出了错？答案是，shell 认为我们引用的是未初始化的变量 <code>Xabc</code>。处理这个问题的方法是把大括号放在 <code>X</code> 上以将其与其他字符分开。以下给出了期望的结果：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">${X}</span>abc"</span></code></pre></div><h2 id="条件语句">条件语句</h2><p>有时需要检查某些条件。一个字符串是否有0个长度？文件 “foo” 是否存在，它是一个符号链接还是一个真实的文件？首先，我们使用 <code>if</code> 命令来运行测试。 语法如下：</p>
<pre>if condition
then
  statement1
  statement2
  ..........
fi</pre><p>有时您可能希望在条件失败时指定备用操作。这是如何做的：</p>
<pre>if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi</pre><p>或者，如果第一个 <code>if</code> 失败，则可以测试另一个条件。 请注意，可以添加任何数量的 <code>elif</code>。</p>
<pre>if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........    
elif condition3
then
  statement5
  statement6
  ........    

fi</pre><p>如果相应的条件为真，则 <code>if/elif</code> 和下一个 <code>elif</code> 或 <code>fi</code> 之间的块内的语句将被执行。 实际上，任何命令都可以替代条件，并且当且仅当命令返回退出状态为<code>0</code>（换句话说，如果命令退出“成功”），则该块将被执行。 但是，在本文档中，我们只会使用 <code>test</code> 或 <code>[ ]</code> 来测试条件。</p>
<h3 id="测试命令和操作符">测试命令和操作符</h3><p>几乎所有的条件语句使用的命令都是测试命令。 测试返回 <code>true</code> 或 <code>false</code>（更准确地说，退出 <code>0</code> 或非零状态），这取决于测试是通过还是失败。 它大概如下工作：</p>
<pre>test operand1 operator operand2</pre><p>对于某些测试，只需要一个操作数（operand2）测试命令通常以下列形式缩写：</p>
<pre>[ operator operand2 ]</pre><p>让讨论回到现实，我们举几个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">3</span>
Y=<span class="number">4</span>
empty_string=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> <span class="operator">-lt</span> <span class="variable">$Y</span> ]  <span class="comment"># is $X less than $Y ?</span>
<span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"\$X=<span class="variable">${X}</span>, which is smaller than \$Y=<span class="variable">${Y}</span>"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$empty_string</span>"</span> ]; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"empty string is non_empty"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ <span class="operator">-e</span> <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>       <span class="comment"># test to see if ~/.fvwmrc exists</span>
  <span class="built_in">echo</span> <span class="string">"you have a .fvwmrc file"</span>
  <span class="keyword">if</span> [ -L <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>     <span class="comment"># is it a symlink ?  </span>
    <span class="built_in">echo</span> <span class="string">"it's a symbolic link
  elif [ -f "</span><span class="variable">${HOME}</span>/.fvwmrc<span class="string">" ]; then   # is it a regular file ?
    echo "</span>it<span class="string">'s a regular file"
  fi
else
  echo "you have no .fvwmrc file"
fi</span></code></pre></div><h3 id="值得注意的一些陷阱">值得注意的一些陷阱</h3><p>测试命令需要以“operand1 <space> operator <space> operand2”或“operator <space> operand2”的形式，换句话说，您真的需要这些空格，因为 shell 认为第一个不包含空格的块是运算符（如果以 <code>-</code> 开头）或操作数。例如：</p>
<div class="highlight"><pre><code class="bash"><span class="keyword">if</span> [ <span class="number">1</span>=<span class="number">2</span> ]; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"hello"</span>
<span class="keyword">fi</span></code></pre></div><p>以上会给出准确的 “错误” 输出（即 <code>echo &quot;hello&quot;</code>，因为 shell 看到一个操作数，但没有操作符）。</p>
<p>另一个潜在的陷阱来自于不保护引号中的变量。 我们已经给出了一个例子，说明为什么你必须用引号括起你想要使用在 <code>-n</code> 测试中的操作数。而且，在大部分时候都有很多足够好的理由来使用引号。当您在测试中展开变量时，无法执行此操作可能会导致非常严重的错误。 以下是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">"-n"</span>
Y=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> = <span class="variable">$Y</span> ] ; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"X=Y"</span>
<span class="keyword">fi</span></code></pre></div><p>这将导致错误输出，因为 shell 将我们的表达式展开为<code>[ -n = ]</code>，字符串 “=” 具有非零长度。</p>
<h3 id="测试操作符的简要总结">测试操作符的简要总结</h3><p>以下是测试运算符的快速列表。 这不是全面的，但它可能是所有你需要记住的（如果你需要任何其他的，你可以随时检查 bash 手册页...）</p>
<table>
<thead>
<tr>
<th>operator</th>
<th>produces true if...</th>
<th>number of operands</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>operand non zero length</td>
<td>1</td>
</tr>
<tr>
<td>-z</td>
<td>operand has zero length</td>
<td>1</td>
</tr>
<tr>
<td>-d</td>
<td>there exists a directory whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-f</td>
<td>there exists a file whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-eq</td>
<td>the operands are integers and they are equal</td>
<td>2</td>
</tr>
<tr>
<td>-neq</td>
<td>the opposite of -eq</td>
<td>2</td>
</tr>
<tr>
<td>=</td>
<td>the operands are equal (as strings)</td>
<td>2</td>
</tr>
<tr>
<td>!=</td>
<td>opposite of =</td>
<td>2</td>
</tr>
<tr>
<td>-lt</td>
<td>operand1 is strictly less than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-gt</td>
<td>operand1 is strictly greater than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-ge</td>
<td>operand1 is greater than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-le</td>
<td>operand1 is less than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="循环">循环</h2><p>循环是使得人们可以重复一个过程或对几个不同的项目执行相同的过程的结构。 在bash中有以下种类的循环可用：</p>
<ul>
<li>for 循环</li>
<li>while 循环</li>
</ul>
<h3 id="for-循环">for 循环</h3><p>for 循环的语法最适合通过示例描述：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> red green blue
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>for 循环遍历空白分隔的项。 请注意，如果某些项具有嵌入空白，则需要使用引号保护它们。 以下是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
colour1=<span class="string">"red"</span>
colour2=<span class="string">"light blue"</span>
colour3=<span class="string">"dark green"</span>
<span class="keyword">for</span> X <span class="keyword">in</span> <span class="string">"<span class="variable">$colour1</span>"</span> <span class="variable">$colour2</span><span class="string">" <span class="variable">$colour3</span>"</span>
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>你能猜测如果我们在 for 语句中省略引号，会发生什么？ 这表明变量名应该用引号保护，除非你确定它们不包含任何空格。</p>
<h4 id="for-循环中的-glob">for 循环中的 glob</h4><p>shell 将包含 <code>*</code> 的字符串扩展为“匹配”的所有文件名。当且仅当与匹配字符串相同时，文件名匹配，用任意字符串替换星号 <code>*</code> 后。 例如，字符 <code>*</code> 本身扩展到工作目录中所有文件的空格分隔列表（不包括以点开头的 <code>.</code>）。所以：</p>
<ul>
<li><code>echo *</code> 列出当前目录中的所有文件和目录</li>
<li><code>echo *.jpg</code> 列出所有 jpeg 文件</li>
<li><code>echo ${HOME}/public_html/*.jpg</code> 列出您的 public_html 目录中的所有 jpeg 文件</li>
</ul>
<p>正因为如此，这对于对目录中的文件执行操作非常有用，特别是与for循环一起使用。 例如：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> *.html
<span class="keyword">do</span>
    grep -L <span class="string">'&lt;UL&gt;'</span> <span class="string">"<span class="variable">$X</span>"</span>
<span class="keyword">done</span></code></pre></div><h3 id="while-循环">while 循环</h3><p>当一个给定的条件为真 while 循环进行迭代。 一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">0</span>
<span class="keyword">while</span> [ <span class="variable">$X</span> -le <span class="number">20</span> ]
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
  X=$((X+<span class="number">1</span>))
<span class="keyword">done</span></code></pre></div><p>这提出了一个自然的问题：为什么 bash 不允许 C 语言式的 for 循环 <code>for（X = 1，X &lt;10; X ++）</code> ？</p>
<p>事实上，for 循环不被鼓励使用，因为：bash 是一种解释性语言，而且它的循环是一个相当缓慢的事情。 因此，不鼓励重复迭代。</p>
<h2 id="命令替换">命令替换</h2><p>命令替换是 bash shell 非常方便的功能。 它使您可以获取命令的输出，并将其视为在命令行中写入。 例如，如果要将变量 <code>X</code> 设置为命令的输出，则通过命令替换来执行此操作。</p>
<p>有两种形式的命令替换：括号展开和反向展开。</p>
<p>括号扩展工作如下：<code>$(commands)</code> 展开到命令的输出，允许嵌套。因此命令可以包括括号扩展：</p>
<p>反向扩展将 <code>commands</code> 展开到命令的输出：</p>
<p>给出一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
files=<span class="string">"<span class="variable">$(ls)</span>"</span>
web_files=`ls public_html`
<span class="built_in">echo</span> <span class="string">"<span class="variable">$files</span>"</span>      <span class="comment"># we need the quotes to preserve embedded newlines in $files</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$web_files</span>"</span>  <span class="comment"># we need the quotes to preserve newlines</span>
X=`expr <span class="number">3</span> \* <span class="number">2</span> + <span class="number">4</span>` <span class="comment"># expr evaluate arithmatic expressions. man expr for details.</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$X</span>"</span></code></pre></div><p><code>$()</code> 替代方法的优点是几乎不言而喻：嵌套很容易。 大部分的 bourne shell 可以支持（或 POSIX shell）。但是，反向替换稍微可读性更好，甚至最基本的 shell 也支持（任何 <code>#!/bin/sh</code> 都很好）。</p>
<p>请注意，如果字符串在上述 <code>echo</code> 语句中没有引号保护，换行符将被输出中的空格替换。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[使用 GitHub Comments 替换多说评论]]></title>
        <link href="http://7anshuai.js.org/blog/work/replacing-duoshuo-with-gh-comments.html"/>
        <published>2017-04-27T00:00:00.000Z</published>
        <updated>2017-04-27T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/replacing-duoshuo-with-gh-comments.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>最近多说评论要关闭了，放在 GitHub Pages 上的静态博客需要新的评论功能了。之前有想法使用 <a href="https://developer.github.com/v3/issues/">GitHub Issues API</a> 来实现一个评论系统，目前 GitHub 已经有<a href="https://github.com/imsun/gitment">类似实现</a>了，有兴趣的可以尝试一下。</p>
<h2 id="github-comments">GitHub Comments</h2><p>在看到一篇 <a href="http://donw.io/post/github-comments/">Replacing Disqus with GitHub Comments</a> 文章之后，觉得这个思路更是简单可行。于是动手给博客主题加了一个 GitHub Comments：</p>
<ol>
<li>首先在博客的 GitHub repo 上为文章创建一个 issue，比如为这篇文章创建的一个 <a href="https://github.com/7anshuai/blog/issues/1">issue</a></li>
<li>所有的评论都是在 issue 里面发布</li>
<li>在博客的文章页面添加一些 JavaScript 代码通过 GitHub API 获取到指定 issue 的所有评论并展示</li>
</ol>
<p>好处是显而易见的：</p>
<ul>
<li>可以使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 进行评论，支持插入代码，图片，列表等等</li>
<li>可以使用 GitHub 消息通知来及时回复评论</li>
<li>对于访问博客的读者来说，几乎没有任何追踪代码了</li>
<li>可以过滤一部分垃圾评论</li>
</ul>
<p>最重要的是你不需要申请任何 API 权限去读取 GitHub JSON 数据，它是完全开放的。这篇文章的评论的数据可以在<a href="https://api.github.com/repos/7anshuai/blog/issues/1/comments">这里</a>获取到。
第一条评论是这样的：</p>
<div class="highlight"><pre><code class="javascript">{
    <span class="string">"body"</span>: <span class="string">"Inspired by http://donw.io/post/github-comments/."</span>,
    <span class="string">"created_at"</span>: <span class="string">"2017-04-27T03:12:41Z"</span>,
    <span class="string">"html_url"</span>: <span class="string">"https://github.com/7anshuai/blog/issues/1#issuecomment-297599593"</span>,
    <span class="string">"id"</span>: <span class="number">297599593</span>,
    <span class="string">"issue_url"</span>: <span class="string">"https://api.github.com/repos/7anshuai/blog/issues/1"</span>,
    <span class="string">"updated_at"</span>: <span class="string">"2017-04-27T03:12:41Z"</span>,
    <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/7anshuai/blog/issues/comments/297599593"</span>,
    <span class="string">"user"</span>: {
        <span class="string">"avatar_url"</span>: <span class="string">"https://avatars0.githubusercontent.com/u/9865150?v=3"</span>,
        <span class="string">"events_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/events{/privacy}"</span>,
        <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/followers"</span>,
        <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/following{/other_user}"</span>,
        <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/gists{/gist_id}"</span>,
        <span class="string">"gravatar_id"</span>: <span class="string">""</span>,
        <span class="string">"html_url"</span>: <span class="string">"https://github.com/7anshuai"</span>,
        <span class="string">"id"</span>: <span class="number">9865150</span>,
        <span class="string">"login"</span>: <span class="string">"7anshuai"</span>,
        <span class="string">"organizations_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/orgs"</span>,
        <span class="string">"received_events_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/received_events"</span>,
        <span class="string">"repos_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/repos"</span>,
        <span class="string">"site_admin"</span>: <span class="literal">false</span>,
        <span class="string">"starred_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/starred{/owner}{/repo}"</span>,
        <span class="string">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/7anshuai/subscriptions"</span>,
        <span class="string">"type"</span>: <span class="string">"User"</span>,
        <span class="string">"url"</span>: <span class="string">"https://api.github.com/users/7anshuai"</span>
    }
}</code></pre></div><h2 id="代码">代码</h2><p>我的博客使用 <a href="https://github.com/lepture/nico">Nico</a> 来生成静态文件。不管你使用什么静态文件生成器，都只需给使用的主题添加一个简单的 <code>comments.html</code>，我的看起来是这样:</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"gh-comments"</span> <span class="attribute">data-comment-id</span>=<span class="value">"{{post.gh_issue_id}}"</span> <span class="attribute">data-title</span>=<span class="value">"{{ post.title }}"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  (<span class="function"><span class="keyword">function</span> <span class="params">()</span>{</span>
    <span class="keyword">if</span> (!<span class="string">'{{post.gh_issue_id}}'</span>) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">var</span> gh_comments = document.getElementsByClassName(<span class="string">'gh-comments'</span>)[<span class="number">0</span>];
    <span class="keyword">var</span> a = document.createElement(<span class="string">'a'</span>);
    a.href = <span class="string">'{{config.github_issues}}'</span>;
    <span class="keyword">var</span> gh_api = <span class="string">'https://api.github.com/repos'</span> + a.pathname;
    <span class="keyword">var</span> gh_issue_id = <span class="string">'{{post.gh_issue_id}}'</span>;
    <span class="keyword">var</span> gh_issue_url = a.href +  <span class="string">'/'</span> + gh_issue_id;
    <span class="keyword">var</span> gh_comments_url = gh_api + <span class="string">'/'</span> + gh_issue_id + <span class="string">'/comments'</span>;
    fetch(gh_comments_url, {
      headers: <span class="keyword">new</span> Headers({
        <span class="string">'Accept'</span>: <span class="string">'application/vnd.github.v3.html+json'</span>,
        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>
      }),
      method: <span class="string">'GET'</span>
    }).then((res) =&gt; {
      <span class="keyword">if</span> (res.status == <span class="number">200</span>) <span class="keyword">return</span> res.json();
      <span class="keyword">let</span> error = <span class="keyword">new</span> Error(<span class="string">'HTTP Exception[GET]'</span>);
      error.status = res.status;
      error.statusText = res.statusText;
      error.url = res.url;
      <span class="keyword">throw</span> error;
    }).then((json) =&gt; {
        gh_comments.insertAdjacentHTML(<span class="string">'afterbegin'</span>, `&lt;h3&gt;GitHub Comments&lt;<span class="regexp">/h3&gt;
          &lt;p&gt;Visit the &lt;a href="${gh_issue_url}"&gt;GitHub Issue&lt;/</span>a&gt; to comment on <span class="keyword">this</span> post.<span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span>`);

        for (let comment of json) {
          let date = new Date(comment.created_at);
          let c = '<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"gh-comment"</span>&gt;</span>' +
              `<span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"${comment.user.avatar_url}"</span> <span class="attribute">width</span>=<span class="value">"24px"</span>&gt;</span> ` +
              `<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${comment.user.html_url}"</span>&gt;</span>${comment.user.login}<span class="tag">&lt;/<span class="title">a</span>&gt;</span>` +
              ' posted at ' +
              `<span class="tag">&lt;<span class="title">time</span>&gt;</span>${date.toUTCString()}<span class="tag">&lt;/<span class="title">time</span>&gt;</span>` +
              '<span class="tag">&lt;<span class="title">hr</span>&gt;</span>' +
              comment.body_html +
              '<span class="tag">&lt;/<span class="title">div</span>&gt;</span>';
          gh_comments.insertAdjacentHTML('beforeend', c);
        }
    }).catch((err) =&gt; {
      gh_comments.insertAdjacentHTML('afterbegin', `<span class="tag">&lt;<span class="title">h3</span>&gt;</span>GitHub Comments<span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="tag">&lt;<span class="title">p</span>&gt;</span>Comments are not open for this post yet<span class="tag">&lt;/<span class="title">p</span>&gt;</span>`);
    });
  })();
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>其中：</p>
<ul>
<li><code>{{config.github_issues}}</code> - 在 nico.json 配置文件中添加的本博客 issues 地址</li>
<li><code>{{post.gh_issue_id}}</code> - 在文章的 Markdown 文档中指定相应的 issue id</li>
<li><code>{{post.title}}</code> - 文章的标题（并没有什么用）</li>
</ul>
<blockquote>
<p>注意：如果你使用 nico， 默认是不支持读取 <code>post.gh_issue_id</code>，找到相应的 <a href="https://github.com/lepture/nico/blob/master/lib/sdk/post.js#L98">lib/sdk/post.js</a></p>
<p>手动添加一行 <code>post.gh_issue_id = post.meta.gh_issue_id;</code></p>
</blockquote>
<p>在主题的 <code>post.html</code> 文件中将 <code>comments.html</code> 引入进来即可：</p>
<div class="highlight"><pre><code class="xml">{%- if config.github_issues %}
{%- include "_comments.html" %}
{%- endif %}</code></pre></div><p>当你在 nico.json 配置好了博客 issues 地址，并在某篇文章指定了 issue id，就能成功组合一个该 issue 的 comments API url，获取到了数据展示在文章后面。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://donw.io/post/github-comments/">Replacing Disqus with GitHub Comments</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Chrome DevTools 中并行调试 Node.js 和浏览器 JavaScript]]></title>
        <link href="http://7anshuai.js.org/blog/work/nodejs-debugging-with-chrome-devtools.html"/>
        <published>2017-02-09T00:00:00.000Z</published>
        <updated>2017-02-09T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/nodejs-debugging-with-chrome-devtools.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>Programmers make mistakes. For whimsical reasons, programming errors are called <strong>bugs</strong> and the process of tracking them down is called <strong>debugging</strong>.</p>
<p>-- Allen Downey</p>
</blockquote>
<p>最近读了 <a href="http://greenteapress.com/wp/think-python-2e/">Think Python</a>，书中对 Debugging 的描述很有趣：</p>
<blockquote>
<p>编写代码，特别是 debugging，有时会产生强烈的情绪。如果你在与一个困难的 bug 做斗争，你可能会感动愤怒，沮丧或者尴尬。</p>
<p>有证据表明，人们会很自然的把计算机当作人一样做出反应。当它们运转良好，我们认为它们是好队友，而当它们顽固或粗鲁时，我们也会像对待顽固，粗鲁的人一样回应它们。</p>
<p>做点准备可能会帮助你处理这些反应。一种方法是将计算机视为具有某些优势（如速度和精度）和特定弱点（例如缺乏同情心和无法掌握大局）的员工。</p>
<p>你的工作是做一个好的经理：找到方法来利用优势和缓解弱点。 并找到使用你的情绪来解决问题的方法，而不会让你的反应干扰你的有效工作能力。</p>
<p>学习 debug 可能令人沮丧，但它是一个有价值的技能，对于除了编程以外还有许多活动都是有用的。</p>
</blockquote>
<p>对于程序员来说最重要的技能是解决问题。善于 Debug 能极大的提高解决问题的效率和成功率。So, 做为 JS 开发者需要好好学习总结下 JavaScript 及 Node.js debug。</p>
<h2 id="javascript-debugger">JavaScript Debugger</h2><p>Web 浏览器附带一个通常被称为“开发者工具”的内置功能，它提供了更好的视角来观察运行在浏览器里的 JavaScript。虽然不是必须的，但当你调试代码错误时，你会发现开发者工具很有用。</p>
<p><a href="https://developers.google.cn/web/tools/chrome-devtools/">Chrome DevTools</a> 是 Google Chrome 中内置的一组网络制作和调试工具。 使用 DevTools 来迭代，调试和配置您的网站。具体的如何调试 JavaScript 代码可以参考<a href="https://developers.google.cn/web/tools/chrome-devtools/javascript/">官方文档</a>。</p>
<h2 id="node-debuggers">Node debuggers</h2><h3 id="debugger">Debugger</h3><p>服务器端的 JavaScript 运行时环境 Node.js 包含了一个基于 TCP 协议访问的进程外调试工具和内置的调试客户端。要使用它，使用debug参数启动Node.js，然后是要调试的脚本的路径; 将显示一个提示，指示调试器成功启动：</p>
<pre>$ node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(() =&gt; {
  3   debugger;
debug&gt;</pre><p>Node.js 的调试客户端不是一个全功能调试器，但简单的步骤和检查是可行的。</p>
<p>更多的详情及高级用法可参考<a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html">官方文档</a>。</p>
<h3 id="node-inspector">Node Inspector</h3><p>随着 Node.js 的大热，开源社区里的优秀开发者贡献了大量的 <a href="https://github.com/sindresorhus/awesome-nodejs#debugging--profiling">debugging 工具</a>，其中的佼佼者便是 <a href="https://github.com/node-inspector/node-inspector">node-inspector</a>。</p>
<p>Node Inspector 是 Node.js 应用程序的调试器接口，通过它可以使用 Blink（Chrome 浏览器内核）开发工具来进行 debugging。</p>
<h4 id="安装">安装</h4><p>通过 npm 安装 node-inspector：</p>
<pre>$ npm install -g node-inspector</pre><h4 id="启动">启动</h4><p>然后启动程序：</p>
<pre>$ node-debug app.js</pre><p>其中 <code>app.js</code> 是您的 Node 应用程序主要 JavaScript 文件的名称。</p>
<h4 id="调试">调试</h4><p><code>node-debug</code> 命令将在默认浏览器中加载 Node Inspector。</p>
<blockquote>
<p>⚠：Node Inspector 仅适用于 Chrome 和 Opera。 如果另一个浏览器是您的默认网络浏览器（例如 Safari 或 Internet Explorer），则必须在其中一个浏览器中重新打开检查器页面。</p>
</blockquote>
<p>Node Inspector 的工作方式几乎与 Chrome DevTools 完全相同。</p>
<h4 id="issues">issues</h4><p><a href="https://www.npmjs.com/package/node-inspector">Node Inspector</a> 目前最新的 package 版本是0.12.8，发布于10个月前。
而 Node.js 版本更新很快，v6.x 已经有十几个版本更新了。</p>
<p>在好几个月前，我开始使用 Node.js v6.4.0，同样的也安装了 Node Inspector 来进行 Debugging，然后就遇到了：<a href="https://github.com/node-inspector/node-inspector/issues/905">Throwing exception on simple use case</a>。</p>
<p>在好长一段时间，这个问题没有得到解决，相关讨论，PR也没有得到回应或者 Merge。直到最近，终于合并了一个 Pull Request：<a href="https://github.com/node-inspector/node-inspector/pull/914">Fix callback call in InjectorClient._findNMInScope</a>。然而 Node Inspector package 还没有发布 patch 更新，所以 <code>npm install -g node-inspector</code> 依然会遇到这个问题。</p>
<p>如果需要在 v6.4.0 以上版本使用 Node Inspector，可以直接从 github 下载安装 <code>npm install -g https://github.com/node-inspector/node-inspector</code>，或者手动修改 <a href="https://github.com/node-inspector/node-inspector/pull/914/files">InjectorClient.js</a>。</p>
<h3 id="node-js-集成-v8-inspector">Node.js 集成 V8 Inspector</h3><p>在 Node Inspector issues里看到了很多讨论，有开发者提出了使用 <code>node --inspect app.js</code> 来替代 node-inspector。
原来 Node.js v6.3.0+ 已经内置支持了 <a href="https://github.com/nodejs/node/pull/6792">V8 Inspector</a>。</p>
<p><a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html#debugger_v8_inspector_integration_for_node_js">Node.js debugger docs</a> 文档也增加了这部分内容：</p>
<blockquote>
<p>⚠：这是一个实验特性。</p>
</blockquote>
<p>V8 Inspector 集成允许将 Chrome 开发工具通过 <a href="https://developer.chrome.com/devtools/docs/debugger-protocol">Chrome Debugging Protocol</a> 连接到 Node.js 实例以进行调试和分析。</p>
<p>V8 Inspector 可以通过在启动 Node.js 应用程序时传递 <code>--inspect</code> 标志来启用。 也可以提供具有该标志的自定义端口，例如， <code>--inspect=9222</code> 将接受端口9222上的 DevTools 连接。</p>
<p>如需在应用的第一行代码添加断点，在 <code>--inspect</code> 之外增加 <code>--debug-brk</code> 标志。</p>
<div class="highlight"><pre><code class="bash">$ node --inspect index.js
Debugger listening on port <span class="number">9229</span>.
Warning: This is an experimental feature and could change at any time.
To start debugging, open the following URL <span class="keyword">in</span> Chrome:
    chrome-devtools://devtools/remote/serve_file/@<span class="number">60</span><span class="built_in">cd</span>6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=<span class="literal">true</span>&amp;v8only=<span class="literal">true</span>&amp;ws=localhost:<span class="number">9229</span>/node</code></pre></div><h2 id="node-js-与浏览器-javascript-并行调试">Node.js 与浏览器 JavaScript 并行调试</h2><p>Chrome DevTools 已经进一步发展，打开具有特定网址的单独页面以调试 Node.js 代码的步骤已非必须。</p>
<p>这意味着，今天你可以在同一个 DevTools 窗口中并行调试浏览器 JavaScript 文件和 Node.js，这有着完美的意义。</p>
<h3 id="开启-devtools-实验特性">开启 DevTools 实验特性</h3><p>目前 Chrome 浏览器 JavaScript 和 Node.js 代码的并行调试是一个实验性的新功能。</p>
<p>要启用它，您必须执行以下操作：</p>
<ul>
<li>打开 <a href="chrome://flags/#enable-devtools-experiments">chrome://flags/#enable-devtools-experiments</a> URL</li>
<li>启用 <code>Developer Tools experiments</code> 标志</li>
<li>重启 Chrome</li>
<li>打开 DevTools 设置 -&gt; Experiments 选项（在重启之后它开始可见）</li>
<li>按6次 &quot;SHIFT&quot; 以显示隐藏的实验功能</li>
<li>选中 &quot;Node debugging&quot;</li>
<li>打开/关闭 DevTools</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/6b4c087fgy1fcoxl9cy10j20zk10sn1m.jpg" alt="Enable DevTools Experiments"></p>
<h3 id="debug">Debug</h3><p>开始 debugging，像上面一样以 debug mode 启动 Node.js：</p>
<pre>node --inspect server.js</pre><p>像平时一样在 Chrome 打开您的页面和 DevTools，选择 Sources -&gt; 按 <code>ESC</code> 开启 Console -&gt; 在 debugger 面板中点击 connect 连接 <code>NodeJS Main Context</code>：
<img src="http://wx3.sinaimg.cn/mw690/6b4c087fgy1fcoxlafw3fj20zk0yyaha.jpg" alt="Node.js debugging"></p>
<p>如果您的 Node.js 应用有 console.log 或类似输出，您会看到，它们已经出现在 Chrome DevTools console。然后，你可以同时给浏览器和 Node.js 文件设置断点进行 debug。</p>
<p><img src="http://wx3.sinaimg.cn/mw1024/6b4c087fgy1fcq2n9u9rtg20gn0aenpd.gif" alt="Node.js Debugging Gif"></p>
<h2 id="总结">总结</h2><p>如果您的项目使用 Node.js，现在您可以从一个地方调试和更改所有 JavaScript - Chrome DevTools。</p>
<p>您还可以将 Chrome DevTools 的所有强大功能应用于 Node.js 代码。</p>
<h2 id="参考链接">参考链接</h2><ul>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html">Node.js Debugger</a></li>
<li><a href="https://github.com/nodejs/node/pull/6792">Add V8_inspector support</a></li>
<li><a href="https://github.com/node-inspector/node-inspector">Node Inspector</a></li>
<li><a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27#.fuwv7r5ex">Debugging Node.js with Chrome DevTools</a></li>
<li><a href="https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools">Node.js debugging with Chrome DevTools (in parallel with browser JavaScript)</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[通过 Nginx 给本地应用取个漂亮域名]]></title>
        <link href="http://7anshuai.js.org/blog/work/nginx-and-pretty-domains.html"/>
        <published>2016-09-19T00:00:00.000Z</published>
        <updated>2016-09-19T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/nginx-and-pretty-domains.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>简单记录下之前看到并实践的一篇文章 <a href="http://zaiste.net/2013/03/serving_apps_locally_with_nginx_and_pretty_domains/">Serving Apps Locally with Nginx and Pretty Domains</a>。在 Mac OS X 上通过配置 Nginx 实现本地应用可以通过漂亮的域名来访问，比如 <code>http://anapp.dev/</code>。类似的解决方案有 <a href="http://pow.cx">pow</a> - Mac OS X 上的零配置 Rake Server。</p>
<h2 id="nginx">Nginx</h2><p>首先需要关掉 Apache 进程（Mac OS X 上默认启动 Apache 监听 <code>80</code> 端口）：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist</code></pre></div><p>使用 Homebrew 安装 Nginx ：</p>
<div class="highlight"><pre><code class="bash">brew install nginx</code></pre></div><p>Nginx 监听 <code>80</code>（或任何小于 <code>1024</code> 的）端口需要使用 <code>sudo</code> 命令，否则会启动失败。对于大于 <code>1024</code> 的端口，如下直接为启动脚本建立一个符号链接：</p>
<div class="highlight"><pre><code class="bash">ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist</code></pre></div><p>对于 HTTP 默认端口，需要在 <code>/usr/local/etc/nginx.conf</code> 中将 <code>listen</code> 的值从 <code>8080</code> 修改为 <code>80</code>。</p>
<pre>server {
     …
     listen 80;
     server_name localhost;
     …
}</pre><p>小于 <code>1024</code> 的端口不能为启动脚本建立符号链接，必须将脚本拷贝到 <code>/Library/LaunchAgents</code>。</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist /Library/LaunchAgents</code></pre></div><p>在 <code>homebrew.mxcl.nginx.plist</code> 中，需要将 <code>UserName</code> 项修改为 <code>root</code>。为了方便，还可以将 <code>Label</code> 项修改为 <code>nginx</code>，这样就可以使用</p>
<div class="highlight"><pre><code class="bash">launchctl start nginx</code></pre></div><p>代替</p>
<div class="highlight"><pre><code class="bash">launchctl start homebrew.mxcl.nginx</code></pre></div><h2 id="本地-dns">本地 DNS</h2><p>接下来是设置一个本地的 DNS。因为不能在 <code>/etc/hosts</code> 文件中使用通配符，无法实现类似功能：</p>
<pre>127.0.0.1      *.dev.</pre><p>为了解决这个问题，需要安装一个叫做 <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">DNSMasq</a> 的 DNS 代理：</p>
<div class="highlight"><pre><code class="bash">brew install dnsmasq</code></pre></div><p>配置文件存储在 <code>/usr/local/etc/</code> 下的 <code>dnsmasq.conf</code> ：</p>
<div class="highlight"><pre><code class="bash">touch /usr/local/etc/dnsmasq.conf</code></pre></div><p>在文件中写入：</p>
<pre>address=/.dev/127.0.0.1</pre><p>这样所有 <code>*.dev</code> 的站点会被重定向到本地 IP，即 <code>127.0.0.1</code>。
类似 Nginx 进程，<code>dnsmasq</code> 需要 <code>root</code> 权限：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> cp -fv /usr/local/opt/dnsmasq/*.plist /Library/LaunchDaemons
<span class="built_in">sudo</span> launchctl load /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist</code></pre></div><p>然后，需要配置 OSX 使用本地系统作为首要 DNS 服务器。进入系统设置 -&gt; 网络，在 DNS 配置中将回环 IP (即 <code>127.0.0.1</code>)作为第一行，然后是惯例的 DNS IP：</p>
<pre>127.0.0.1
8.8.8.8
8.8.4.4</pre><p>现在，试着 <code>ping</code> 任何以 <code>.dev</code> 结尾的地址，应该返回的 IP 地址是 <code>127.0.0.1</code>：</p>
<div class="highlight"><pre><code class="bash">$ ping example.dev
PING example.dev (<span class="number">127.0</span>.<span class="number">0.1</span>): <span class="number">56</span> data bytes</code></pre></div><h2 id="虚拟主机">虚拟主机</h2><p>关于虚拟主机配置，按照惯例在 <code>/usr/local/etc/nginx/</code> 下创建两个目录 <code>sites-enabled</code> 和 <code>sites-available</code>：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">cd</span> /usr/local/etc/nginx
mkdir sites-available
mkdir sites-enabled</code></pre></div><p>在 <code>nginx.conf</code> 中的 <code>http</code> 部分，需要加入以下行：</p>
<pre>include sites-enabled/*.dev;</pre><h3 id="后端参与的项目配置">后端参与的项目配置</h3><p>现在可以指定每一个 app 的配置了。看一下配置模板文件：</p>
<pre>upstream NAME {
    server 127.0.0.1:3000;
}

server {
    listen 80;
    server_name NAME.dev;
    root PATH_TO_PUBLIC;

    try_files $uri/index.html $uri.html $uri @app;

    location @app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;

      proxy_pass http://NAME;
    }
}</pre><p>为了使它工作起来，至少需要修改两个地方，即 <code>NAME</code> 和 <code>PATH_TO_PUBLIC</code>。 <code>NAME</code> 可以是应用程序名称。 <code>PATH_TO_PUBLIC</code> 则指定项目静态资源目录，例如在 Express 中的路径为 <code>public</code>。
配置文件需要放在 <code>sites-available</code> 下，然后需要链接到 <code>sites-enabled</code>，例如：</p>
<div class="highlight"><pre><code class="bash">ln <span class="operator">-s</span> /usr/local/etc/nginx/sites-available/anapp.dev \
  /usr/local/etc/nginx/sites-enabled/anapp.dev</code></pre></div><p>建立链接后，需要重启 Nginx：</p>
<div class="highlight"><pre><code class="bash"><span class="built_in">sudo</span> launchctl stop nginx
<span class="built_in">sudo</span> launchctl start nginx</code></pre></div><h3 id="无后端参与的项目配置">无后端参与的项目配置</h3><p>以上的配置文件对于纯静态的项目来说是不必要的。可以通过位于 <code>/usr/local/etc/nginx/nginx.conf</code> 中默认的 <code>server</code> 指令设置一个动态的应用程序分发。Nginx 会在定义的基础路径中查找匹配被请求的域名目录。如在以下例子中， <code>appname.dev</code> 会匹配 <code>/Users/zaiste/dev</code> 下一个叫做 <code>appname</code> 的目录：</p>
<pre>server {
    listen       80;
    server_name  app localhost .dev;

    set $basepath &quot;/Users/zaiste/dev&quot;;

    set $domain $host;
    if ($domain ~ &quot;^(.*)\.dev$&quot;) {
        set $domain $1;
    }
    set $rootpath &quot;${domain}&quot;;
    if (-d $basepath/$domain/public) {
        set $rootpath &quot;${domain}/public&quot;;
    }
    if (-f $basepath/$domain/index.html) {
        set $rootpath $domain;
    }

    root $basepath/$rootpath;

    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}</pre><p>现在，只需要在 <code>/Users/zaiste/dev</code> 创建一个新的目录及相应的 HTML 文件，剩下的事情就交给 Nginx 了。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/basecamp/pow">Pow</a> - Zero-configuration Rack server for Mac OS X</li>
<li><a href="https://zaiste.net/posts/serving_apps_locally_with_nginx_and_pretty_domains/">Serving Apps Locally with Nginx and Pretty Domains
</a></li>
<li><a href="https://passingcuriosity.com/2013/dnsmasq-dev-osx/">Using Dnsmasq for local development on OS X</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Bash 中解析命令行参数]]></title>
        <link href="http://7anshuai.js.org/blog/work/parse-command-line-arguments-in-bash.html"/>
        <published>2016-04-22T00:00:00.000Z</published>
        <updated>2016-04-22T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/parse-command-line-arguments-in-bash.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>最近的一个前端小项目是智能 Wi-Fi 音箱 <a href="http://sugrsugr.com">Sugr Cube</a> 中的 Web 上传歌曲界面，使用了 Require.js 组织代码，文件上传部分基于 <a href="https://github.com/blueimp/jQuery-File-Upload">jQuery File Upload</a>。Web page 编写完后需要使用 r.js 打包处理下，并将生成的文件上传到硬件设备里的 <a href="https://github.com/ankushagarwal/nweb">Nweb</a> 目录下。</p>
<h2 id="项目结构">项目结构</h2><pre>|--node_modules
|  |-- blueimp-file-upload-node
|  |  本地文件上传服务器
|  |-- requirejs
|  |  requirejs optimizer (r.js)
|  |-- inliner
|  |  Node utility to inline images, CSS and JavaScript for a web page
|--public
|  静态文件（css，js，images等）
|-- package.json
|  npm 项目配置
|-- index.html</pre><h2 id="npm-scripts">npm scripts</h2><p>编写 <a href="https://docs.npmjs.com/misc/scripts">npm scripts</a> 用来运行相关脚本：</p>
<div class="highlight"><pre><code class="javascript">{
  ...,
  <span class="string">"scripts"</span>: {
    <span class="string">"build"</span>: <span class="string">"r.js -o baseUrl=public/js paths.requireLib=require paths.jquery=jquery name=app include=requireLib out=public/js/app-built.js"</span>,
    <span class="string">"inliner"</span>: <span class="string">"inliner -vs index.html &gt; www/index.html"</span>,
    <span class="string">"server"</span>: <span class="string">"node node_modules/blueimp-file-upload-node/server.js"</span>,
    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  },
  ...
}</code></pre></div><p>OK，页面开发完后运行相应的命令 <code>npm run build</code>，<code>npm run inliner</code> 之后，再将生成好的单一 HTML 文件（www/index.html）scp 到硬件设备的文件 www 目录下。那么问题来了，调试过程中需要频繁的重复这一过程，而且硬件设备的局域网 IP 地址也常会发生变化，我需要个一键部署的 shell 脚本，比如这样：</p>
<pre>./publish --user root --host 192.168.1.99</pre><h2 id="bash-script">Bash script</h2><p>如何编写一个能接受命令行参数的 Bash 脚本？在 stackoverflow 上找到大家推荐的方法：使用没有 getopt[s] 的 straight bash。</p>
<h3 id="空格分离的-straight-bash">空格分离的 Straight Bash</h3><p>使用方法：<code>./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts</code></p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="comment"># Use -gt 1 to consume two arguments per pass in the loop (e.g. each</span>
<span class="comment"># argument has a corresponding value to go with it).</span>
<span class="comment"># Use -gt 0 to consume one or more arguments per pass in the loop (e.g.</span>
<span class="comment"># some arguments don't have a corresponding value to go with it such</span>
<span class="comment"># as in the --default example).</span>
<span class="comment"># note: if this is set to -gt 0 the /etc/hosts part is not recognized ( may be a bug )</span>
<span class="keyword">while</span> [[ <span class="variable">$#</span> <span class="operator">-gt</span> <span class="number">1</span> ]]
<span class="keyword">do</span>
key=<span class="string">"<span class="variable">$1</span>"</span>

<span class="keyword">case</span> <span class="variable">$key</span> <span class="keyword">in</span>
    <span class="operator">-e</span>|--extension)
    EXTENSION=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    <span class="operator">-s</span>|--searchpath)
    SEARCHPATH=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    <span class="operator">-l</span>|--lib)
    LIBPATH=<span class="string">"<span class="variable">$2</span>"</span>
    shift <span class="comment"># past argument</span>
    ;;
    --default)
    DEFAULT=YES
    ;;
    *)
            <span class="comment"># unknown option</span>
    ;;
<span class="keyword">esac</span>
shift <span class="comment"># past argument or value</span>
<span class="keyword">done</span>
<span class="built_in">echo</span> FILE EXTENSION  = <span class="string">"<span class="variable">${EXTENSION}</span>"</span>
<span class="built_in">echo</span> SEARCH PATH     = <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>
<span class="built_in">echo</span> LIBRARY PATH    = <span class="string">"<span class="variable">${LIBPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"Number files in SEARCH PATH with EXTENSION:"</span> $(ls -<span class="number">1</span> <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>/*.<span class="string">"<span class="variable">${EXTENSION}</span>"</span> | wc <span class="operator">-l</span>)
<span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"Last line of file specified as non-opt/last argument:"</span>
    tail -<span class="number">1</span> <span class="variable">$1</span>
<span class="keyword">fi</span></code></pre></div><h3 id="等号分离的-straight-bash">等号分离的 Straight Bash</h3><p>使用方法：<code>./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts</code></p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash
</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>
<span class="keyword">do</span>
<span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span>
    <span class="operator">-e</span>=*|--extension=*)
    EXTENSION=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    <span class="operator">-s</span>=*|--searchpath=*)
    SEARCHPATH=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    <span class="operator">-l</span>=*|--lib=*)
    LIBPATH=<span class="string">"<span class="variable">${i#*=}</span>"</span>
    shift <span class="comment"># past argument=value</span>
    ;;
    --default)
    DEFAULT=YES
    shift <span class="comment"># past argument with no value</span>
    ;;
    *)
            <span class="comment"># unknown option</span>
    ;;
<span class="keyword">esac</span>
<span class="keyword">done</span>
<span class="built_in">echo</span> <span class="string">"FILE EXTENSION  = <span class="variable">${EXTENSION}</span>"</span>
<span class="built_in">echo</span> <span class="string">"SEARCH PATH     = <span class="variable">${SEARCHPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"LIBRARY PATH    = <span class="variable">${LIBPATH}</span>"</span>
<span class="built_in">echo</span> <span class="string">"Number files in SEARCH PATH with EXTENSION:"</span> $(ls -<span class="number">1</span> <span class="string">"<span class="variable">${SEARCHPATH}</span>"</span>/*.<span class="string">"<span class="variable">${EXTENSION}</span>"</span> | wc <span class="operator">-l</span>)
<span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"Last line of file specified as non-opt/last argument:"</span>
    tail -<span class="number">1</span> <span class="variable">$1</span>
<span class="keyword">fi</span></code></pre></div><p>为了更好的理解 <code>${i#*=}</code> 可在<a href="http://tldp.org/LDP/abs/html/string-manipulation.html">这篇指南</a>中查找 &quot;Substring Removal&quot;。它的功能等同于 <code>sed &#39;s/[^=]*=//&#39; &lt;&lt;&lt; &quot;$i&quot;</code>（调用了一个不必要的子进程）或者 <code>echo &quot;$i&quot; | sed &#39;s/[^=]*=//&#39;</code>（调用了两个不必要的子进程）。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://www.panix.com/~elflord/unix/bash-tute.html">A quick guide to writing scripts using the bash shell</a></li>
<li><a href="http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash">How do I parse command line arguments in bash?</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[[译] 为 Node.js 包准备的 Makefile]]></title>
        <link href="http://7anshuai.js.org/blog/work/makefile-recipes-for-nodejs.html"/>
        <published>2015-04-12T00:00:00.000Z</published>
        <updated>2015-04-12T00:00:00.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/makefile-recipes-for-nodejs.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>原文链接：<a href="https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html">Makefile recipes for Node.js packages</a></p>
</blockquote>
<p>当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 <code>make</code> 程序来完成这些任务，主要是因为它的简单明了。</p>
<p>要开始使用 <code>make</code> 你需要在项目根目录创建一个 <code>Makefile</code>。<code>Makefile</code> 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 <code>make &lt;task name&gt;</code>。简单吧！</p>
<p>以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 <code>Makefile</code> 文件。我会一步一步的完成它。</p>
<p>首先是定义一些有用的变量：我在 <code>src</code> 保存源码，编译过的代码放在 <code>lib</code>（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。</p>
<pre>BIN = ./node_modules/.bin
SRC = $(wildcard src/*.coffee)
LIB = $(SRC:src/%.coffee=lib/%.js)</pre><p><code>SRC</code> 将会包含一个 <code>src</code> 目录中的 <code>.coffee</code> 文件列表，然后 <code>LIB</code> － 一个相对应的 <code>.js</code> 文件列表（目前还不存在）。<code>$(VAR:pattern1=pattern2)</code> 使用来指定存储在变量中的每一个项的变换。</p>
<p>所以如果我们保存 <code>src/index.coffee src/mod.coffee</code> 在文件系统中， <code>SRC</code> 会捕获它们然后相应的使 <code>LIB</code> 保存 <code>lib/index.js lib/mod.js</code> 。</p>
<p><code>BIN</code> 指向 Node 本地可执行模块的安装目录。</p>
<h2 id="构建">构建</h2><p>现在让我们定义第一个任务构建并表明它依赖于存储在 <code>LIB</code> 变量的所有文件。</p>
<div class="highlight"><pre><code class="bash">build: $(LIB)</code></pre></div><p>很简单，对不对？<code>$(LIB)</code> 只是在 <code>make</code> 中间接引用变量的语法。</p>
<p>运行 <code>make build</code> 后，程序会尝试确保 <code>LIB</code> 中的所有文件都已就位并及时更新。但是我们如何让 <code>make</code> 知道怎样在 <code>SRC</code> 中获取相应的文件，处理并将所有的这些文件放入 <code>LIB</code> 中呢？</p>
<p>接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － <code>lib/%.js</code> － 正是这个模式将会在 <code>LIB</code> 变量中进行文件匹配。</p>
<div class="highlight"><pre><code class="bash">lib/%.js: src/%.coffee
  @mkdir -p $(@D)
  @$(BIN)/coffee -bcp $&lt; &gt; <span class="variable">$@</span></code></pre></div><p>这条规则告诉 <code>make</code> 那些 <code>lib/%.js</code> 文件依赖于相应的 <code>src/%.coffee</code> 文件，所以如果当后者发生改变时 <code>make</code> 会重新编译生成前者。</p>
<p>它是如何工作的？首先，它创建了一个目标文件的目录（<code>$(@D)</code> 表示这个目录，它是 <code>make</code> 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 <code>.coffee</code> 文件（通过 <code>$&lt;</code> 表示）并将结果写入目标文件（通过 <code>$@</code> 表示）。</p>
<p>注意 @ 前缀，默认的 <code>make</code> 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。</p>
<p>足够作为一个构建程序了，<code>make build</code> 会从 src 目录下将相应的文件重新构建到 lib 目录下。</p>
<h2 id="测试">测试</h2><p>测试任务很简单：</p>
<div class="highlight"><pre><code class="bash">test: build
  @$(BIN)/mocha -b specs</code></pre></div><p>我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。</p>
<h2 id="辅助任务">辅助任务</h2><p>接下来到辅助任务 － <code>clean</code> 用来清除所有编译生成的代码：</p>
<div class="highlight"><pre><code class="bash">clean:
  @rm <span class="operator">-f</span> $(LIB)</code></pre></div><p><code>install</code> 和 <code>link</code> 任务是简单的运行相应的 <code>npm</code> 子命令：</p>
<div class="highlight"><pre><code class="bash">install link:
  @npm <span class="variable">$@</span>;</code></pre></div><p>注音 <code>$@</code> 变量的使用技巧，它是如何传递任务名称作为 <code>npm</code> 的子命令。</p>
<h2 id="版本">版本</h2><p>下一个是版本任务。</p>
<p>下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。</p>
<div class="highlight"><pre><code class="bash">define release
  VERSION=`node -pe <span class="string">"require('./package.json').version"</span>` &amp;&amp; \
  NEXT_VERSION=`node -pe <span class="string">"require('semver').inc(\"$<span class="variable">$VERSION</span>\", '<span class="variable">$(1)</span>')"</span>` &amp;&amp; \
  node <span class="operator">-e</span> <span class="string">"\
    var j = require('./package.json');\
    j.version = \"$<span class="variable">$NEXT_VERSION</span>\";\
    var s = JSON.stringify(j, null, 2);\
    require('fs').writeFileSync('./package.json', s);"</span> &amp;&amp; \
  git commit -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span> -- package.json &amp;&amp; \
  git tag <span class="string">"$<span class="variable">$NEXT_VERSION</span>"</span> -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span>
endef</code></pre></div><p>简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 <code>$1</code> 变量定义的）重写了 <code>package.json</code>，然后创建了一个相应的 <code>git commit</code> 和 <code>git tag</code>。</p>
<p>接下啦只需要通过传递 <code>patch</code>，<code>minor</code> 或者 <code>major</code> 参数调用 <code>release</code> 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。</p>
<div class="highlight"><pre><code class="bash">release-patch: build test
  @$(call release,patch)

release-minor: build test
  @$(call release,minor)

release-major: build test
  @$(call release,major)</code></pre></div><p>最后一点是 <code>publish</code> 任务，它用来推送代码到仓库，并发布包到 npm。</p>
<div class="highlight"><pre><code class="bash">publish:
  git push --tags origin HEAD:master
  npm publish</code></pre></div><p>现在发布一个新的次要版本只需要在命令行执行 <code>make release-minor publish</code> － <code>package.json</code> 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。</p>
<p>完整的 <code>Makefile</code> 在 <a href="https://gist.github.com/5588256">这里</a>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Node.js 中使用 Asset Pipeline]]></title>
        <link href="http://7anshuai.js.org/blog/work/assets-pipeline-on-nodejs.html"/>
        <published>2015-03-16T14:03:07.000Z</published>
        <updated>2015-03-16T14:03:07.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/assets-pipeline-on-nodejs.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>-- Phil Karlton</p>
</blockquote>
<p>计算机科学只有两个难题：缓存失效和变量命名。</p>
<p><em>Coding</em> 中，这两道难题确实无处不在。难题之一缓存失效，Web 中的资源缓存涉及到服务器和浏览器两端的各种缓存机制（详情可阅读腾讯 AlloyTeam 的博客 <a href="http://alloyteam.com/2012/03/web-cache-1-web-cache-overview/">Web 缓存机制系列</a>）。当 Web 应用进行版本更新时，需要发布新的资源文件并更新缓存。那怎么让 Web 浏览器中原有的缓存失效，加载新的资源文件并缓存到客户端的计算机上呢？常见的两种做法是：</p>
<ul>
<li>传统手工作业</li>
<li>基于日期的请求字符串</li>
</ul>
<p>这两种方法都有明显的缺点，手动控制文件版本的做法通常是这样的：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.1/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.2/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>基于日期的请求字符串：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349480"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349481"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>这两种方法都有明显的缺点,传统手工作业是繁琐低效的，而基于日期的请求字符串的缓存并不可靠。在查看过 <a href="https://github.com/">GitHub</a> 的网页源码后，发现他们组织程序的静态资源方式有所不同：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://assets-cdn.github.com/assets/github-d869f6edeea2dbd9c7c3595e2f31cf8a1530bd36eaa84707461f65c5ee848853.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>文件名后面加上了一串字符串（基于MD5生成），顿觉莫名的高大上啊。偶尔在 <a href="https://ruby-china.org/">Ruby China</a> 闲逛得知，这是 Rails 3.1 版本开始引入的静态资源管理方式 <a href="http://guides.ruby-china.org/asset_pipeline.html">Asset Pipeline</a>。</p>
<h2 id="asset-pipeline-是什么？">Asset Pipeline 是什么？</h2><p>Rails 指南中提到，Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。它提供了三个主要功能：</p>
<ul>
<li>连接合并 JavaScript 和 CSS 文件，减少页面的 HTTP 请求。</li>
<li>压缩 JavaScript 和 CSS 文件（减重瘦身上前线）</li>
<li>高级语言及预处理器支持，允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript。</li>
</ul>
<p>在生产环境中，Rails 通过 Asset Pipeline 技术在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。</p>
<h2 id="md5-指纹">MD5 指纹</h2><p>Rails 指南中详细解释了指纹。指纹可以根据文件内容生成文件名，文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。</p>
<p>如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。</p>
<h2 id="connect-assets">connect-assets</h2><p>不同语言不同框架都有类似 Rails Asset Pipeline 的实现，<a href="https://github.com/adunkman/connect-assets">connect-assets</a> 是为 Node.js 打造的 Asset Pipeline。它也实现了以上所述的三个主要功能：合并，压缩 JavaScript/CSS 文件，高级语言预处理。在 Node.js 中也可以给静态资源添加指纹，使用更有效的缓存技术。</p>
<p>使用方法也很简单，第一步在项目中安装 connect-asset：</p>
<div class="highlight"><pre><code class="bash">npm install connect-assets</code></pre></div><p>第二步，在 Express 应用中添加配置代码：</p>
<div class="highlight"><pre><code class="javascript">app.use(require(<span class="string">'connect-assets'</span>)());</code></pre></div><p>最后，在项目中创建一个 <code>assets</code> 文件夹，并分别将 JavaScript 和 CSS 文件放入 <code>/assets/js</code> 和 <code>/assets/css</code>。</p>
<p>Node.js 应用就可以使用最基本的 connect-assets 功能了。</p>
<h3 id="标记函数">标记函数</h3><p>connect-assets 提供了三个名为 <code>js</code>，<code>css</code>, <code>assetPath</code> 的全局函数，可以在视图文件中使用它们。标记函数返回需要的包含最新版本的静态资源（或资源的路径）HTML 标记。例如，在一个 Jade 模板中的代码：</p>
<pre>!= css(&quot;normalize&quot;)
!= js(&quot;jquery&quot;)</pre><p><code>!=</code> 是 Jade 语法， 用于运行 JS 和显示输出，结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>你可以传递特殊属性给函数 <code>css</code> 或 <code>js</code>：</p>
<pre>!= css(&quot;normalize&quot;, {&quot;data-turbolinks-track&quot;: true})
!= js(&quot;jquery&quot;, {async: true})</pre><p>结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> <span class="attribute">data-turbolinks-track</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="sprockets-风格的合并">Sprockets 风格的合并</h3><p>可以在 <code>.js.coffee</code> 和 <code>.js</code> 文件中使用 Sprockets-style 语法指定依赖关系。</p>
<p>在 CoffeeScript 中：</p>
<div class="highlight"><pre><code class="coffeescript"><span class="comment">#= require dependency</span></code></pre></div><p>在 JavaScript 中：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">//= require dependency</span></code></pre></div><p>当你这样做并在 <code>js</code> 函数中指定该文件，会产生两个效果：</p>
<ul>
<li>默认的你会得到多个 <code>script</code>，按顺序输出你指定的所有依赖。</li>
<li>如果你传递 <code>build: true</code> 选项给 connect-assets（当 <code>env == &#39;production&#39;</code> 时默认开启），你会得到一个单独的标记，它指向一个将所有依赖目标都编译，合并，压缩（通过 UglifyJS）的 JavaScript 文件。</li>
</ul>
<p>如果你想包含整个文件夹的脚本，使用 <code>//= require_tree dir</code> 代替 <code>//= require file</code>。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="http://code.google.com/speed/page-speed/docs/caching.html">Optimize caching</a></li>
<li><a href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Revving Filenames: dont&#39;t use querystring</a></li>
</ul>
<p>周末福利:</p>
<p>豆瓣女神，独立音乐人，北大美女才女 － 程璧的官方主页 <a href="http://www.annapatio.com/">Anna&#39;s Patio</a> 是基于 Ruby on Rails，真心很赞啊！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[基本的命令行编辑技巧]]></title>
        <link href="http://7anshuai.js.org/blog/work/the-basic-command-line-editing.html"/>
        <published>2015-01-26T14:46:54.000Z</published>
        <updated>2015-01-26T14:46:54.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/the-basic-command-line-editing.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>GNU Bash shell 提供了 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html">Command line editing</a> 功能，它是由 <a href="http://tiswww.case.edu/php/chet/readline/rltop.html">Readline library</a> 实现的。Python 交互式命令行和 Node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing 支持 Emacs-style 和 Vi-style 的命令风格，默认的是 Emacs-style。</p>
<h2 id="命令行编辑">命令行编辑</h2><p>基本上，Unix/Linux 系统默认就支持 Command line editing，所以打开终端，或者在终端运行 Python interactive 或者 Node REPL，都可以马上使用常规的 Emacs 的控制字符集 <code>Control-*</code> 了。</p>
<ul>
<li><code>C-a</code> （Control-a）移动光标到行首</li>
<li><code>C-e</code> 移动光标到行尾</li>
<li><code>C-b</code> 将光标往左移动一个位置</li>
<li><code>C-f</code> 将光标往右移动一个位置</li>
<li><code>Backspace</code> 你懂得</li>
<li><code>C-d</code> 删除光标右边的一个字符</li>
<li><code>C-k</code> 删除光标右边所有的字符</li>
<li><code>C-y</code> 拉回最后一次删除的字符</li>
<li><code>C-_</code> 撤销最后一次操作</li>
</ul>
<h2 id="历史替换">历史替换</h2><p>历史替换（History Subsititution）的工作原理如下。所有已运行的非空命令行，都会保存到历史缓冲区，当你在一个新的提示符后输入时，实际上是在缓冲区底部添加新的一行。
<code>C-p</code> 可以往上移动一行，<code>C-n</code> 往下移动一行，<code>C-R</code> 可以反向搜索， <code>C-s</code> 向前搜索。</p>
<h2 id="键值绑定">键值绑定</h2><p>可以在 <code>~/.inputrc</code> 文件中增加一些自定义的命令和功能。常见的形式是： <code>key-name: function-name</code> 或 <code>&quot;string&quot;: function-name</code>，还可以通过 <code>set option-name vale</code> 设置选项。
一个简单的例子：</p>
<div class="highlight"><pre><code class="bash"><span class="comment"># I prefer vi-style editing:</span>
<span class="keyword">set</span> editing-mode vi

<span class="comment"># Edit using a single line:</span>
<span class="keyword">set</span> horizontal-scroll-mode On

<span class="comment"># Rebind some keys:</span>
Meta-h: backward-kill-word
<span class="string">"\C-u"</span>: universal-argument
<span class="string">"\C-x\C-r"</span>: re-read-init-file</code></pre></div><p>参考链接：</p>
<ul>
<li><a href="https://docs.python.org/2.7/tutorial/interactive.html">Interactive Input Editing and History Substitution</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[一个 JavaScript 控制台错误]]></title>
        <link href="http://7anshuai.js.org/blog/work/a-javascript-console-error.html"/>
        <published>2014-10-16T08:51:17.000Z</published>
        <updated>2014-10-16T08:51:17.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/a-javascript-console-error.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p>Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现<code>ReferenceError: varialbe is not defined</code>错误，令我感到迷惑不解。场景大致如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> getSth = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    $.ajax({
        url: <span class="string">'/echo/json'</span>,
        type: <span class="string">'GET'</span>,
        data: {key: key},
        dataType: <span class="string">'json'</span>
    }).done(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        console.log(key)
    })
}</code></pre></div><p>AJAX请求成功执行匿名回调函数时，<code>console.log</code>语句会正常打印<code>key</code>值。但将<code>console.log(key)</code>改为 <code>console.log(data)</code>，通过开发工具在此处设置一个断点，代码执行在断点处时在控制台中打印<code>key</code>，则会报错<code>ReferenceError: key is not defined</code>。</p>
<p>一开始想当然的认为<code>key</code>变量是通过查找作用域链获得，反复调试后发现，如果在匿名回调函数的代码中引用<code>key</code>变量的话，则会在当前作用域创建一个闭包，而 JavaScript 是基于<a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>，闭包的创建是在词法分析阶段，所以在代码执行时通过控制台动态的引用<code>key</code>值会得到一个<code>ReferenceError</code>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[在 Vim 中多行注释]]></title>
        <link href="http://7anshuai.js.org/blog/work/comment-lines-in-vim.html"/>
        <published>2014-06-17T13:47:14.000Z</published>
        <updated>2014-06-17T13:47:14.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/comment-lines-in-vim.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <p><a href="http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim">What&#39;s a quick way to comment/uncomment lines in vim?</a></p>
<p>Stackoverflow 上的一个关于 Vim comments 的问题有很多不错的答案，记录其中一个简单基础的方法。</p>
<ul>
<li>首先，将光标移动到想要注释的代码块第一行</li>
<li>然后 <code>Ctrl + V</code> （<code>Ctrl + Q</code> for Gvim）进入 Visual block mode</li>
<li>移动光标到要注释的代码末行</li>
<li><code>Shift + i</code>（大写 I）</li>
<li>添加行注释 <code>//</code> 或 <code>#</code></li>
<li>最后按下 <code>Esc</code></li>
</ul>
<p>Give it a second to work.</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Something to think about]]></title>
        <link href="http://7anshuai.js.org/blog/work/something-to-think-about.html"/>
        <published>2013-07-20T01:25:56.000Z</published>
        <updated>2013-07-20T01:25:56.000Z</updated>
        <id>http://7anshuai.js.org/blog/work/something-to-think-about.html</id>
        <content type="html" xml:base="http://7anshuai.js.org/blog/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies; the other is to make it so complicated that there are no obvious deficiencies.</p>
<p>Success in life is a matter not so much of talent and opportunity as of concentration and perserverance.</p>
<p>From <a href="http://swaroopch.com/notes/python/">A Byte of Python</a></p>
</blockquote>
]]>
        </content>
    </entry>
</feed>