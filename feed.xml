<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>谭帅的博客</title>
    <link href="http://blog.tanshuai.me/feed.xml" rel="self" />
    <link href="http://blog.tanshuai.me/" />
    <id>http://blog.tanshuai.me/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[在 Node.js 中使用 Asset Pipeline]]></title>
        <link href="http://blog.tanshuai.me/assets-pipeline-on-nodejs.html"/>
        <published>2015-03-16T14:03:07.000Z</published>
        <updated>2015-03-16T14:03:07.000Z</updated>
        <id>http://blog.tanshuai.me/assets-pipeline-on-nodejs.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>-- Phil Karlton</p>
</blockquote>
<p>计算机科学只有两个难题：缓存失效和变量命名。</p>
<p><em>Coding</em> 中，这两道难题确实无处不在。难题之一缓存失效，Web 中的资源缓存涉及到服务器和浏览器两端的各种缓存机制（详情可阅读腾讯 AlloyTeam 的博客 <a href="http://alloyteam.com/2012/03/web-cache-1-web-cache-overview/">Web 缓存机制系列</a>）。当 Web 应用进行版本更新时，需要发布新的资源文件并更新缓存。那怎么让 Web 浏览器中原有的缓存失效，加载新的资源文件并缓存到客户端的计算机上呢？常见的两种做法是：</p>
<ul>
<li>传统手工作业</li>
<li>基于日期的请求字符串</li>
</ul>
<p>这两种方法都有明显的缺点，手动控制文件版本的做法通常是这样的：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.1/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/0.0.2/js/app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>基于日期的请求字符串：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- version 0.0.1 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349480"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- version 0.0.2 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.example.com/static/js/app.js?1427594349481"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>这两种方法都有明显的缺点,传统手工作业是繁琐低效的，而基于日期的请求字符串的缓存并不可靠。在查看过 <a href="https://github.com/">GitHub</a> 的网页源码后，发现他们组织程序的静态资源方式有所不同：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://assets-cdn.github.com/assets/github-d869f6edeea2dbd9c7c3595e2f31cf8a1530bd36eaa84707461f65c5ee848853.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>文件名后面加上了一串字符串（基于MD5生成），顿觉莫名的高大上啊。偶尔在 <a href="https://ruby-china.org/">Ruby China</a> 闲逛得知，这是 Rails 3.1 版本开始引入的静态资源管理方式 <a href="http://guides.ruby-china.org/asset_pipeline.html">Asset Pipeline</a>。</p>
<h2 id="asset-pipeline-是什么？">Asset Pipeline 是什么？</h2><p>Rails 指南中提到，Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。它提供了三个主要功能：</p>
<ul>
<li>连接合并 JavaScript 和 CSS 文件，减少页面的 HTTP 请求。</li>
<li>压缩 JavaScript 和 CSS 文件（减重瘦身上前线）</li>
<li>高级语言及预处理器支持，允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript。</li>
</ul>
<p>在生产环境中，Rails 通过 Asset Pipeline 技术在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。</p>
<h2 id="md5-指纹">MD5 指纹</h2><p>Rails 指南中详细解释了指纹。指纹可以根据文件内容生成文件名，文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。</p>
<p>如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。</p>
<h2 id="connect-assets">connect-assets</h2><p>不同语言不同框架都有类似 Rails Asset Pipeline 的实现，<a href="https://github.com/adunkman/connect-assets">connect-assets</a> 是为 Node.js 打造的 Asset Pipeline。它也实现了以上所述的三个主要功能：合并，压缩 JavaScript/CSS 文件，高级语言预处理。在 Node.js 中也可以给静态资源添加指纹，使用更有效的缓存技术。</p>
<p>使用方法也很简单，第一步在项目中安装 connect-asset：</p>
<div class="highlight"><pre><code class="bash">npm install connect-assets</code></pre></div><p>第二步，在 Express 应用中添加配置代码：</p>
<div class="highlight"><pre><code class="javascript">app.use(require(<span class="string">'connect-assets'</span>)());</code></pre></div><p>最后，在项目中创建一个 <code>assets</code> 文件夹，并分别将 JavaScript 和 CSS 文件放入 <code>/assets/js</code> 和 <code>/assets/css</code>。</p>
<p>Node.js 应用就可以使用最基本的 connect-assets 功能了。</p>
<h3 id="标记函数">标记函数</h3><p>connect-assets 提供了三个名为 <code>js</code>，<code>css</code>, <code>assetPath</code> 的全局函数，可以在视图文件中使用它们。标记函数返回需要的包含最新版本的静态资源（或资源的路径）HTML 标记。例如，在一个 Jade 模板中的代码：</p>
<pre>!= css(&quot;normalize&quot;)
!= js(&quot;jquery&quot;)</pre><p><code>!=</code> 是 Jade 语法， 用于运行 JS 和显示输出，结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><p>你可以传递特殊属性给函数 <code>css</code> 或 <code>js</code>：</p>
<pre>!= css(&quot;normalize&quot;, {&quot;data-turbolinks-track&quot;: true})
!= js(&quot;jquery&quot;, {async: true})</pre><p>结果如下：</p>
<div class="highlight"><pre><code class="xml"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"/css/normalize-[hash].css"</span> <span class="attribute">data-turbolinks-track</span> /&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/jquery-[hash].js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="sprockets-风格的合并">Sprockets 风格的合并</h3><p>可以在 <code>.js.coffee</code> 和 <code>.js</code> 文件中使用 Sprockets-style 语法指定依赖关系。</p>
<p>在 CoffeeScript 中：</p>
<div class="highlight"><pre><code class="coffeescript"><span class="comment">#= require dependency</span></code></pre></div><p>在 JavaScript 中：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">//= require dependency</span></code></pre></div><p>当你这样做并在 <code>js</code> 函数中指定该文件，会产生两个效果：</p>
<ul>
<li>默认的你会得到多个 <code>script</code>，按顺序输出你指定的所有依赖。</li>
<li>如果你传递 <code>build: true</code> 选项给 connect-assets（当 <code>env == &#39;production&#39;</code> 时默认开启），你会得到一个单独的标记，它指向一个将所有依赖目标都编译，合并，压缩（通过 UglifyJS）的 JavaScript 文件。</li>
</ul>
<p>如果你想包含整个文件夹的脚本，使用 <code>//= require_tree dir</code> 代替 <code>//= require file</code>。</p>
<p>一个使用 connect-assets 的 Node.js App <a href="http://node.tanshuai.me/">Node starter</a>，fork from <a href="https://github.com/sahat/hackathon-starter">Hackathon Starter</a>。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="http://code.google.com/speed/page-speed/docs/caching.html">Optimize caching</a></li>
<li><a href="http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">Revving Filenames: dont&#39;t use querystring</a></li>
</ul>
<p>周末福利:</p>
<p>豆瓣女神，独立音乐人，北大美女才女 － 程璧的官方主页 <a href="http://www.annapatio.com/">Anna&#39;s Patio</a> 是基于 Ruby on Rails，真心很赞啊！</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[基本的命令行编辑技巧]]></title>
        <link href="http://blog.tanshuai.me/the-basic-command-line-editing.html"/>
        <published>2015-01-26T14:46:54.000Z</published>
        <updated>2015-01-26T14:46:54.000Z</updated>
        <id>http://blog.tanshuai.me/the-basic-command-line-editing.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>GNU Bash shell 提供了 <a href="https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html">Command line editing</a> 功能，它是由 <a href="http://tiswww.case.edu/php/chet/readline/rltop.html">Readline library</a> 实现的。Python 交互式命令行和 node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing 支持 Emacs-style 和 Vi-style 的命令风格，默认的是 Emacs-style。</p>
<h2 id="命令行编辑">命令行编辑</h2><p>基本上，Unix/Linux 系统默认就支持 Command line editing，所以打开终端，或者在终端运行 Python interactive 或者 Node REPL，都可以马上使用常规的 Emacs 的控制字符集 <code>Control-*</code> 了。</p>
<ul>
<li><code>C-a</code> （Control-a）移动光标到行首</li>
<li><code>C-e</code> 移动光标到行尾</li>
<li><code>C-b</code> 将光标往左移动一个位置</li>
<li><code>C-f</code> 将光标往右移动一个位置</li>
<li><code>Backspace</code> 你懂得</li>
<li><code>C-d</code> 删除光标右边的一个字符</li>
<li><code>C-k</code> 删除光标右边所有的字符</li>
<li><code>C-y</code> 拉回最后一次删除的字符</li>
<li><code>C-_</code> 撤销最后一次操作</li>
</ul>
<h2 id="历史替换">历史替换</h2><p>历史替换（History Subsititution）的工作原理如下。所有已运行的非空命令行，都会保存到历史缓冲区，当你在一个新的提示符后输入时，实际上是在缓冲区底部添加新的一行。
<code>C-p</code> 可以往上移动一行，<code>C-n</code> 往下移动一行，<code>C-R</code> 可以反向搜索， <code>C-s</code> 向前搜索。</p>
<h2 id="键值绑定">键值绑定</h2><p>可以在 <code>~/.inputrc</code> 文件中增加一些自定义的命令和功能。常见的形式是： <code>key-name: function-name</code> 或 <code>&quot;string&quot;: function-name</code>，还可以通过 <code>set option-name vale</code> 设置选项。
一个简单的例子：</p>
<div class="highlight"><pre><code class="bash"><span class="comment"># I prefer vi-style editing:</span>
<span class="keyword">set</span> editing-mode vi

<span class="comment"># Edit using a single line:</span>
<span class="keyword">set</span> horizontal-scroll-mode On

<span class="comment"># Rebind some keys:</span>
Meta-h: backward-kill-word
<span class="string">"\C-u"</span>: universal-argument
<span class="string">"\C-x\C-r"</span>: re-read-init-file</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[一个 JavaScript 控制台错误]]></title>
        <link href="http://blog.tanshuai.me/a-javascript-console-error.html"/>
        <published>2014-10-16T08:51:17.000Z</published>
        <updated>2014-10-16T08:51:17.000Z</updated>
        <id>http://blog.tanshuai.me/a-javascript-console-error.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现<code>ReferenceError: varialbe is not defined</code>错误，令我感到迷惑不解。场景大致如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> getSth = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    $.ajax({
        url: <span class="string">'/echo/json'</span>,
        type: <span class="string">'GET'</span>,
        data: {key: key},
        dataType: <span class="string">'json'</span>
    }).done(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        console.log(key)
    })
}</code></pre></div><p>AJAX请求成功执行匿名回调函数时，<code>console.log</code>语句会正常打印<code>key</code>值。但将<code>console.log(key)</code>改为 <code>console.log(data)</code>，通过开发工具在此处设置一个断点，代码执行在断点处时在控制台中打印<code>key</code>，则会报错<code>ReferenceError: key is not defined</code>。</p>
<p>一开始想当然的认为<code>key</code>变量是通过查找作用域链获得，反复调试后发现，如果在匿名回调函数的代码中引用<code>key</code>变量的话，则会在当前作用域创建一个闭包，而 JavaScript 是基于<a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>，闭包的创建是在词法分析阶段，所以在代码执行时通过控制台动态的引用<code>key</code>值会得到一个<code>ReferenceError</code>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Comment lines in vim]]></title>
        <link href="http://blog.tanshuai.me/comment-lines-in-vim.html"/>
        <published>2014-06-17T13:47:14.000Z</published>
        <updated>2014-06-17T13:47:14.000Z</updated>
        <id>http://blog.tanshuai.me/comment-lines-in-vim.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p><a href="http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim">What&#39;s a quick way to comment/uncomment lines in vim?</a> Stackoverflow 上的一个关于 Vim comments 的问题有很多不错的答案，记录第二个简单基础的方法。</p>
<p>首先，将光标移动到想要注释的代码块第一行，然后<code>Ctrl + V</code> （<code>Ctrl + Q</code> for Gvim）进入 Visual block mode，移动光标到要注释的代码末行，再 <code>Shift + i</code>，添加行注释<code>//</code>， 最后按下 <code>Esc</code>，Give it a second to work.</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Something to think about]]></title>
        <link href="http://blog.tanshuai.me/something-to-think-about.html"/>
        <published>2013-07-20T01:25:56.000Z</published>
        <updated>2013-07-20T01:25:56.000Z</updated>
        <id>http://blog.tanshuai.me/something-to-think-about.html</id>
        <content type="html" xml:base="http://blog.tanshuai.me/" xml:lang="en">
            <![CDATA[ <p>There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies; the other is to make it so complicated that there are no obvious deficiencies.</p>
<p>Success in life is a matter not so much of talent and opportunity as of concentration and perserverance.</p>
<p>From <a href="http://swaroopch.com/notes/python/">A Byte of Python</a></p>
]]>
        </content>
    </entry>
</feed>