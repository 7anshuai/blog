{"componentChunkName":"component---src-templates-blog-post-js","path":"/makefile-recipes-for-nodejs/","result":{"data":{"site":{"siteMetadata":{"title":"TS Blog"}},"markdownRemark":{"id":"ac1d7512-ff5a-5a99-a9fb-7069317116c2","excerpt":"原文链接：Makefile recipes for Node.js packages 当你编写 Node.js…","html":"<blockquote>\n<p>原文链接：<a href=\"https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html\">Makefile recipes for Node.js packages</a></p>\n</blockquote>\n<p>当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 <code class=\"language-text\">make</code> 程序来完成这些任务，主要是因为它的简单明了。</p>\n<p>要开始使用 <code class=\"language-text\">make</code> 你需要在项目根目录创建一个 <code class=\"language-text\">Makefile</code>。<code class=\"language-text\">Makefile</code> 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 <code class=\"language-text\">make &lt;task name&gt;</code>。简单吧！</p>\n<p>以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 <code class=\"language-text\">Makefile</code> 文件。我会一步一步的完成它。</p>\n<p>首先是定义一些有用的变量：我在 <code class=\"language-text\">src</code> 保存源码，编译过的代码放在 <code class=\"language-text\">lib</code>（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">BIN = ./node_modules/.bin\nSRC = $(wildcard src/*.coffee)\nLIB = $(SRC:src/%.coffee=lib/%.js)</code></pre></div>\n<p><code class=\"language-text\">SRC</code> 将会包含一个 <code class=\"language-text\">src</code> 目录中的 <code class=\"language-text\">.coffee</code> 文件列表，然后 <code class=\"language-text\">LIB</code> － 一个相对应的 <code class=\"language-text\">.js</code> 文件列表（目前还不存在）。<code class=\"language-text\">$(VAR:pattern1=pattern2)</code> 使用来指定存储在变量中的每一个项的变换。</p>\n<p>所以如果我们保存 <code class=\"language-text\">src/index.coffee src/mod.coffee</code> 在文件系统中， <code class=\"language-text\">SRC</code> 会捕获它们然后相应的使 <code class=\"language-text\">LIB</code> 保存 <code class=\"language-text\">lib/index.js lib/mod.js</code> 。</p>\n<p><code class=\"language-text\">BIN</code> 指向 Node 本地可执行模块的安装目录。</p>\n<h2>构建</h2>\n<p>现在让我们定义第一个任务构建并表明它依赖于存储在 <code class=\"language-text\">LIB</code> 变量的所有文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">build: <span class=\"token variable\"><span class=\"token variable\">$(</span>LIB<span class=\"token variable\">)</span></span></code></pre></div>\n<p>很简单，对不对？<code class=\"language-text\">$(LIB)</code> 只是在 <code class=\"language-text\">make</code> 中间接引用变量的语法。</p>\n<p>运行 <code class=\"language-text\">make build</code> 后，程序会尝试确保 <code class=\"language-text\">LIB</code> 中的所有文件都已就位并及时更新。但是我们如何让 <code class=\"language-text\">make</code> 知道怎样在 <code class=\"language-text\">SRC</code> 中获取相应的文件，处理并将所有的这些文件放入 <code class=\"language-text\">LIB</code> 中呢？</p>\n<p>接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － <code class=\"language-text\">lib/%.js</code> － 正是这个模式将会在 <code class=\"language-text\">LIB</code> 变量中进行文件匹配。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">lib/%.js: src/%.coffee\n  @mkdir -p <span class=\"token variable\"><span class=\"token variable\">$(</span>@D<span class=\"token variable\">)</span></span>\n  @<span class=\"token variable\"><span class=\"token variable\">$(</span>BIN<span class=\"token variable\">)</span></span>/coffee -bcp $<span class=\"token operator\">&lt;</span> <span class=\"token operator\">></span> <span class=\"token variable\">$@</span></code></pre></div>\n<p>这条规则告诉 <code class=\"language-text\">make</code> 那些 <code class=\"language-text\">lib/%.js</code> 文件依赖于相应的 <code class=\"language-text\">src/%.coffee</code> 文件，所以如果当后者发生改变时 <code class=\"language-text\">make</code> 会重新编译生成前者。</p>\n<p>它是如何工作的？首先，它创建了一个目标文件的目录（<code class=\"language-text\">$(@D)</code> 表示这个目录，它是 <code class=\"language-text\">make</code> 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 <code class=\"language-text\">.coffee</code> 文件（通过 <code class=\"language-text\">$&lt;</code> 表示）并将结果写入目标文件（通过 <code class=\"language-text\">$@</code> 表示）。</p>\n<p>注意 @ 前缀，默认的 <code class=\"language-text\">make</code> 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。</p>\n<p>足够作为一个构建程序了，<code class=\"language-text\">make build</code> 会从 src 目录下将相应的文件重新构建到 lib 目录下。</p>\n<h2>测试</h2>\n<p>测试任务很简单：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">test: build\n  @<span class=\"token variable\"><span class=\"token variable\">$(</span>BIN<span class=\"token variable\">)</span></span>/mocha -b specs</code></pre></div>\n<p>我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。</p>\n<h2>辅助任务</h2>\n<p>接下来到辅助任务 － <code class=\"language-text\">clean</code> 用来清除所有编译生成的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">clean:\n  @rm -f <span class=\"token variable\"><span class=\"token variable\">$(</span>LIB<span class=\"token variable\">)</span></span></code></pre></div>\n<p><code class=\"language-text\">install</code> 和 <code class=\"language-text\">link</code> 任务是简单的运行相应的 <code class=\"language-text\">npm</code> 子命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">install</span> link:\n  @npm <span class=\"token variable\">$@</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>注音 <code class=\"language-text\">$@</code> 变量的使用技巧，它是如何传递任务名称作为 <code class=\"language-text\">npm</code> 的子命令。</p>\n<h2>版本</h2>\n<p>下一个是版本任务。</p>\n<p>下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">define release\n  <span class=\"token assign-left variable\">VERSION</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>node -pe <span class=\"token string\">\"require('./package.json').version\"</span><span class=\"token variable\">`</span></span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token assign-left variable\">NEXT_VERSION</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>node -pe <span class=\"token string\">\"require('semver').inc(<span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$$</span>VERSION<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, '<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token number\">1</span><span class=\"token variable\">)</span></span>')\"</span><span class=\"token variable\">`</span></span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  node -e <span class=\"token string\">\"\\\n    var j = require('./package.json');\\\n    j.version = <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$$</span>NEXT_VERSION<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>;\\\n    var s = JSON.stringify(j, null, 2);\\\n    require('fs').writeFileSync('./package.json', s);\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"release <span class=\"token variable\">$$</span>NEXT_VERSION\"</span> -- package.json <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token function\">git</span> tag <span class=\"token string\">\"<span class=\"token variable\">$$</span>NEXT_VERSION\"</span> -m <span class=\"token string\">\"release <span class=\"token variable\">$$</span>NEXT_VERSION\"</span>\nendef</code></pre></div>\n<p>简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 <code class=\"language-text\">$1</code> 变量定义的）重写了 <code class=\"language-text\">package.json</code>，然后创建了一个相应的 <code class=\"language-text\">git commit</code> 和 <code class=\"language-text\">git tag</code>。</p>\n<p>接下啦只需要通过传递 <code class=\"language-text\">patch</code>，<code class=\"language-text\">minor</code> 或者 <code class=\"language-text\">major</code> 参数调用 <code class=\"language-text\">release</code> 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">release-patch: build <span class=\"token builtin class-name\">test</span>\n  @<span class=\"token variable\"><span class=\"token variable\">$(</span>call release,patch<span class=\"token variable\">)</span></span>\n\nrelease-minor: build <span class=\"token builtin class-name\">test</span>\n  @<span class=\"token variable\"><span class=\"token variable\">$(</span>call release,minor<span class=\"token variable\">)</span></span>\n\nrelease-major: build <span class=\"token builtin class-name\">test</span>\n  @<span class=\"token variable\"><span class=\"token variable\">$(</span>call release,major<span class=\"token variable\">)</span></span></code></pre></div>\n<p>最后一点是 <code class=\"language-text\">publish</code> 任务，它用来推送代码到仓库，并发布包到 npm。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">publish:\n  <span class=\"token function\">git</span> push --tags origin HEAD:master\n  <span class=\"token function\">npm</span> publish</code></pre></div>\n<p>现在发布一个新的次要版本只需要在命令行执行 <code class=\"language-text\">make release-minor publish</code> － <code class=\"language-text\">package.json</code> 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。</p>\n<p>完整的 <code class=\"language-text\">Makefile</code> 在 <a href=\"https://gist.github.com/5588256\">这里</a>。</p>","frontmatter":{"title":"【译】为 Node.js 包准备的 Makefile","date":"April 12, 2015","description":null}}},"pageContext":{"slug":"/makefile-recipes-for-nodejs/","previous":{"fields":{"slug":"/assets-pipeline-on-nodejs/"},"frontmatter":{"title":"在 Node.js 中使用 Asset Pipeline"}},"next":{"fields":{"slug":"/parse-command-line-arguments-in-bash/"},"frontmatter":{"title":"在 Bash 中解析命令行参数"}}}},"staticQueryHashes":["1246554614","2841359383"]}