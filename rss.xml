<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[TS Blog]]></title><description><![CDATA[A web blog.]]></description><link>http://7anshuai.js.org/blog</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 22 Sep 2020 12:12:04 GMT</lastBuildDate><item><title><![CDATA[【译】 使用 Bash Shell 编写脚本的快速指南]]></title><description><![CDATA[原文链接：A quick guide to writing scripts using the bash shell 简单的 shell 脚本 一个简单的 shell 脚本只是一点点按顺序执行的命令列表。通常，一个 shell…]]></description><link>http://7anshuai.js.org/blog/bash-tute/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/bash-tute/</guid><pubDate>Thu, 04 May 2017 00:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;!-- [//]: &lt;&gt; (# A quick guide to writing scripts using the bash shell) --&gt;
&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.panix.com/~elflord/unix/bash-tute.html&quot;&gt;A quick guide to writing scripts using the bash shell&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- [//]: &lt;&gt; (## A simple shell script) --&gt;
&lt;h2&gt;简单的 shell 脚本&lt;/h2&gt;
&lt;p&gt;一个简单的 shell 脚本只是一点点按顺序执行的命令列表。通常，一个 shell 脚本应该从如下面的一行开始：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (A shell script is little more than a list of commands that are run in sequence. Conventionally, a shellscript should start with a line such as the following:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示脚本应该在 bash shell 中运行，无论用户选择了哪个交互式 shell。这是非常重要的，因为不同 shell 的语法可能有很大差异。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This indicates that the script should be run in the bash shell regardless of which interactive shell the user has chosen. This is very important, since the syntax of different shells can vary greatly.) --&gt;
&lt;h3&gt;简单的例子&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### A simple example) --&gt;
&lt;p&gt;这是一个非常简单的 shell 脚本示例。 它只是运行一些简单的命令：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Here&apos;s a very simple example of a shell script. It just runs a few simple commands) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hello, &lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;. I wish to list some files of yours&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;listing files in the current directory, &lt;span class=&quot;token environment constant&quot;&gt;$PWD&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# list files&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，请注意第4行的注释。在一个 bash 脚本中，任何一个 &lt;code class=&quot;language-text&quot;&gt;#&lt;/code&gt;（除了第一行的 &lt;a href=&quot;https://zh.wikipedia.org/zh-hans/Shebang&quot;&gt;shebang&lt;/a&gt; 之外）都被视为注释。 即 shell 解释器会忽略它。而对于人们阅读脚本是有益的。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Firstly, notice the comment on line 4. In a bash script, anything following a pound sign # (besides the shell name on the first line) is treated as a comment. ie the shell ignores it. It is there for the benifit of people reading the script.) --&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$USER&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;$PWD&lt;/code&gt; 是&lt;em&gt;变量&lt;/em&gt;。这些是由 bash shell 本身定义的标准变量，它们不需要在脚本中定义。请注意，当变量名称在双引号内时，变量是&lt;em&gt;展开的&lt;/em&gt;（&lt;code class=&quot;language-text&quot;&gt;expanded&lt;/code&gt;）。展开（&lt;code class=&quot;language-text&quot;&gt;expand&lt;/code&gt;）是一个非常合适的词：shell 看到字符串 &lt;code class=&quot;language-text&quot;&gt;$USER&lt;/code&gt;，并用变量的值替换它，然后执行命令。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (`$USER` and `$PWD` are *variables*. These are standard variables defined by the bash shell itself, they needn&apos;t be defined in the script. Note that the variables are *expanded* when the variable name is inside double quotes. Expanded is a very appropriate word: the shell basically sees the string $USER and replaces it with the variable&apos;s value then executes the command.) --&gt;
&lt;p&gt;下面我们来继续讨论变量…&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (We continue the discussion on variables below ...) --&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;!-- [//]: &lt;&gt; (## Variables) --&gt;
&lt;p&gt;任何编程语言都需要变量。如下定义一个变量：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Any programming language needs variables. You define a variable as follows:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后引用它：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (and refer to it as follows:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更具体地说，&lt;code class=&quot;language-text&quot;&gt;$X&lt;/code&gt; 用于表示变量 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt; 的值。 一些要注意的语义：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (More specifically, `$X` is used to denote the value of the variable `X`. Some things to take note of regarding semantics:) --&gt;
&lt;!-- [//]: &lt;&gt; (- bash gets unhappy if you leave a space on either side of the `=` sign. For example, the following gives an error message:) --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你在 &lt;code class=&quot;language-text&quot;&gt;=&lt;/code&gt; 标志的两边留下空格，bash就会变得不快乐。 例如，以下内容导致了一个错误：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;X &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hello&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [//]: &lt;&gt; (- while I have quotes in my example, they are not always necessary. where you need quotes is when your variable names include spaces. For example,) --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虽然在我的例子中有引号，但并不总是必需的。 当变量的值包含空格时需要引号。 例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;hello world &lt;span class=&quot;token comment&quot;&gt;# error&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# OK&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是因为 shell 本质上将命令行看作一堆由空格分隔的命令和命令参数。 &lt;code class=&quot;language-text&quot;&gt;foo=baris&lt;/code&gt; 被认为是一个命令。 &lt;code class=&quot;language-text&quot;&gt;foo = bar&lt;/code&gt;的问题是 shell 看到由空格分隔的单词 &lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;，并把它解释为一个命令。 同样，命令 &lt;code class=&quot;language-text&quot;&gt;X=hello world&lt;/code&gt; 的问题是 shell 将 &lt;code class=&quot;language-text&quot;&gt;X=hello&lt;/code&gt; 解释为一个命令，而 &lt;code class=&quot;language-text&quot;&gt;world&lt;/code&gt; 这个词没有任何意义（因为赋值命令不能携带参数）。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This is because the shell essentially sees the command line as a pile of commands and command arguments seperated by spaces. `foo=baris` considered a command. The problem with `foo = bar` is the shell sees the word `foo` seperated by spaces and interprets it as a command. Likewise, the problem with the command `X=hello world` is that the shell interprets `X=hello` as a command, and the word &quot;world&quot; does not make any sense (since the assignment command doesn&apos;t take arguments).) --&gt;
&lt;h3&gt;单引号与双引号&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### Single Quotes versus double quotes) --&gt;
&lt;p&gt;基本上，变量名称只在双引号内展开，单引号里不展开。如果不需要引用变量，单引号很好用，因为结果更可预测。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Basically, variable names are exapnded within double quotes, but not single quotes. If you do not need to refer to variables, single quotes are good to use as the results are more predictable.) --&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; -n &lt;span class=&quot;token string&quot;&gt;&apos;&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;=&apos;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# -n option stops echo from breaking the line&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;\&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;=&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;&quot;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# this does the same thing as the first two lines&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出看起来像这样（假设你的用户名是 elflord）:&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The output looks like this (assuming your username is elflord)) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;elflord

&lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;elflord&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;双引号更灵活，但是可预测性较低。如果可以在两者之间选择的话，使用单引号。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (so the double quotes still have a work around. Double quotes are more flexible, but less predictable. Given the choice between single quotes and double quotes, use single quotes.) --&gt;
&lt;h3&gt;使用引号括起变量&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### Using Quotes to enclose your variables) --&gt;
&lt;p&gt;有时，使用双引号保护变量名是个好主意。 如果您的变量值包含空格或是空字符串，则这是很重要的。 一个例子如下：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Sometimes, it is a good idea to protect variable names in double quotes. This is usually the most important if your variables value either (a) contains spaces or (b) is the empty string. An example is as follows:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# -n tests to see if the argument is non empty&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;the variable X is not the empty string&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段脚本会输出：&lt;code class=&quot;language-text&quot;&gt;the variable X is not the empty string&lt;/code&gt;。
因为 shell 将 &lt;code class=&quot;language-text&quot;&gt;$X&lt;/code&gt; 展开为空字符串。 表达式 &lt;code class=&quot;language-text&quot;&gt;[ -n ]&lt;/code&gt; 返回 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;（因为它没有提供参数）。 一个更好的脚本将是：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This script will give the following output: the variable X is not the empty string) --&gt;
&lt;!-- [//]: &lt;&gt; (Why ? because the shell expands $X to the empty string. The expression [ -n ] returns true (since it is not provided with an argument). A better script would have been:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# -n tests to see if the argument is non empty&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;the variable X is not the empty string&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，表达式展开为 &lt;code class=&quot;language-text&quot;&gt;[ -n &amp;quot;&amp;quot; ]&lt;/code&gt;，返回 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;。因为用双引号括起来的字符串显然是空的。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (In this example, the expression expands to [ -n &quot;&quot; ] which returns false, since the string enclosed in inverted commas is clearly empty.) --&gt;
&lt;h3&gt;变量展开实战&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### Variable Expansion in action) --&gt;
&lt;p&gt;只是为了说服你，shell 真的像我之前提到的那样在 “展开” 变量，这里是一个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Just to convince you that the shell really does &quot;expand&quot; variables in the sense I mentioned before, here is an example:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;LS&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;ls&quot;&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;LS_FLAGS&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;-al&quot;&lt;/span&gt;

&lt;span class=&quot;token variable&quot;&gt;$LS&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$LS_FLAGS&lt;/span&gt; &lt;span class=&quot;token environment constant&quot;&gt;$HOME&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看起来有点神秘。 最后一行会发生什么，它实际上是执行命令
&lt;code class=&quot;language-text&quot;&gt;ls -al /home/elflord&lt;/code&gt;（假设 &lt;code class=&quot;language-text&quot;&gt;/home/elflord&lt;/code&gt; 是你的主目录）。 也就是说，shell 只是用它们的值替换变量，然后执行命令。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This looks a little enigmatic. What happens with the last line is that it actually executes the command `ls -al /home/elflord` (assuming that /home/elflord is your home directory). That is, the shell simply replaces the variables with their values, and then executes the command.) --&gt;
&lt;h3&gt;使用大括号来保护变量&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### Using Braces to Protect Your Variables) --&gt;
&lt;p&gt;好了，这里有一个潜在的问题。 假设要 &lt;code class=&quot;language-text&quot;&gt;echo&lt;/code&gt; 变量 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt; 的值，紧接着是字母 &lt;code class=&quot;language-text&quot;&gt;abc&lt;/code&gt;。 问题：你怎么做的？ 我们来试一试：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (OK. Here&apos;s a potential problem situation. Suppose you want to echo the value of the variable X, followed immediately by the letters &quot;abc&quot;. Question: how do you do this ? Let&apos;s have a try:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;ABC
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$Xabc&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样没有得到输出。哪里出了错？答案是，shell 认为我们引用的是未初始化的变量 &lt;code class=&quot;language-text&quot;&gt;Xabc&lt;/code&gt;。处理这个问题的方法是把大括号放在 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt; 上以将其与其他字符分开。以下给出了期望的结果：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This gives no output. What went wrong ? The answer is that the shell thought that we were asking for the variable Xabc, which is uninitialised. The way to deal with this is to put braces around X to seperate it from the other characters. The following gives the desired result:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;ABC
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${X}&lt;/span&gt;abc&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;条件语句&lt;/h2&gt;
&lt;!-- [//]: &lt;&gt; (## Conditionals, if/then/elif) --&gt;
&lt;p&gt;有时需要检查某些条件。一个字符串是否有0个长度？文件 “foo” 是否存在，它是一个符号链接还是一个真实的文件？首先，我们使用 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 命令来运行测试。 语法如下：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Sometimes, it&apos;s necessary to check for certain conditions. Does a string have 0 length ? does the file &quot;foo&quot; exist, and is it a symbolic link , or a real file ? Firstly, we use the if command to run a test. The syntax is as follows:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if condition
then
  statement1
  statement2
  ..........
fi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时您可能希望在条件失败时指定备用操作。这是如何做的：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Sometimes, you may wish to specify an alternate action when the condition fails. Here&apos;s how it&apos;s done.) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，如果第一个 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 失败，则可以测试另一个条件。 请注意，可以添加任何数量的 &lt;code class=&quot;language-text&quot;&gt;elif&lt;/code&gt;。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (alternatively, it is possible to test for another condition if the first &quot;if&quot; fails. Note that any number of elifs can be added.) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........    
elif condition3
then
  statement5
  statement6
  ........    

fi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果相应的条件为真，则 &lt;code class=&quot;language-text&quot;&gt;if/elif&lt;/code&gt; 和下一个 &lt;code class=&quot;language-text&quot;&gt;elif&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;fi&lt;/code&gt; 之间的块内的语句将被执行。 实际上，任何命令都可以替代条件，并且当且仅当命令返回退出状态为&lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;（换句话说，如果命令退出“成功”），则该块将被执行。 但是，在本文档中，我们只会使用 &lt;code class=&quot;language-text&quot;&gt;test&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;[ ]&lt;/code&gt; 来测试条件。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The statements inside the block between if/elif and the next elif or fi are executed if the corresponding condition is true. Actually, any command can go in place of the conditions, and the block will be executed if and only if the command returns an exit status of 0 (in other words, if the command exits &quot;succesfully&quot; ). However, in the course of this document, we will be only interested in using &quot;test&quot; or &quot;[ ]&quot; to evaluate conditions.) --&gt;
&lt;h3&gt;测试命令和操作符&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### The Test Command and Operators) --&gt;
&lt;p&gt;几乎所有的条件语句使用的命令都是测试命令。 测试返回 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;（更准确地说，退出 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt; 或非零状态），这取决于测试是通过还是失败。 它大概如下工作：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The command used in conditionals nearly all the time is the test command. Test returns true or false (more accurately, exits with 0 or non zero status) depending respectively on whether the test is passed or failed. It works like this:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;test operand1 operator operand2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于某些测试，只需要一个操作数（operand2）测试命令通常以下列形式缩写：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (for some tests, there need be only one operand (operand2) The test command is typically abbreviated in this form:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[ operator operand2 ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让讨论回到现实，我们举几个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (To bring this discussion back down to earth, we give a few examples:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;empty_string&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt; -lt &lt;span class=&quot;token variable&quot;&gt;$Y&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# is $X less than $Y ?&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;\&lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;=&lt;span class=&quot;token variable&quot;&gt;${X}&lt;/span&gt;, which is smaller than \&lt;span class=&quot;token variable&quot;&gt;$Y&lt;/span&gt;=&lt;span class=&quot;token variable&quot;&gt;${Y}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$empty_string&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;empty string is non_empty&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -e &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${&lt;span class=&quot;token environment constant&quot;&gt;HOME&lt;/span&gt;}&lt;/span&gt;/.fvwmrc&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;       &lt;span class=&quot;token comment&quot;&gt;# test to see if ~/.fvwmrc exists&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;you have a .fvwmrc file&quot;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -L &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${&lt;span class=&quot;token environment constant&quot;&gt;HOME&lt;/span&gt;}&lt;/span&gt;/.fvwmrc&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;     &lt;span class=&quot;token comment&quot;&gt;# is it a symlink ?  &lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;it&apos;s a symbolic link
  elif [ -f &quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;${&lt;span class=&quot;token environment constant&quot;&gt;HOME&lt;/span&gt;}&lt;/span&gt;/.fvwmrc&lt;span class=&quot;token string&quot;&gt;&quot; ]; then   # is it a regular file ?
    echo &quot;&lt;/span&gt;it&apos;s a regular &lt;span class=&quot;token function&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;
  fi
else
  echo &quot;&lt;/span&gt;you have no .fvwmrc file&quot;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;值得注意的一些陷阱&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### Some pitfalls to be wary of) --&gt;
&lt;p&gt;测试命令需要以“operand1 &lt;space&gt; operator &lt;space&gt; operand2”或“operator &lt;space&gt; operand2”的形式，换句话说，您真的需要这些空格，因为 shell 认为第一个不包含空格的块是运算符（如果以 &lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt; 开头）或操作数。例如：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The test command needs to be in the form &quot;operand1&lt;space&gt;operator&lt;space&gt;operand2&quot; or operator&lt;space&gt;operand2 , in other words you really need these spaces, since the shell considers the first block containing no spaces to be either an operator (if it begins with a &apos;-&apos;) or an operand (if it doesn&apos;t). So for example; this) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上会给出准确的 “错误” 输出（即 &lt;code class=&quot;language-text&quot;&gt;echo &amp;quot;hello&amp;quot;&lt;/code&gt;，因为 shell 看到一个操作数，但没有操作符）。&lt;/p&gt;
&lt;p&gt;另一个潜在的陷阱来自于不保护引号中的变量。 我们已经给出了一个例子，说明为什么你必须用引号括起你想要使用在 &lt;code class=&quot;language-text&quot;&gt;-n&lt;/code&gt; 测试中的操作数。而且，在大部分时候都有很多足够好的理由来使用引号。当您在测试中展开变量时，无法执行此操作可能会导致非常严重的错误。 以下是一个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (gives exactly the &quot;wrong&quot; output (ie it echos &quot;hello&quot;, since it sees an operand but no operator.)) --&gt;
&lt;!-- [//]: &lt;&gt; (Another potential trap comes from not protecting variables in quotes. We have already given an example as to why you must wrap anything you wish to use for a -n test with quotes. However, there are a lot of good reasons for using quotes all the time, or almost all of the time. Failing to do this when you have variables expanded inside tests can result in very wierd bugs. Here&apos;s an example: For example,) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;-n&quot;&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$Y&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;X=Y&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将导致错误输出，因为 shell 将我们的表达式展开为&lt;code class=&quot;language-text&quot;&gt;[ -n = ]&lt;/code&gt;，字符串 “=” 具有非零长度。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This will give misleading output since the shell expands our expression to `[ -n = ]` and the string &quot;=&quot; has non zero length.) --&gt;
&lt;h3&gt;测试操作符的简要总结&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### A brief summary of test operators) --&gt;
&lt;p&gt;以下是测试运算符的快速列表。 这不是全面的，但它可能是所有你需要记住的（如果你需要任何其他的，你可以随时检查 bash 手册页…）&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Here&apos;s a quick list of test operators. It&apos;s by no means comprehensive, but its likely to be all you&apos;ll need to remember (if you need anything else, you can always check the bash manpage ... )) --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operator&lt;/th&gt;
&lt;th&gt;produces true if…&lt;/th&gt;
&lt;th&gt;number of operands&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;operand non zero length&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-z&lt;/td&gt;
&lt;td&gt;operand has zero length&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;there exists a directory whose name is operand&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;there exists a file whose name is operand&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;the operands are integers and they are equal&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-neq&lt;/td&gt;
&lt;td&gt;the opposite of -eq&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;the operands are equal (as strings)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;opposite of =&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-lt&lt;/td&gt;
&lt;td&gt;operand1 is strictly less than operand2 (both operands should be integers)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-gt&lt;/td&gt;
&lt;td&gt;operand1 is strictly greater than operand2 (both operands should be integers)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ge&lt;/td&gt;
&lt;td&gt;operand1 is greater than or equal to operand2 (both operands should be integers)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-le&lt;/td&gt;
&lt;td&gt;operand1 is less than or equal to operand2 (both operands should be integers)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;循环&lt;/h2&gt;
&lt;!-- [//]: &lt;&gt; (## Loops) --&gt;
&lt;p&gt;循环是使得人们可以重复一个过程或对几个不同的项目执行相同的过程的结构。 在bash中有以下种类的循环可用：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Loops are constructions that enable one to reiterate a procedure or perform the same procedure on several different items. There are the following kinds of loops available in bash) --&gt;
&lt;ul&gt;
&lt;li&gt;for 循环&lt;/li&gt;
&lt;li&gt;while 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;for 循环&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### For loops) --&gt;
&lt;p&gt;for 循环的语法最适合通过示例描述：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The syntax for the for loops is best demonstrated by example.) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token for-or-select variable&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; red green blue
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for 循环遍历空白分隔的项。 请注意，如果某些项具有嵌入空白，则需要使用引号保护它们。 以下是一个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The for loop iterates the loop over the space seperated items. Note that if some of the items have embedded spaces, you need to protect them with quotes. Here&apos;s an example:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;colour1&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;colour2&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;light blue&quot;&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;colour3&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;dark green&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token for-or-select variable&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$colour1&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$colour2&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot; &lt;span class=&quot;token variable&quot;&gt;$colour3&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你能猜测如果我们在 for 语句中省略引号，会发生什么？ 这表明变量名应该用引号保护，除非你确定它们不包含任何空格。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Can you guess what would happen if we left out the quotes in the for statement ? This indicates that variable names should be protected with quotes unless you are pretty sure that they do not contain any spaces.) --&gt;
&lt;h4&gt;for 循环中的 glob&lt;/h4&gt;
&lt;!-- [//]: &lt;&gt; (#### Globbing in for loops) --&gt;
&lt;p&gt;shell 将包含 &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt; 的字符串扩展为“匹配”的所有文件名。当且仅当与匹配字符串相同时，文件名匹配，用任意字符串替换星号 &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt; 后。 例如，字符 &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt; 本身扩展到工作目录中所有文件的空格分隔列表（不包括以点开头的 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt;）。所以：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The shell expands a string containing a * to all filenames that &quot;match&quot;. A filename matches if and only if it is identical to the match string after replacing the stars * with arbitrary strings. For example, the character &quot;*&quot; by itself expands to a space seperated list of all files in the working directory (excluding those that start with a dot &quot;.&quot; ) So) --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;echo *&lt;/code&gt; 列出当前目录中的所有文件和目录&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;echo *.jpg&lt;/code&gt; 列出所有 jpeg 文件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;echo ${HOME}/public_html/*.jpg&lt;/code&gt; 列出您的 public_html 目录中的所有 jpeg 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正因为如此，这对于对目录中的文件执行操作非常有用，特别是与for循环一起使用。 例如：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (As it happens, this turns out to be very useful for performing operations on the files in a directory, especially used in conjunction with a for loop. For example:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token for-or-select variable&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; *.html
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -L &lt;span class=&quot;token string&quot;&gt;&apos;&amp;lt;UL&gt;&apos;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;while 循环&lt;/h3&gt;
&lt;!-- [//]: &lt;&gt; (### While Loops) --&gt;
&lt;p&gt;当一个给定的条件为真 while 循环进行迭代。 一个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (While loops iterate &quot;while&quot; a given condition is true. An example of this:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt; -le &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;
  &lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$((&lt;/span&gt;X&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这提出了一个自然的问题：为什么 bash 不允许 C 语言式的 for 循环 &lt;code class=&quot;language-text&quot;&gt;for（X = 1，X &amp;lt;10; X ++）&lt;/code&gt; ？&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (This raises a natural question: why doesn&apos;t bash allow the C like for loops `for (X=1,X&lt;10; X++)`) --&gt;
&lt;p&gt;事实上，for 循环不被鼓励使用，因为：bash 是一种解释性语言，而且它的循环是一个相当缓慢的事情。 因此，不鼓励重复迭代。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (As it happens, this is discouraged for a reason: bash is an interpreted language, and a rather slow one for that matter. For this reason, heavy iteration is discouraged.) --&gt;
&lt;h2&gt;命令替换&lt;/h2&gt;
&lt;!-- [//]: &lt;&gt; (## Command Substitution) --&gt;
&lt;p&gt;命令替换是 bash shell 非常方便的功能。 它使您可以获取命令的输出，并将其视为在命令行中写入。 例如，如果要将变量 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt; 设置为命令的输出，则通过命令替换来执行此操作。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Command Substitution is a very handy feature of the bash shell. It enables you to take the output of a command and treat it as though it was written on the command line. For example, if you want to set the variable X to the output of a command, the way you do this is via command substitution.) --&gt;
&lt;p&gt;有两种形式的命令替换：括号展开和反向展开。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (There are two means of command substitution: brace expansion and backtick expansion.) --&gt;
&lt;p&gt;括号扩展工作如下：&lt;code class=&quot;language-text&quot;&gt;$(commands)&lt;/code&gt; 展开到命令的输出，允许嵌套。因此命令可以包括括号扩展：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Brace expansion workls as follows: $(commands) expands to the output of commands This permits nesting, so commands can include brace expansions) --&gt;
&lt;p&gt;反向扩展将 &lt;code class=&quot;language-text&quot;&gt;commands&lt;/code&gt; 展开到命令的输出：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Backtick expansion expands `commands` to the output of commands) --&gt;
&lt;p&gt;给出一个例子：&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (An example is given:) --&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;web_files&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt; public_html&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$files&lt;/span&gt;&quot;&lt;/span&gt;      &lt;span class=&quot;token comment&quot;&gt;# we need the quotes to preserve embedded newlines in $files&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$web_files&lt;/span&gt;&quot;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# we need the quotes to preserve newlines&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;expr&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;* &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# expr evaluate arithmatic expressions. man expr for details.&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$X&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$()&lt;/code&gt; 替代方法的优点是几乎不言而喻：嵌套很容易。 大部分的 bourne shell 可以支持（或 POSIX shell）。但是，反向替换稍微可读性更好，甚至最基本的 shell 也支持（任何 &lt;code class=&quot;language-text&quot;&gt;#!/bin/sh&lt;/code&gt; 都很好）。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (The advantage of the $() substitution method is almost self evident: it is very easy to nest. It is supported by most of the bourne shell varients (the POSIX shell or better is OK). However, the backtick substitution is slightly more readable, and is supported by even the most basic shells (any #!/bin/sh version is just fine)) --&gt;
&lt;p&gt;请注意，如果字符串在上述 &lt;code class=&quot;language-text&quot;&gt;echo&lt;/code&gt; 语句中没有引号保护，换行符将被输出中的空格替换。&lt;/p&gt;
&lt;!-- [//]: &lt;&gt; (Note that if strings are not quote-protected in the above echo statement, new lines are replaced by spaces in the output.) --&gt;</content:encoded></item><item><title><![CDATA[在 Chrome DevTools 中并行调试 Node.js 和浏览器 JavaScript]]></title><description><![CDATA[Programmers make mistakes. For whimsical reasons, programming errors are called bugs and the process of tracking them down is called…]]></description><link>http://7anshuai.js.org/blog/nodejs-debugging-with-chrome-devtools/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/nodejs-debugging-with-chrome-devtools/</guid><pubDate>Thu, 09 Feb 2017 00:00:00 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Programmers make mistakes. For whimsical reasons, programming errors are called &lt;strong&gt;bugs&lt;/strong&gt; and the process of tracking them down is called &lt;strong&gt;debugging&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;— Allen Downey&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近读了 &lt;a href=&quot;http://greenteapress.com/wp/think-python-2e/&quot;&gt;Think Python&lt;/a&gt;，书中对 Debugging 的描述很有趣：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写代码，特别是 debugging，有时会产生强烈的情绪。如果你在与一个困难的 bug 做斗争，你可能会感动愤怒，沮丧或者尴尬。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;有证据表明，人们会很自然的把计算机当作人一样做出反应。当它们运转良好，我们认为它们是好队友，而当它们顽固或粗鲁时，我们也会像对待顽固，粗鲁的人一样回应它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;做点准备可能会帮助你处理这些反应。一种方法是将计算机视为具有某些优势（如速度和精度）和特定弱点（例如缺乏同情心和无法掌握大局）的员工。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你的工作是做一个好的经理：找到方法来利用优势和缓解弱点。 并找到使用你的情绪来解决问题的方法，而不会让你的反应干扰你的有效工作能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;学习 debug 可能令人沮丧，但它是一个有价值的技能，对于除了编程以外还有许多活动都是有用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于程序员来说最重要的技能是解决问题。善于 Debug 能极大的提高解决问题的效率和成功率。So, 做为 JS 开发者需要好好学习总结下 JavaScript 及 Node.js debug。&lt;/p&gt;
&lt;h2&gt;JavaScript Debugger&lt;/h2&gt;
&lt;p&gt;Web 浏览器附带一个通常被称为“开发者工具”的内置功能，它提供了更好的视角来观察运行在浏览器里的 JavaScript。虽然不是必须的，但当你调试代码错误时，你会发现开发者工具很有用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/&quot;&gt;Chrome DevTools&lt;/a&gt; 是 Google Chrome 中内置的一组网络制作和调试工具。 使用 DevTools 来迭代，调试和配置您的网站。具体的如何调试 JavaScript 代码可以参考&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/javascript/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Node debuggers&lt;/h2&gt;
&lt;h3&gt;Debugger&lt;/h3&gt;
&lt;p&gt;服务器端的 JavaScript 运行时环境 Node.js 包含了一个基于 TCP 协议访问的进程外调试工具和内置的调试客户端。要使用它，使用debug参数启动Node.js，然后是要调试的脚本的路径; 将显示一个提示，指示调试器成功启动：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ node debug myscript.js
&amp;lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(() =&amp;gt; {
  3   debugger;
debug&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node.js 的调试客户端不是一个全功能调试器，但简单的步骤和检查是可行的。&lt;/p&gt;
&lt;p&gt;更多的详情及高级用法可参考&lt;a href=&quot;https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Node Inspector&lt;/h3&gt;
&lt;p&gt;随着 Node.js 的大热，开源社区里的优秀开发者贡献了大量的 &lt;a href=&quot;https://github.com/sindresorhus/awesome-nodejs#debugging--profiling&quot;&gt;debugging 工具&lt;/a&gt;，其中的佼佼者便是 &lt;a href=&quot;https://github.com/node-inspector/node-inspector&quot;&gt;node-inspector&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Node Inspector 是 Node.js 应用程序的调试器接口，通过它可以使用 Blink（Chrome 浏览器内核）开发工具来进行 debugging。&lt;/p&gt;
&lt;h4&gt;安装&lt;/h4&gt;
&lt;p&gt;通过 npm 安装 node-inspector：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm install -g node-inspector&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;启动&lt;/h4&gt;
&lt;p&gt;然后启动程序：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ node-debug app.js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code class=&quot;language-text&quot;&gt;app.js&lt;/code&gt; 是您的 Node 应用程序主要 JavaScript 文件的名称。&lt;/p&gt;
&lt;h4&gt;调试&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;node-debug&lt;/code&gt; 命令将在默认浏览器中加载 Node Inspector。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠：Node Inspector 仅适用于 Chrome 和 Opera。 如果另一个浏览器是您的默认网络浏览器（例如 Safari 或 Internet Explorer），则必须在其中一个浏览器中重新打开检查器页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Node Inspector 的工作方式几乎与 Chrome DevTools 完全相同。&lt;/p&gt;
&lt;h4&gt;issues&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/node-inspector&quot;&gt;Node Inspector&lt;/a&gt; 目前最新的 package 版本是0.12.8，发布于10个月前。
而 Node.js 版本更新很快，v6.x 已经有十几个版本更新了。&lt;/p&gt;
&lt;p&gt;在好几个月前，我开始使用 Node.js v6.4.0，同样的也安装了 Node Inspector 来进行 Debugging，然后就遇到了：&lt;a href=&quot;https://github.com/node-inspector/node-inspector/issues/905&quot;&gt;Throwing exception on simple use case&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在好长一段时间，这个问题没有得到解决，相关讨论，PR也没有得到回应或者 Merge。直到最近，终于合并了一个 Pull Request：&lt;a href=&quot;https://github.com/node-inspector/node-inspector/pull/914&quot;&gt;Fix callback call in InjectorClient._findNMInScope&lt;/a&gt;。然而 Node Inspector package 还没有发布 patch 更新，所以 &lt;code class=&quot;language-text&quot;&gt;npm install -g node-inspector&lt;/code&gt; 依然会遇到这个问题。&lt;/p&gt;
&lt;p&gt;如果需要在 v6.4.0 以上版本使用 Node Inspector，可以直接从 github 下载安装 &lt;code class=&quot;language-text&quot;&gt;npm install -g https://github.com/node-inspector/node-inspector&lt;/code&gt;，或者手动修改 &lt;a href=&quot;https://github.com/node-inspector/node-inspector/pull/914/files&quot;&gt;InjectorClient.js&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Node.js 集成 V8 Inspector&lt;/h3&gt;
&lt;p&gt;在 Node Inspector issues里看到了很多讨论，有开发者提出了使用 &lt;code class=&quot;language-text&quot;&gt;node --inspect app.js&lt;/code&gt; 来替代 node-inspector。
原来 Node.js v6.3.0+ 已经内置支持了 &lt;a href=&quot;https://github.com/nodejs/node/pull/6792&quot;&gt;V8 Inspector&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html#debugger_v8_inspector_integration_for_node_js&quot;&gt;Node.js debugger docs&lt;/a&gt; 文档也增加了这部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠：这是一个实验特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;V8 Inspector 集成允许将 Chrome 开发工具通过 &lt;a href=&quot;https://developer.chrome.com/devtools/docs/debugger-protocol&quot;&gt;Chrome Debugging Protocol&lt;/a&gt; 连接到 Node.js 实例以进行调试和分析。&lt;/p&gt;
&lt;p&gt;V8 Inspector 可以通过在启动 Node.js 应用程序时传递 &lt;code class=&quot;language-text&quot;&gt;--inspect&lt;/code&gt; 标志来启用。 也可以提供具有该标志的自定义端口，例如， &lt;code class=&quot;language-text&quot;&gt;--inspect=9222&lt;/code&gt; 将接受端口9222上的 DevTools 连接。&lt;/p&gt;
&lt;p&gt;如需在应用的第一行代码添加断点，在 &lt;code class=&quot;language-text&quot;&gt;--inspect&lt;/code&gt; 之外增加 &lt;code class=&quot;language-text&quot;&gt;--debug-brk&lt;/code&gt; 标志。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node --inspect index.js
Debugger listening on port &lt;span class=&quot;token number&quot;&gt;9229&lt;/span&gt;.
Warning: This is an experimental feature and could change at any time.
To start debugging, &lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt; the following URL &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; Chrome:
    chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;true&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;v8only&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;true&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;ws&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;localhost:9229/node&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Node.js 与浏览器 JavaScript 并行调试&lt;/h2&gt;
&lt;p&gt;Chrome DevTools 已经进一步发展，打开具有特定网址的单独页面以调试 Node.js 代码的步骤已非必须。&lt;/p&gt;
&lt;p&gt;这意味着，今天你可以在同一个 DevTools 窗口中并行调试浏览器 JavaScript 文件和 Node.js，这有着完美的意义。&lt;/p&gt;
&lt;h3&gt;开启 DevTools 实验特性&lt;/h3&gt;
&lt;p&gt;目前 Chrome 浏览器 JavaScript 和 Node.js 代码的并行调试是一个实验性的新功能。&lt;/p&gt;
&lt;p&gt;要启用它，您必须执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开 &lt;a href=&quot;chrome://flags/#enable-devtools-experiments&quot;&gt;chrome://flags/#enable-devtools-experiments&lt;/a&gt; URL&lt;/li&gt;
&lt;li&gt;启用 &lt;code class=&quot;language-text&quot;&gt;Developer Tools experiments&lt;/code&gt; 标志&lt;/li&gt;
&lt;li&gt;重启 Chrome&lt;/li&gt;
&lt;li&gt;打开 DevTools 设置 -&gt; Experiments 选项（在重启之后它开始可见）&lt;/li&gt;
&lt;li&gt;按6次 “SHIFT” 以显示隐藏的实验功能&lt;/li&gt;
&lt;li&gt;选中 “Node debugging”&lt;/li&gt;
&lt;li&gt;打开/关闭 DevTools&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/6b4c087fgy1fcoxl9cy10j20zk10sn1m.jpg&quot; alt=&quot;Enable DevTools Experiments&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Debug&lt;/h3&gt;
&lt;p&gt;开始 debugging，像上面一样以 debug mode 启动 Node.js：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;node --inspect server.js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像平时一样在 Chrome 打开您的页面和 DevTools，选择 Sources -&gt; 按 &lt;code class=&quot;language-text&quot;&gt;ESC&lt;/code&gt; 开启 Console -&gt; 在 debugger 面板中点击 connect 连接 &lt;code class=&quot;language-text&quot;&gt;NodeJS Main Context&lt;/code&gt;：
&lt;img src=&quot;http://wx3.sinaimg.cn/mw690/6b4c087fgy1fcoxlafw3fj20zk0yyaha.jpg&quot; alt=&quot;Node.js debugging&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果您的 Node.js 应用有 console.log 或类似输出，您会看到，它们已经出现在 Chrome DevTools console。然后，你可以同时给浏览器和 Node.js 文件设置断点进行 debug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw1024/6b4c087fgy1fcq2n9u9rtg20gn0aenpd.gif&quot; alt=&quot;Node.js Debugging Gif&quot;&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;如果您的项目使用 Node.js，现在您可以从一个地方调试和更改所有 JavaScript - Chrome DevTools。&lt;/p&gt;
&lt;p&gt;您还可以将 Chrome DevTools 的所有强大功能应用于 Node.js 代码。&lt;/p&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/dist/latest-v6.x/docs/api/debugger.html&quot;&gt;Node.js Debugger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nodejs/node/pull/6792&quot;&gt;Add V8_inspector support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/node-inspector/node-inspector&quot;&gt;Node Inspector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27#.fuwv7r5ex&quot;&gt;Debugging Node.js with Chrome DevTools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools&quot;&gt;Node.js debugging with Chrome DevTools (in parallel with browser JavaScript)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[通过 Nginx 给本地应用取个漂亮域名]]></title><description><![CDATA[简单记录下之前看到并实践的一篇文章 Serving Apps Locally with Nginx and Pretty Domains。在 Mac OS X 上通过配置 Nginx 实现本地应用可以通过漂亮的域名来访问，比如 。类似的解决方案有 pow - Mac OS X…]]></description><link>http://7anshuai.js.org/blog/nginx-and-pretty-domains/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/nginx-and-pretty-domains/</guid><pubDate>Mon, 19 Sep 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;简单记录下之前看到并实践的一篇文章 &lt;a href=&quot;http://zaiste.net/2013/03/serving_apps_locally_with_nginx_and_pretty_domains/&quot;&gt;Serving Apps Locally with Nginx and Pretty Domains&lt;/a&gt;。在 Mac OS X 上通过配置 Nginx 实现本地应用可以通过漂亮的域名来访问，比如 &lt;code class=&quot;language-text&quot;&gt;http://anapp.dev/&lt;/code&gt;。类似的解决方案有 &lt;a href=&quot;http://pow.cx&quot;&gt;pow&lt;/a&gt; - Mac OS X 上的零配置 Rake Server。&lt;/p&gt;
&lt;h2&gt;Nginx&lt;/h2&gt;
&lt;p&gt;首先需要关掉 Apache 进程（Mac OS X 上默认启动 Apache 监听 &lt;code class=&quot;language-text&quot;&gt;80&lt;/code&gt; 端口）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 Homebrew 安装 Nginx ：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; nginx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nginx 监听 &lt;code class=&quot;language-text&quot;&gt;80&lt;/code&gt;（或任何小于 &lt;code class=&quot;language-text&quot;&gt;1024&lt;/code&gt; 的）端口需要使用 &lt;code class=&quot;language-text&quot;&gt;sudo&lt;/code&gt; 命令，否则会启动失败。对于大于 &lt;code class=&quot;language-text&quot;&gt;1024&lt;/code&gt; 的端口，如下直接为启动脚本建立一个符号链接：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;ln&lt;/span&gt; -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 HTTP 默认端口，需要在 &lt;code class=&quot;language-text&quot;&gt;/usr/local/etc/nginx.conf&lt;/code&gt; 中将 &lt;code class=&quot;language-text&quot;&gt;listen&lt;/code&gt; 的值从 &lt;code class=&quot;language-text&quot;&gt;8080&lt;/code&gt; 修改为 &lt;code class=&quot;language-text&quot;&gt;80&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;server {
     …
     listen 80;
     server_name localhost;
     …
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小于 &lt;code class=&quot;language-text&quot;&gt;1024&lt;/code&gt; 的端口不能为启动脚本建立符号链接，必须将脚本拷贝到 &lt;code class=&quot;language-text&quot;&gt;/Library/LaunchAgents&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cp&lt;/span&gt; /usr/local/opt/nginx/homebrew.mxcl.nginx.plist /Library/LaunchAgents&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code class=&quot;language-text&quot;&gt;homebrew.mxcl.nginx.plist&lt;/code&gt; 中，需要将 &lt;code class=&quot;language-text&quot;&gt;UserName&lt;/code&gt; 项修改为 &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt;。为了方便，还可以将 &lt;code class=&quot;language-text&quot;&gt;Label&lt;/code&gt; 项修改为 &lt;code class=&quot;language-text&quot;&gt;nginx&lt;/code&gt;，这样就可以使用&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;launchctl start nginx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代替&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;launchctl start homebrew.mxcl.nginx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;本地 DNS&lt;/h2&gt;
&lt;p&gt;接下来是设置一个本地的 DNS。因为不能在 &lt;code class=&quot;language-text&quot;&gt;/etc/hosts&lt;/code&gt; 文件中使用通配符，无法实现类似功能：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;127.0.0.1      *.dev.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了解决这个问题，需要安装一个叫做 &lt;a href=&quot;http://www.thekelleys.org.uk/dnsmasq/doc.html&quot;&gt;DNSMasq&lt;/a&gt; 的 DNS 代理：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; dnsmasq&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件存储在 &lt;code class=&quot;language-text&quot;&gt;/usr/local/etc/&lt;/code&gt; 下的 &lt;code class=&quot;language-text&quot;&gt;dnsmasq.conf&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;touch&lt;/span&gt; /usr/local/etc/dnsmasq.conf&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在文件中写入：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;address=/.dev/127.0.0.1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样所有 &lt;code class=&quot;language-text&quot;&gt;*.dev&lt;/code&gt; 的站点会被重定向到本地 IP，即 &lt;code class=&quot;language-text&quot;&gt;127.0.0.1&lt;/code&gt;。
类似 Nginx 进程，&lt;code class=&quot;language-text&quot;&gt;dnsmasq&lt;/code&gt; 需要 &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt; 权限：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cp&lt;/span&gt; -fv /usr/local/opt/dnsmasq/*.plist /Library/LaunchDaemons
&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; launchctl load /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，需要配置 OSX 使用本地系统作为首要 DNS 服务器。进入系统设置 -&gt; 网络，在 DNS 配置中将回环 IP (即 &lt;code class=&quot;language-text&quot;&gt;127.0.0.1&lt;/code&gt;)作为第一行，然后是惯例的 DNS IP：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;127.0.0.1
8.8.8.8
8.8.4.4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，试着 &lt;code class=&quot;language-text&quot;&gt;ping&lt;/code&gt; 任何以 &lt;code class=&quot;language-text&quot;&gt;.dev&lt;/code&gt; 结尾的地址，应该返回的 IP 地址是 &lt;code class=&quot;language-text&quot;&gt;127.0.0.1&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;ping&lt;/span&gt; example.dev
PING example.dev &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;token number&quot;&gt;56&lt;/span&gt; data bytes&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;虚拟主机&lt;/h2&gt;
&lt;p&gt;关于虚拟主机配置，按照惯例在 &lt;code class=&quot;language-text&quot;&gt;/usr/local/etc/nginx/&lt;/code&gt; 下创建两个目录 &lt;code class=&quot;language-text&quot;&gt;sites-enabled&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;sites-available&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;cd&lt;/span&gt; /usr/local/etc/nginx
&lt;span class=&quot;token function&quot;&gt;mkdir&lt;/span&gt; sites-available
&lt;span class=&quot;token function&quot;&gt;mkdir&lt;/span&gt; sites-enabled&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code class=&quot;language-text&quot;&gt;nginx.conf&lt;/code&gt; 中的 &lt;code class=&quot;language-text&quot;&gt;http&lt;/code&gt; 部分，需要加入以下行：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;include sites-enabled/*.dev;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后端参与的项目配置&lt;/h3&gt;
&lt;p&gt;现在可以指定每一个 app 的配置了。看一下配置模板文件：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;upstream NAME {
    server 127.0.0.1:3000;
}

server {
    listen 80;
    server_name NAME.dev;
    root PATH_TO_PUBLIC;

    try_files $uri/index.html $uri.html $uri @app;

    location @app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;
      proxy_redirect off;

      proxy_pass http://NAME;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了使它工作起来，至少需要修改两个地方，即 &lt;code class=&quot;language-text&quot;&gt;NAME&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;PATH_TO_PUBLIC&lt;/code&gt;。 &lt;code class=&quot;language-text&quot;&gt;NAME&lt;/code&gt; 可以是应用程序名称。 &lt;code class=&quot;language-text&quot;&gt;PATH_TO_PUBLIC&lt;/code&gt; 则指定项目静态资源目录，例如在 Express 中的路径为 &lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt;。
配置文件需要放在 &lt;code class=&quot;language-text&quot;&gt;sites-available&lt;/code&gt; 下，然后需要链接到 &lt;code class=&quot;language-text&quot;&gt;sites-enabled&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;ln&lt;/span&gt; -s /usr/local/etc/nginx/sites-available/anapp.dev &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;
  /usr/local/etc/nginx/sites-enabled/anapp.dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立链接后，需要重启 Nginx：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; launchctl stop nginx
&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; launchctl start nginx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;无后端参与的项目配置&lt;/h3&gt;
&lt;p&gt;以上的配置文件对于纯静态的项目来说是不必要的。可以通过位于 &lt;code class=&quot;language-text&quot;&gt;/usr/local/etc/nginx/nginx.conf&lt;/code&gt; 中默认的 &lt;code class=&quot;language-text&quot;&gt;server&lt;/code&gt; 指令设置一个动态的应用程序分发。Nginx 会在定义的基础路径中查找匹配被请求的域名目录。如在以下例子中， &lt;code class=&quot;language-text&quot;&gt;appname.dev&lt;/code&gt; 会匹配 &lt;code class=&quot;language-text&quot;&gt;/Users/zaiste/dev&lt;/code&gt; 下一个叫做 &lt;code class=&quot;language-text&quot;&gt;appname&lt;/code&gt; 的目录：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;server {
    listen       80;
    server_name  app localhost .dev;

    set $basepath &amp;quot;/Users/zaiste/dev&amp;quot;;

    set $domain $host;
    if ($domain ~ &amp;quot;^(.*)\.dev$&amp;quot;) {
        set $domain $1;
    }
    set $rootpath &amp;quot;${domain}&amp;quot;;
    if (-d $basepath/$domain/public) {
        set $rootpath &amp;quot;${domain}/public&amp;quot;;
    }
    if (-f $basepath/$domain/index.html) {
        set $rootpath $domain;
    }

    root $basepath/$rootpath;

    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，只需要在 &lt;code class=&quot;language-text&quot;&gt;/Users/zaiste/dev&lt;/code&gt; 创建一个新的目录及相应的 HTML 文件，剩下的事情就交给 Nginx 了。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/basecamp/pow&quot;&gt;Pow&lt;/a&gt; - Zero-configuration Rack server for Mac OS X&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zaiste.net/posts/serving_apps_locally_with_nginx_and_pretty_domains/&quot;&gt;Serving Apps Locally with Nginx and Pretty Domains
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://passingcuriosity.com/2013/dnsmasq-dev-osx/&quot;&gt;Using Dnsmasq for local development on OS X&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[在 Bash 中解析命令行参数]]></title><description><![CDATA[最近的一个前端小项目是智能 Wi-Fi 音箱 Sugr Cube 中的 Web 上传歌曲界面，使用了 Require.js 组织代码，文件上传部分基于 jQuery File Upload。Web page 编写完后需要使用 r.js…]]></description><link>http://7anshuai.js.org/blog/parse-command-line-arguments-in-bash/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/parse-command-line-arguments-in-bash/</guid><pubDate>Fri, 22 Apr 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近的一个前端小项目是智能 Wi-Fi 音箱 &lt;a href=&quot;http://sugrsugr.com&quot;&gt;Sugr Cube&lt;/a&gt; 中的 Web 上传歌曲界面，使用了 Require.js 组织代码，文件上传部分基于 &lt;a href=&quot;https://github.com/blueimp/jQuery-File-Upload&quot;&gt;jQuery File Upload&lt;/a&gt;。Web page 编写完后需要使用 r.js 打包处理下，并将生成的文件上传到硬件设备里的 &lt;a href=&quot;https://github.com/ankushagarwal/nweb&quot;&gt;Nweb&lt;/a&gt; 目录下。&lt;/p&gt;
&lt;h2&gt;项目结构&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;|--node_modules
|  |-- blueimp-file-upload-node
|  |  本地文件上传服务器
|  |-- requirejs
|  |  requirejs optimizer (r.js)
|  |-- inliner
|  |  Node utility to inline images, CSS and JavaScript for a web page
|--public
|  静态文件（css，js，images等）
|-- package.json
|  npm 项目配置
|-- index.html&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;npm scripts&lt;/h2&gt;
&lt;p&gt;编写 &lt;a href=&quot;https://docs.npmjs.com/misc/scripts&quot;&gt;npm scripts&lt;/a&gt; 用来运行相关脚本：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  ...&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;r.js -o baseUrl=public/js paths.requireLib=require paths.jquery=jquery name=app include=requireLib out=public/js/app-built.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;inliner&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;inliner -vs index.html &gt; www/index.html&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;node node_modules/blueimp-file-upload-node/server.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  ...
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，页面开发完后运行相应的命令 &lt;code class=&quot;language-text&quot;&gt;npm run build&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;npm run inliner&lt;/code&gt; 之后，再将生成好的单一 HTML 文件（www/index.html）scp 到硬件设备的文件 www 目录下。那么问题来了，调试过程中需要频繁的重复这一过程，而且硬件设备的局域网 IP 地址也常会发生变化，我需要个一键部署的 shell 脚本，比如这样：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;./publish --user root --host 192.168.1.99&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Bash script&lt;/h2&gt;
&lt;p&gt;如何编写一个能接受命令行参数的 Bash 脚本？在 stackoverflow 上找到大家推荐的方法：使用没有 getopt[s] 的 straight bash。&lt;/p&gt;
&lt;h3&gt;空格分离的 Straight Bash&lt;/h3&gt;
&lt;p&gt;使用方法：&lt;code class=&quot;language-text&quot;&gt;./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Use -gt 1 to consume two arguments per pass in the loop (e.g. each&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# argument has a corresponding value to go with it).&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# Use -gt 0 to consume one or more arguments per pass in the loop (e.g.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# some arguments don&apos;t have a corresponding value to go with it such&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# as in the --default example).&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# note: if this is set to -gt 0 the /etc/hosts part is not recognized ( may be a bug )&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$#&lt;/span&gt; -gt &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$key&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;
    -e&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--extension&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;EXTENSION&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    -s&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--searchpath&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;SEARCHPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    -l&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--lib&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;LIBPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    --default&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;YES
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    *&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# unknown option&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;esac&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument or value&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; FILE EXTENSION  &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${EXTENSION}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; SEARCH &lt;span class=&quot;token environment constant&quot;&gt;PATH&lt;/span&gt;     &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${SEARCHPATH}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; LIBRARY &lt;span class=&quot;token environment constant&quot;&gt;PATH&lt;/span&gt;    &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${LIBPATH}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Number files in SEARCH PATH with EXTENSION:&quot;&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt; -1 &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${SEARCHPATH}&lt;/span&gt;&quot;&lt;/span&gt;/*.&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${EXTENSION}&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;wc&lt;/span&gt; -l&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Last line of file specified as non-opt/last argument:&quot;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;tail&lt;/span&gt; -1 &lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;等号分离的 Straight Bash&lt;/h3&gt;
&lt;p&gt;使用方法：&lt;code class=&quot;language-text&quot;&gt;./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token for-or-select variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$@&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;
    -e&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--extension&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;EXTENSION&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${i&lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;*=}&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument=value&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    -s&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--searchpath&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;SEARCHPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${i&lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;*=}&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument=value&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    -l&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt;--lib&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;*&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;LIBPATH&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${i&lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;*=}&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument=value&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    --default&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token assign-left variable&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;YES
    &lt;span class=&quot;token builtin class-name&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# past argument with no value&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    *&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# unknown option&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;esac&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;done&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;FILE EXTENSION  = &lt;span class=&quot;token variable&quot;&gt;${EXTENSION}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;SEARCH PATH     = &lt;span class=&quot;token variable&quot;&gt;${SEARCHPATH}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;LIBRARY PATH    = &lt;span class=&quot;token variable&quot;&gt;${LIBPATH}&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Number files in SEARCH PATH with EXTENSION:&quot;&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt; -1 &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${SEARCHPATH}&lt;/span&gt;&quot;&lt;/span&gt;/*.&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${EXTENSION}&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;wc&lt;/span&gt; -l&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Last line of file specified as non-opt/last argument:&quot;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;tail&lt;/span&gt; -1 &lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了更好的理解 &lt;code class=&quot;language-text&quot;&gt;${i#*=}&lt;/code&gt; 可在&lt;a href=&quot;http://tldp.org/LDP/abs/html/string-manipulation.html&quot;&gt;这篇指南&lt;/a&gt;中查找 “Substring Removal”。它的功能等同于 &lt;code class=&quot;language-text&quot;&gt;sed &amp;#39;s/[^=]*=//&amp;#39; &amp;lt;&amp;lt;&amp;lt; &amp;quot;$i&amp;quot;&lt;/code&gt;（调用了一个不必要的子进程）或者 &lt;code class=&quot;language-text&quot;&gt;echo &amp;quot;$i&amp;quot; | sed &amp;#39;s/[^=]*=//&amp;#39;&lt;/code&gt;（调用了两个不必要的子进程）。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.panix.com/~elflord/unix/bash-tute.html&quot;&gt;A quick guide to writing scripts using the bash shell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash&quot;&gt;How do I parse command line arguments in bash?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[【译】为 Node.js 包准备的 Makefile]]></title><description><![CDATA[原文链接：Makefile recipes for Node.js packages 当你编写 Node.js…]]></description><link>http://7anshuai.js.org/blog/makefile-recipes-for-nodejs/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/makefile-recipes-for-nodejs/</guid><pubDate>Sun, 12 Apr 2015 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html&quot;&gt;Makefile recipes for Node.js packages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 程序来完成这些任务，主要是因为它的简单明了。&lt;/p&gt;
&lt;p&gt;要开始使用 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 你需要在项目根目录创建一个 &lt;code class=&quot;language-text&quot;&gt;Makefile&lt;/code&gt;。&lt;code class=&quot;language-text&quot;&gt;Makefile&lt;/code&gt; 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 &lt;code class=&quot;language-text&quot;&gt;make &amp;lt;task name&amp;gt;&lt;/code&gt;。简单吧！&lt;/p&gt;
&lt;p&gt;以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 &lt;code class=&quot;language-text&quot;&gt;Makefile&lt;/code&gt; 文件。我会一步一步的完成它。&lt;/p&gt;
&lt;p&gt;首先是定义一些有用的变量：我在 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt; 保存源码，编译过的代码放在 &lt;code class=&quot;language-text&quot;&gt;lib&lt;/code&gt;（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sh&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;BIN = ./node_modules/.bin
SRC = $(wildcard src/*.coffee)
LIB = $(SRC:src/%.coffee=lib/%.js)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SRC&lt;/code&gt; 将会包含一个 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt; 目录中的 &lt;code class=&quot;language-text&quot;&gt;.coffee&lt;/code&gt; 文件列表，然后 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; － 一个相对应的 &lt;code class=&quot;language-text&quot;&gt;.js&lt;/code&gt; 文件列表（目前还不存在）。&lt;code class=&quot;language-text&quot;&gt;$(VAR:pattern1=pattern2)&lt;/code&gt; 使用来指定存储在变量中的每一个项的变换。&lt;/p&gt;
&lt;p&gt;所以如果我们保存 &lt;code class=&quot;language-text&quot;&gt;src/index.coffee src/mod.coffee&lt;/code&gt; 在文件系统中， &lt;code class=&quot;language-text&quot;&gt;SRC&lt;/code&gt; 会捕获它们然后相应的使 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; 保存 &lt;code class=&quot;language-text&quot;&gt;lib/index.js lib/mod.js&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;BIN&lt;/code&gt; 指向 Node 本地可执行模块的安装目录。&lt;/p&gt;
&lt;h2&gt;构建&lt;/h2&gt;
&lt;p&gt;现在让我们定义第一个任务构建并表明它依赖于存储在 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; 变量的所有文件。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;build: &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;LIB&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，对不对？&lt;code class=&quot;language-text&quot;&gt;$(LIB)&lt;/code&gt; 只是在 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 中间接引用变量的语法。&lt;/p&gt;
&lt;p&gt;运行 &lt;code class=&quot;language-text&quot;&gt;make build&lt;/code&gt; 后，程序会尝试确保 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; 中的所有文件都已就位并及时更新。但是我们如何让 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 知道怎样在 &lt;code class=&quot;language-text&quot;&gt;SRC&lt;/code&gt; 中获取相应的文件，处理并将所有的这些文件放入 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; 中呢？&lt;/p&gt;
&lt;p&gt;接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － &lt;code class=&quot;language-text&quot;&gt;lib/%.js&lt;/code&gt; － 正是这个模式将会在 &lt;code class=&quot;language-text&quot;&gt;LIB&lt;/code&gt; 变量中进行文件匹配。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;lib/%.js: src/%.coffee
  @mkdir -p &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;@D&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
  @&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;BIN&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;/coffee -bcp $&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条规则告诉 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 那些 &lt;code class=&quot;language-text&quot;&gt;lib/%.js&lt;/code&gt; 文件依赖于相应的 &lt;code class=&quot;language-text&quot;&gt;src/%.coffee&lt;/code&gt; 文件，所以如果当后者发生改变时 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 会重新编译生成前者。&lt;/p&gt;
&lt;p&gt;它是如何工作的？首先，它创建了一个目标文件的目录（&lt;code class=&quot;language-text&quot;&gt;$(@D)&lt;/code&gt; 表示这个目录，它是 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 &lt;code class=&quot;language-text&quot;&gt;.coffee&lt;/code&gt; 文件（通过 &lt;code class=&quot;language-text&quot;&gt;$&amp;lt;&lt;/code&gt; 表示）并将结果写入目标文件（通过 &lt;code class=&quot;language-text&quot;&gt;$@&lt;/code&gt; 表示）。&lt;/p&gt;
&lt;p&gt;注意 @ 前缀，默认的 &lt;code class=&quot;language-text&quot;&gt;make&lt;/code&gt; 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。&lt;/p&gt;
&lt;p&gt;足够作为一个构建程序了，&lt;code class=&quot;language-text&quot;&gt;make build&lt;/code&gt; 会从 src 目录下将相应的文件重新构建到 lib 目录下。&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;测试任务很简单：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;test: build
  @&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;BIN&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;/mocha -b specs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。&lt;/p&gt;
&lt;h2&gt;辅助任务&lt;/h2&gt;
&lt;p&gt;接下来到辅助任务 － &lt;code class=&quot;language-text&quot;&gt;clean&lt;/code&gt; 用来清除所有编译生成的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;clean:
  @rm -f &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;LIB&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;install&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;link&lt;/code&gt; 任务是简单的运行相应的 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt; 子命令：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; link:
  @npm &lt;span class=&quot;token variable&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注音 &lt;code class=&quot;language-text&quot;&gt;$@&lt;/code&gt; 变量的使用技巧，它是如何传递任务名称作为 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt; 的子命令。&lt;/p&gt;
&lt;h2&gt;版本&lt;/h2&gt;
&lt;p&gt;下一个是版本任务。&lt;/p&gt;
&lt;p&gt;下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;define release
  &lt;span class=&quot;token assign-left variable&quot;&gt;VERSION&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;node -pe &lt;span class=&quot;token string&quot;&gt;&quot;require(&apos;./package.json&apos;).version&quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;token assign-left variable&quot;&gt;NEXT_VERSION&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;node -pe &lt;span class=&quot;token string&quot;&gt;&quot;require(&apos;semver&apos;).inc(&lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$$&lt;/span&gt;VERSION&lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;, &apos;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&apos;)&quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;
  node -e &lt;span class=&quot;token string&quot;&gt;&quot;\
    var j = require(&apos;./package.json&apos;);\
    j.version = &lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$$&lt;/span&gt;NEXT_VERSION&lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;;\
    var s = JSON.stringify(j, null, 2);\
    require(&apos;fs&apos;).writeFileSync(&apos;./package.json&apos;, s);&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; commit -m &lt;span class=&quot;token string&quot;&gt;&quot;release &lt;span class=&quot;token variable&quot;&gt;$$&lt;/span&gt;NEXT_VERSION&quot;&lt;/span&gt; -- package.json &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; tag &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$$&lt;/span&gt;NEXT_VERSION&quot;&lt;/span&gt; -m &lt;span class=&quot;token string&quot;&gt;&quot;release &lt;span class=&quot;token variable&quot;&gt;$$&lt;/span&gt;NEXT_VERSION&quot;&lt;/span&gt;
endef&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 &lt;code class=&quot;language-text&quot;&gt;$1&lt;/code&gt; 变量定义的）重写了 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;，然后创建了一个相应的 &lt;code class=&quot;language-text&quot;&gt;git commit&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;git tag&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下啦只需要通过传递 &lt;code class=&quot;language-text&quot;&gt;patch&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;minor&lt;/code&gt; 或者 &lt;code class=&quot;language-text&quot;&gt;major&lt;/code&gt; 参数调用 &lt;code class=&quot;language-text&quot;&gt;release&lt;/code&gt; 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;release-patch: build &lt;span class=&quot;token builtin class-name&quot;&gt;test&lt;/span&gt;
  @&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;call release,patch&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;

release-minor: build &lt;span class=&quot;token builtin class-name&quot;&gt;test&lt;/span&gt;
  @&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;call release,minor&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;

release-major: build &lt;span class=&quot;token builtin class-name&quot;&gt;test&lt;/span&gt;
  @&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;call release,major&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一点是 &lt;code class=&quot;language-text&quot;&gt;publish&lt;/code&gt; 任务，它用来推送代码到仓库，并发布包到 npm。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;publish:
  &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; push --tags origin HEAD:master
  &lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; publish&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在发布一个新的次要版本只需要在命令行执行 &lt;code class=&quot;language-text&quot;&gt;make release-minor publish&lt;/code&gt; － &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。&lt;/p&gt;
&lt;p&gt;完整的 &lt;code class=&quot;language-text&quot;&gt;Makefile&lt;/code&gt; 在 &lt;a href=&quot;https://gist.github.com/5588256&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[在 Node.js 中使用 Asset Pipeline]]></title><description><![CDATA[There are only two hard things in Computer Science: cache invalidation and naming things. — Phil Karlton 计算机科学只有两个难题：缓存失效和变量命名。 Coding…]]></description><link>http://7anshuai.js.org/blog/assets-pipeline-on-nodejs/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/assets-pipeline-on-nodejs/</guid><pubDate>Thu, 26 Mar 2015 14:03:07 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;
&lt;p&gt;— Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算机科学只有两个难题：缓存失效和变量命名。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Coding&lt;/em&gt; 中，这两道难题确实无处不在。难题之一缓存失效，Web 中的资源缓存涉及到服务器和浏览器两端的各种缓存机制（详情可阅读腾讯 AlloyTeam 的博客 &lt;a href=&quot;http://alloyteam.com/2012/03/web-cache-1-web-cache-overview/&quot;&gt;Web 缓存机制系列&lt;/a&gt;）。当 Web 应用进行版本更新时，需要发布新的资源文件并更新缓存。那怎么让 Web 浏览器中原有的缓存失效，加载新的资源文件并缓存到客户端的计算机上呢？常见的两种做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统手工作业&lt;/li&gt;
&lt;li&gt;基于日期的请求字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法都有明显的缺点，手动控制文件版本的做法通常是这样的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;&amp;lt;!-- version 0.0.1 --&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;http://cdn.example.com/static/0.0.1/js/app.js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;&amp;lt;!-- version 0.0.2 --&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;http://cdn.example.com/static/0.0.2/js/app.js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于日期的请求字符串：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;&amp;lt;!-- version 0.0.1 --&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;http://cdn.example.com/static/js/app.js?1427594349480&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;&amp;lt;!-- version 0.0.2 --&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;http://cdn.example.com/static/js/app.js?1427594349481&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方法都有明显的缺点,传统手工作业是繁琐低效的，而基于日期的请求字符串的缓存并不可靠。在查看过 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; 的网页源码后，发现他们组织程序的静态资源方式有所不同：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;https://assets-cdn.github.com/assets/github-d869f6edeea2dbd9c7c3595e2f31cf8a1530bd36eaa84707461f65c5ee848853.js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件名后面加上了一串字符串（基于MD5生成），顿觉莫名的高大上啊。偶尔在 &lt;a href=&quot;https://ruby-china.org/&quot;&gt;Ruby China&lt;/a&gt; 闲逛得知，这是 Rails 3.1 版本开始引入的静态资源管理方式 &lt;a href=&quot;http://guides.ruby-china.org/asset_pipeline.html&quot;&gt;Asset Pipeline&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Asset Pipeline 是什么？&lt;/h2&gt;
&lt;p&gt;Rails 指南中提到，Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。它提供了三个主要功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接合并 JavaScript 和 CSS 文件，减少页面的 HTTP 请求。&lt;/li&gt;
&lt;li&gt;压缩 JavaScript 和 CSS 文件（减重瘦身上前线）&lt;/li&gt;
&lt;li&gt;高级语言及预处理器支持，允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生产环境中，Rails 通过 Asset Pipeline 技术在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。&lt;/p&gt;
&lt;h2&gt;MD5 指纹&lt;/h2&gt;
&lt;p&gt;Rails 指南中详细解释了指纹。指纹可以根据文件内容生成文件名，文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。&lt;/p&gt;
&lt;p&gt;如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。&lt;/p&gt;
&lt;h2&gt;connect-assets&lt;/h2&gt;
&lt;p&gt;不同语言不同框架都有类似 Rails Asset Pipeline 的实现，&lt;a href=&quot;https://github.com/adunkman/connect-assets&quot;&gt;connect-assets&lt;/a&gt; 是为 Node.js 打造的 Asset Pipeline。它也实现了以上所述的三个主要功能：合并，压缩 JavaScript/CSS 文件，高级语言预处理。在 Node.js 中也可以给静态资源添加指纹，使用更有效的缓存技术。&lt;/p&gt;
&lt;p&gt;使用方法也很简单，第一步在项目中安装 connect-asset：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; connect-assets&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，在 Express 应用中添加配置代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;connect-assets&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，在项目中创建一个 &lt;code class=&quot;language-text&quot;&gt;assets&lt;/code&gt; 文件夹，并分别将 JavaScript 和 CSS 文件放入 &lt;code class=&quot;language-text&quot;&gt;/assets/js&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;/assets/css&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Node.js 应用就可以使用最基本的 connect-assets 功能了。&lt;/p&gt;
&lt;h3&gt;标记函数&lt;/h3&gt;
&lt;p&gt;connect-assets 提供了三个名为 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;css&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;assetPath&lt;/code&gt; 的全局函数，可以在视图文件中使用它们。标记函数返回需要的包含最新版本的静态资源（或资源的路径）HTML 标记。例如，在一个 Jade 模板中的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;!= css(&amp;quot;normalize&amp;quot;)
!= js(&amp;quot;jquery&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;!=&lt;/code&gt; 是 Jade 语法， 用于运行 JS 和显示输出，结果如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;link&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;rel&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;stylesheet&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;/css/normalize-[hash].css&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;/js/jquery-[hash].js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以传递特殊属性给函数 &lt;code class=&quot;language-text&quot;&gt;css&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;!= css(&amp;quot;normalize&amp;quot;, {&amp;quot;data-turbolinks-track&amp;quot;: true})
!= js(&amp;quot;jquery&amp;quot;, {async: true})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;link&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;rel&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;stylesheet&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;/css/normalize-[hash].css&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;data-turbolinks-track&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;/js/jquery-[hash].js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Sprockets 风格的合并&lt;/h3&gt;
&lt;p&gt;可以在 &lt;code class=&quot;language-text&quot;&gt;.js.coffee&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;.js&lt;/code&gt; 文件中使用 Sprockets-style 语法指定依赖关系。&lt;/p&gt;
&lt;p&gt;在 CoffeeScript 中：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;coffeescript&quot;&gt;&lt;pre class=&quot;language-coffeescript&quot;&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;#= require dependency&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 JavaScript 中：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//= require dependency&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你这样做并在 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt; 函数中指定该文件，会产生两个效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认的你会得到多个 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;，按顺序输出你指定的所有依赖。&lt;/li&gt;
&lt;li&gt;如果你传递 &lt;code class=&quot;language-text&quot;&gt;build: true&lt;/code&gt; 选项给 connect-assets（当 &lt;code class=&quot;language-text&quot;&gt;env == &amp;#39;production&amp;#39;&lt;/code&gt; 时默认开启），你会得到一个单独的标记，它指向一个将所有依赖目标都编译，合并，压缩（通过 UglifyJS）的 JavaScript 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想包含整个文件夹的脚本，使用 &lt;code class=&quot;language-text&quot;&gt;//= require_tree dir&lt;/code&gt; 代替 &lt;code class=&quot;language-text&quot;&gt;//= require file&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/speed/page-speed/docs/caching.html&quot;&gt;Optimize caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;Revving Filenames: dont’t use querystring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[基本的命令行编辑技巧]]></title><description><![CDATA[GNU Bash shell 提供了 Command line editing 功能，它是由 Readline library 实现的。Python 交互式命令行和 Node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing…]]></description><link>http://7anshuai.js.org/blog/the-basic-command-line-editing/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/the-basic-command-line-editing/</guid><pubDate>Mon, 26 Jan 2015 14:46:54 GMT</pubDate><content:encoded>&lt;hr&gt;
&lt;p&gt;GNU Bash shell 提供了 &lt;a href=&quot;https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html&quot;&gt;Command line editing&lt;/a&gt; 功能，它是由 &lt;a href=&quot;http://tiswww.case.edu/php/chet/readline/rltop.html&quot;&gt;Readline library&lt;/a&gt; 实现的。Python 交互式命令行和 Node.js REPL等程序都实现了类似的命令行编辑功能。Command line editing 支持 Emacs-style 和 Vi-style 的命令风格，默认的是 Emacs-style。&lt;/p&gt;
&lt;h2&gt;命令行编辑&lt;/h2&gt;
&lt;p&gt;基本上，Unix/Linux 系统默认就支持 Command line editing，所以打开终端，或者在终端运行 Python interactive 或者 Node REPL，都可以马上使用常规的 Emacs 的控制字符集 &lt;code class=&quot;language-text&quot;&gt;Control-*&lt;/code&gt; 了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-a&lt;/code&gt; （Control-a）移动光标到行首&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-e&lt;/code&gt; 移动光标到行尾&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-b&lt;/code&gt; 将光标往左移动一个位置&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-f&lt;/code&gt; 将光标往右移动一个位置&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Backspace&lt;/code&gt; 你懂得&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-d&lt;/code&gt; 删除光标右边的一个字符&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-k&lt;/code&gt; 删除光标右边所有的字符&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-y&lt;/code&gt; 拉回最后一次删除的字符&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C-_&lt;/code&gt; 撤销最后一次操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;历史替换&lt;/h2&gt;
&lt;p&gt;历史替换（History Subsititution）的工作原理如下。所有已运行的非空命令行，都会保存到历史缓冲区，当你在一个新的提示符后输入时，实际上是在缓冲区底部添加新的一行。
&lt;code class=&quot;language-text&quot;&gt;C-p&lt;/code&gt; 可以往上移动一行，&lt;code class=&quot;language-text&quot;&gt;C-n&lt;/code&gt; 往下移动一行，&lt;code class=&quot;language-text&quot;&gt;C-R&lt;/code&gt; 可以反向搜索， &lt;code class=&quot;language-text&quot;&gt;C-s&lt;/code&gt; 向前搜索。&lt;/p&gt;
&lt;h2&gt;键值绑定&lt;/h2&gt;
&lt;p&gt;可以在 &lt;code class=&quot;language-text&quot;&gt;~/.inputrc&lt;/code&gt; 文件中增加一些自定义的命令和功能。常见的形式是： &lt;code class=&quot;language-text&quot;&gt;key-name: function-name&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;string&amp;quot;: function-name&lt;/code&gt;，还可以通过 &lt;code class=&quot;language-text&quot;&gt;set option-name vale&lt;/code&gt; 设置选项。
一个简单的例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# I prefer vi-style editing:&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; editing-mode &lt;span class=&quot;token function&quot;&gt;vi&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;# Edit using a single line:&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; horizontal-scroll-mode On

&lt;span class=&quot;token comment&quot;&gt;# Rebind some keys:&lt;/span&gt;
Meta-h: backward-kill-word
&lt;span class=&quot;token string&quot;&gt;&quot;\C-u&quot;&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt; universal-argument
&lt;span class=&quot;token string&quot;&gt;&quot;\C-x\C-r&quot;&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt; re-read-init-file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2.7/tutorial/interactive.html&quot;&gt;Interactive Input Editing and History Substitution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[一个 JavaScript 控制台错误]]></title><description><![CDATA[Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现  错误，令我感到迷惑不解。 场景大致如下： AJAX…]]></description><link>http://7anshuai.js.org/blog/a-javascript-console-error/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/a-javascript-console-error/</guid><pubDate>Thu, 16 Oct 2014 08:51:17 GMT</pubDate><content:encoded>&lt;p&gt;Web 浏览器中的开发者工具都会提供一个控制台（或者也叫命令行）。在调试 JS 时，在控制台中打印变量或者测试代码片段都很方便。某日，在调试 JS 代码中，在控制台打印一个变量却出现 &lt;code class=&quot;language-text&quot;&gt;ReferenceError: varialbe is not defined&lt;/code&gt; 错误，令我感到迷惑不解。&lt;/p&gt;
&lt;p&gt;场景大致如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getSth&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    $&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        url&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/echo/json&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;GET&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        data&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;key&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        dataType&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;json&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AJAX请求成功执行匿名回调函数时，&lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 语句会正常打印 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 值。但将 &lt;code class=&quot;language-text&quot;&gt;console.log(key)&lt;/code&gt; 改为 &lt;code class=&quot;language-text&quot;&gt;console.log(data)&lt;/code&gt;，通过开发工具在此处设置一个断点，代码执行在断点处时在控制台中打印 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;，则会报错 &lt;code class=&quot;language-text&quot;&gt;ReferenceError: key is not defined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一开始想当然的认为&lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;变量是通过查找作用域链获得，反复调试后发现，如果在匿名回调函数的代码中引用 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;变量的话，则会在当前作用域创建一个闭包，而 JavaScript 是基于&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F&quot;&gt;词法作用域&lt;/a&gt;，闭包的创建是在词法分析阶段，所以在代码执行时通过控制台动态的引用 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 值会得到一个 &lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt;。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[在 Vim 中多行注释]]></title><description><![CDATA[What’s a quick way to comment/uncomment lines in vim? Stackoverflow 上的一个关于 Vim comments…]]></description><link>http://7anshuai.js.org/blog/comment-lines-in-vim/</link><guid isPermaLink="false">http://7anshuai.js.org/blog/comment-lines-in-vim/</guid><pubDate>Tue, 17 Jun 2014 13:47:14 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim&quot;&gt;What’s a quick way to comment/uncomment lines in vim?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stackoverflow 上的一个关于 Vim comments 的问题有很多不错的答案，记录其中一个简单基础的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将光标移动到想要注释的代码块第一行&lt;/li&gt;
&lt;li&gt;然后 &lt;code class=&quot;language-text&quot;&gt;Ctrl + V&lt;/code&gt; （&lt;code class=&quot;language-text&quot;&gt;Ctrl + Q&lt;/code&gt; for Gvim）进入 Visual block mode&lt;/li&gt;
&lt;li&gt;移动光标到要注释的代码末行&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Shift + i&lt;/code&gt;（大写 I）&lt;/li&gt;
&lt;li&gt;添加行注释 &lt;code class=&quot;language-text&quot;&gt;//&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后按下 &lt;code class=&quot;language-text&quot;&gt;Esc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Give it a second to work.&lt;/p&gt;</content:encoded></item></channel></rss>