<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="one 0.2">
    <title>[译] 为 Node.js 包准备的 Makefile</title>
    <link rel="stylesheet" href="../static/one.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59443769-2']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="brand">
          <a class="home" href="../">谭帅的博客</a>
        </div>
        <div class="menu" role="navigation">
          <a href="./">工作</a>
          <a href="../life/">生活</a>
          <a href="../feed.xml">订阅</a>
        </div>
      </div>
    </div>
    <div class="document yue">
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">[译] 为 Node.js 包准备的 Makefile</h1>
  <div class="entry-content" itemprop="articleBody"><p>当你编写 Node.js 代码时，在构建－测试－发布周期中肯定会有一些事情需要自动化。我使用 <code>make</code> 程序来完成这些任务，主要是因为它的简单明了。</p>
<p>要开始使用 <code>make</code> 你需要在项目根目录创建一个 <code>Makefile</code>。<code>Makefile</code> 包含变量和任务声明（下面会给出例子）。要执行一些任务，你只需要在命令行执行 <code>make &lt;task name&gt;</code>。简单吧！</p>
<p>以下是我开始一个新的 Node.js 或者 Browserify 项目的通用 <code>Makefile</code> 文件。我会一步一步的完成它。</p>
<p>首先是定义一些有用的变量：我在 <code>src</code> 保存源码，编译过的代码放在 <code>lib</code>（是的，我使用 CoffeeScript，但你可以随意使用你喜欢的语言来定制模板）。</p>
<pre>BIN = ./node_modules/.bin
SRC = $(wildcard src/*.coffee)
LIB = $(SRC:src/%.coffee=lib/%.js)</pre><p><code>SRC</code> 将会包含一个 <code>src</code> 目录中的 <code>.coffee</code> 文件列表，然后 <code>LIB</code> － 一个相对应的 <code>.js</code> 文件列表（目前还不存在）。<code>$(VAR:pattern1=pattern2)</code> 使用来指定存储在变量中的每一个项的变换。</p>
<p>所以如果我们保存 <code>src/index.coffee src/mod.coffee</code> 在文件系统中， <code>SRC</code> 会捕获它们然后相应的使 <code>LIB</code> 保存 <code>lib/index.js lib/mod.js</code> 。</p>
<p><code>BIN</code> 指向 Node 本地可执行模块的安装目录。</p>
<h2 id="构建">构建</h2><p>现在让我们定义第一个任务构建并表明它依赖于存储在 <code>LIB</code> 变量的所有文件。</p>
<div class="highlight"><pre><code class="bash">build: $(LIB)</code></pre></div><p>很简单，对不对？<code>$(LIB)</code> 只是在 <code>make</code> 中间接引用变量的语法。</p>
<p>运行 <code>make build</code> 后，程序会尝试确保 <code>LIB</code> 中的所有文件都已就位并及时更新。但是我们如何让 <code>make</code> 知道怎样在 <code>SRC</code> 中获取相应的文件，处理并将所有的这些文件放入 <code>LIB</code> 中呢？</p>
<p>接下来的片段定义了一个叫做通配符的规则，它作用于通过给定模式匹配的文件，在当前情况下 － <code>lib/%.js</code> － 正是这个模式将会在 <code>LIB</code> 变量中进行文件匹配。</p>
<div class="highlight"><pre><code class="bash">lib/%.js: src/%.coffee
  @mkdir -p $(@D)
  @$(BIN)/coffee -bcp $&lt; &gt; <span class="variable">$@</span></code></pre></div><p>这条规则告诉 <code>make</code> 那些 <code>lib/%.js</code> 文件依赖于相应的 <code>src/%.coffee</code> 文件，所以如果当后者发生改变时 <code>make</code> 会重新编译生成前者。</p>
<p>它是如何工作的？首先，它创建了一个目标文件的目录（<code>$(@D)</code> 表示这个目录，它是 <code>make</code> 中的一个魔法变量），然后调用 CoffeeScript 编译相应的 <code>.coffee</code> 文件（通过 <code>$&lt;</code> 表示）并将结果写入目标文件（通过 <code>$@</code> 表示）。</p>
<p>注意 @ 前缀，默认的 <code>make</code> 会打印所有执行的命令行，但有 @ 前缀的命令行不会打印。</p>
<p>足够作为一个构建程序了，<code>make build</code> 会从 src 目录下将相应的文件重新构建到 lib 目录下。</p>
<h2 id="测试">测试</h2><p>测试任务很简单：</p>
<div class="highlight"><pre><code class="bash">test: build
  @$(BIN)/mocha -b specs</code></pre></div><p>我们只需指明测试依赖构建任务 － 我们要测试最新的代码 － 然后运行选择的测试工具（当前场合是 mocha）。</p>
<h2 id="辅助任务">辅助任务</h2><p>接下来到辅助任务 － <code>clean</code> 用来清除所有编译生成的代码：</p>
<div class="highlight"><pre><code class="bash">clean:
  @rm <span class="operator">-f</span> $(LIB)</code></pre></div><p><code>install</code> 和 <code>link</code> 任务是简单的运行相应的 <code>npm</code> 子命令：</p>
<div class="highlight"><pre><code class="bash">install link:
  @npm <span class="variable">$@</span>;</code></pre></div><p>注音 <code>$@</code> 变量的使用技巧，它是如何传递任务名称作为 <code>npm</code> 的子命令。</p>
<h2 id="版本">版本</h2><p>下一个是版本任务。</p>
<p>下面的片段可能看起来有些复杂，但实际上它挺简单的。它定义了一个参数化的宏，用来打补丁，生成次要和主要版本。它被以下的任务所使用。</p>
<div class="highlight"><pre><code class="bash">define release
  VERSION=`node -pe <span class="string">"require('./package.json').version"</span>` &amp;&amp; \
  NEXT_VERSION=`node -pe <span class="string">"require('semver').inc(\"$<span class="variable">$VERSION</span>\", '<span class="variable">$(1)</span>')"</span>` &amp;&amp; \
  node <span class="operator">-e</span> <span class="string">"\
    var j = require('./package.json');\
    j.version = \"$<span class="variable">$NEXT_VERSION</span>\";\
    var s = JSON.stringify(j, null, 2);\
    require('fs').writeFileSync('./package.json', s);"</span> &amp;&amp; \
  git commit -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span> -- package.json &amp;&amp; \
  git tag <span class="string">"$<span class="variable">$NEXT_VERSION</span>"</span> -m <span class="string">"release $<span class="variable">$NEXT_VERSION</span>"</span>
endef</code></pre></div><p>简而言之，它使用一个新的递增版本号（版本递增的部分是通过宏参数 <code>$1</code> 变量定义的）重写了 <code>package.json</code>，然后创建了一个相应的 <code>git commit</code> 和 <code>git tag</code>。</p>
<p>接下啦只需要通过传递 <code>patch</code>，<code>minor</code> 或者 <code>major</code> 参数调用 <code>release</code> 宏来创建相应的任务，这些任务依赖构建和测试任务。这样如果不能通过构建或者测试则不能生成版本。</p>
<div class="highlight"><pre><code class="bash">release-patch: build test
  @$(call release,patch)

release-minor: build test
  @$(call release,minor)

release-major: build test
  @$(call release,major)</code></pre></div><p>最后一点是 <code>publish</code> 任务，它用来推送代码到仓库，并发布包到 npm。</p>
<div class="highlight"><pre><code class="bash">publish:
  git push --tags origin HEAD:master
  npm publish</code></pre></div><p>现在发布一个新的次要版本只需要在命令行执行 <code>make release-minor publish</code> － <code>package.json</code> 中的次要版本会递增，新的 Git 提交和标记会被创建和推送到仓库，最后 Node.js 包也会被发布在 npm。</p>
<p>完整的 <code>Makefile</code> 在 <a href="https://gist.github.com/5588256">这里</a>。</p>
<p>原文链接：<a href="https://andreypopp.com/posts/2013-05-16-makefile-recipes-for-node-js.html">Makefile recipes for Node.js packages</a></p>
</div>

  <div class="entry-meta">
    <time class="updated" datetime="2015-04-12T00:00:00.000Z" itemprop="dateModified">Sunday, Apr 12th, 2015</time>
    in <span class="entry-tags">
      
      <a href="../tag/node.js/">node.js</a>
      
      <a href="../tag/shell/">shell</a>
      
    </span>
  </div><div class="ds-thread" data-thread-key="95f8a6722f9b674ac4dd79239c171a18" data-title="[译] 为 Node.js 包准备的 Makefile"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"tanshuai"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
</div>
</div>
    <div class="footer">
      <p class="copyright">powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</p>
    </div>
    <script src="../static/one.js"></script>
  </body>
</html>