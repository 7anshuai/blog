<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="minimal 0.1">
    <title>[译] 使用 bash shell 编写脚本的快速指南（翻译中...）</title>
    <link rel="shortcut icon" href="http://7anshuai.js.org/favicon.ico" />
    <link rel="apple-touch-icon" href="http://7anshuai.js.org/apple-touch-icon.png" />
    <link rel="stylesheet" href="../static/style.css" />
    <link rel="stylesheet" href="../static/syntax.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59443769-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="../"><h1>tanshuai.blog()</h1></a>
        <nav class="menu" role="navigation">
          <p class="view">
            <a href="./">work</a>
          </p>
          <p class="view">
            <a href="../life/">life of shuai</a>
          </p>
          <p class="view">
            <a href="../feed.xml">feed</a>
          </p>
        </nav>
      </header>
      <section>
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">[译] 使用 bash shell 编写脚本的快速指南（翻译中...）</h1>
  <div class="entry-content" itemprop="articleBody"><blockquote>
<p>原文链接：<a href="http://www.panix.com/~elflord/unix/bash-tute.html">A quick guide to writing scripts using the bash shell</a></p>
</blockquote>
<h2 id="简单的-shell-脚本">简单的 shell 脚本</h2><p>一个简单的 shell 脚本只是一点点按顺序执行的命令列表。通常，一个 shell 脚本应该从如下面的一行开始：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span></code></pre></div><p>这表示脚本应该在 bash shell 中运行，无论用户选择了哪个交互式 shell。这是非常重要的，因为不同 shell 的语法可能有很大差异。</p>
<h3 id="简单的例子">简单的例子</h3><p>这是一个非常简单的 shell 脚本示例。 它只是运行一些简单的命令：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"hello, <span class="variable">$USER</span>. I wish to list some files of yours"</span>
<span class="built_in">echo</span> <span class="string">"listing files in the current directory, <span class="variable">$PWD</span>"</span>
ls  <span class="comment"># list files</span></code></pre></div><p>首先，请注意第4行的注释。在一个 bash 脚本中，任何一个 <code>#</code>（除了第一行的 <a href="https://zh.wikipedia.org/zh-hans/Shebang">shebang</a> 之外）都被视为注释。 即 shell 解释器会忽略它。而对于人们阅读脚本是有益的。</p>
<p><code>$USER</code> 和 <code>$PWD</code> 是<em>变量</em>。这些是由 bash shell 本身定义的标准变量，它们不需要在脚本中定义。请注意，当变量名称在双引号内时，变量是<em>展开的</em>（<code>expanded</code>）。展开（<code>expand</code>）是一个非常合适的词：shell 看到字符串 <code>$USER</code>，并用变量的值替换它，然后执行命令。</p>
<p>下面我们来继续讨论变量...</p>
<h2 id="变量">变量</h2><p>任何编程语言都需要变量。如下定义一个变量：</p>
<div class="highlight"><pre><code class="bash">X=<span class="string">"hello"</span></code></pre></div><p>然后引用它：</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$X</span></code></pre></div><p>更具体地说，<code>$X</code> 用于表示变量 <code>X</code> 的值。 关于语义的一些事情要注意：</p>
<ul>
<li>如果你在 <code>=</code> 标志的两边留下空格，bash就会变得不快乐。 例如，以下内容提供了一个错误信息：<div class="highlight"><pre><code class="bash">X = hello</code></pre></div></li>
</ul>
<ul>
<li>虽然在我的例子中有引号，但并不总是必需的。 当变量的值包含空格时需要引号。 例如：<div class="highlight"><pre><code class="bash">X=hello world <span class="comment"># error</span>
X=<span class="string">"hello world"</span> <span class="comment"># OK</span></code></pre></div></li>
</ul>
<p>这是因为 shell 本质上将命令行看作一堆由空格分隔的命令和命令参数。 <code>foo=baris</code> 被认为是一个命令。 <code>foo = bar</code>的问题是 shell 看到由空格分隔的单词 <code>foo</code>，并把它解释为一个命令。 同样，命令 <code>X=hello world</code> 的问题是 shell 将 <code>X=hello</code> 解释为一个命令，而 <code>world</code> 这个词没有任何意义（因为赋值命令不能携带参数）。</p>
<h3 id="单引号与双引号">单引号与双引号</h3><p>基本上，变量名称只在双引号内展开，单引号里不展开。如果不需要引用变量，单引号很好用，因为结果更可预测。</p>
<p>一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> -n <span class="string">'$USER='</span> <span class="comment"># -n option stops echo from breaking the line</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>"</span>
<span class="built_in">echo</span> <span class="string">"\$USER=<span class="variable">$USER</span>"</span>  <span class="comment"># this does the same thing as the first two lines</span></code></pre></div><p>输出看起来像这样（假设你的用户名是 elflord）:</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$USER</span>=elflord

<span class="variable">$USER</span>=elflord</code></pre></div><p>双引号更灵活，但是可预测性较低。如果可以在两者之间选择的话，使用单引号。</p>
<h3 id="使用引号括起变量">使用引号括起变量</h3><p>有时，使用双引号保护变量名是个好主意。 如果您的变量值（a）包含空格或（b）是空字符串，则这是很重要的。 一个例子如下：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="variable">$X</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>这段脚本会输出：<code>the variable X is not the empty string</code>。
因为 shell 将 <code>$X</code> 扩展为空字符串。 表达式 <code>[-n]</code> 返回 <code>true</code>（因为它没有提供参数）。 一个更好的脚本将是：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$X</span>"</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>在这个例子中，表达式展开为 <code>[ -n &quot;&quot; ]</code>，返回 <code>false</code>。因为用双引号括起来的字符串显然是空的。</p>
<h3 id="变量展开实战">变量展开实战</h3><p>只是为了说服你，shell 真的像我之前提到的那样在 “展开” 变量，这里是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
LS=<span class="string">"ls"</span>
LS_FLAGS=<span class="string">"-al"</span>

<span class="variable">$LS</span> <span class="variable">$LS_FLAGS</span> <span class="variable">$HOME</span></code></pre></div><p>这看起来有点神秘。 最后一行会发生什么，它实际上是执行命令
<code>ls -al /home/elflord</code>（假设 <code>/home/elflord</code> 是你的主目录）。 也就是说，shell 只是用它们的值替换变量，然后执行命令。</p>
<h3 id="使用大括号来保护变量">使用大括号来保护变量</h3><p>好了，这里有一个潜在的问题。 假设要 <code>echo</code> 变量 <code>X</code> 的值，紧接着是字母 <code>abc</code>。 问题：你怎么做的？ 我们来试一试：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">$Xabc</span>"</span></code></pre></div><p>这样没有得到输出。哪里出了错？答案是，shell 认为我们引用的是未初始化的变量 <code>Xabc</code>。处理这个问题的方法是把大括号放在 <code>X</code> 上以将其与其他字符分开。以下给出了期望的结果：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">${X}</span>abc"</span></code></pre></div><h2 id="条件语句">条件语句</h2><p>有时需要检查某些条件。一个字符串是否有0个长度？文件“foo”是否存在，它是一个符号链接还是一个真实的文件？首先，我们使用 <code>if</code> 命令来运行测试。 语法如下：</p>
<pre>if condition
then
  statement1
  statement2
  ..........
fi</pre><p>有时您可能希望在条件失败时指定备用操作。这是如何做的：
<a href="&lt;" title="The statements inside the block between if/elif and the next elif or fi are executed if the corresponding condition is true. Actually, any command can go in place of the conditions, and the block will be executed if and only if the command returns an exit status of 0 (in other words, if the command exits &quot;succesfully&quot; ). However, in the course of this document, we will be only interested in using &quot;test&quot; or &quot;[ ]&quot; to evaluate conditions.">//</a>: &lt;&gt; (Sometimes, you may wish to specify an alternate action when the condition fails. Here&#39;s how it&#39;s done.）</p>
<pre>if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi</pre><p>或者，如果第一个 <code>if</code> 失败，则可以测试另一个条件。 请注意，可以添加任何数量的 <code>elif</code>。</p>
<pre>if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........    
elif condition3
then
  statement5
  statement6
  ........    

fi</pre><p>如果相应的条件为真，则 <code>if/elif</code> 和下一个 <code>elif</code> 或 <code>fi</code> 之间的块内的语句将被执行。 实际上，任何命令都可以替代条件，并且当且仅当命令返回退出状态为<code>0</code>（换句话说，如果命令退出“成功”），则该块将被执行。 但是，在本文档中，我们只会使用 <code>test</code> 或 <code>[ ]</code> 来测试条件。</p>
<h2 id="the-test-command-and-operators">The Test Command and Operators</h2><p>The command used in conditionals nearly all the time is the test command. Test returns true or false (more accurately, exits with 0 or non zero status) depending respectively on whether the test is passed or failed. It works like this:
test operand1 operator operand2
for some tests, there need be only one operand (operand2) The test command is typically abbreviated in this form:
[ operand1 operator operand2 ]
To bring this discussion back down to earth, we give a few examples:</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">3</span>
Y=<span class="number">4</span>
empty_string=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> <span class="operator">-lt</span> <span class="variable">$Y</span> ]  <span class="comment"># is $X less than $Y ?</span>
<span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"\$X=<span class="variable">${X}</span>, which is smaller than \$Y=<span class="variable">${Y}</span>"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$empty_string</span>"</span> ]; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"empty string is non_empty"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ <span class="operator">-e</span> <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>       <span class="comment"># test to see if ~/.fvwmrc exists</span>
  <span class="built_in">echo</span> <span class="string">"you have a .fvwmrc file"</span>
  <span class="keyword">if</span> [ -L <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>     <span class="comment"># is it a symlink ?  </span>
    <span class="built_in">echo</span> <span class="string">"it's a symbolic link
  elif [ -f "</span><span class="variable">${HOME}</span>/.fvwmrc<span class="string">" ]; then   # is it a regular file ?
    echo "</span>it<span class="string">'s a regular file"
  fi
else
  echo "you have no .fvwmrc file"
fi</span></code></pre></div><p>Some pitfalls to be wary of</p>
<p>The test command needs to be in the form &quot;operand1<space>operator<space>operand2&quot; or operator<space>operand2 , in other words you really need these spaces, since the shell considers the first block containing no spaces to be either an operator (if it begins with a &#39;-&#39;) or an operand (if it doesn&#39;t). So for example; this</p>
<pre>if [ 1=2 ]; then
  echo &quot;hello&quot;
fi</pre><p>gives exactly the &quot;wrong&quot; output (ie it echos &quot;hello&quot;, since it sees an operand but no operator.)
Another potential trap comes from not protecting variables in quotes. We have already given an example as to why you must wrap anything you wish to use for a -n test with quotes. However, there are a lot of good reasons for using quotes all the time, or almost all of the time. Failing to do this when you have variables expanded inside tests can result in very wierd bugs. Here&#39;s an example: For example,</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">"-n"</span>
Y=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> = <span class="variable">$Y</span> ] ; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"X=Y"</span>
<span class="keyword">fi</span></code></pre></div><p>This will give misleading output since the shell expands our expression to
[ -n = ]
and the string &quot;=&quot; has non zero length.</p>
<h3 id="a-brief-summary-of-test-operators">A brief summary of test operators</h3><p>Here&#39;s a quick list of test operators. It&#39;s by no means comprehensive, but its likely to be all you&#39;ll need to remember (if you need anything else, you can always check the bash manpage ... )</p>
<table>
<thead>
<tr>
<th>operator</th>
<th>produces true if...</th>
<th>number of operands</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>operand non zero length</td>
<td>1</td>
</tr>
<tr>
<td>-z</td>
<td>operand has zero length</td>
<td>1</td>
</tr>
<tr>
<td>-d</td>
<td>there exists a directory whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-f</td>
<td>there exists a file whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-eq</td>
<td>the operands are integers and they are equal</td>
<td>2</td>
</tr>
<tr>
<td>-neq</td>
<td>the opposite of -eq</td>
<td>2</td>
</tr>
<tr>
<td>=</td>
<td>the operands are equal (as strings)</td>
<td>2</td>
</tr>
<tr>
<td>!=</td>
<td>opposite of =</td>
<td>2</td>
</tr>
<tr>
<td>-lt</td>
<td>operand1 is strictly less than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-gt</td>
<td>operand1 is strictly greater than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-ge</td>
<td>operand1 is greater than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-le</td>
<td>operand1 is less than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="loops">Loops</h2><p>Loops are constructions that enable one to reiterate a procedure or perform the same procedure on several different items. There are the following kinds of loops available in bash</p>
<ul>
<li>for loops</li>
<li>while loops</li>
</ul>
<h3 id="for-loops">For loops</h3><p>The syntax for the for loops is best demonstrated by example.</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> red green blue
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>THe for loop iterates the loop over the space seperated items. Note that if some of the items have embedded spaces, you need to protect them with quotes. Here&#39;s an example:</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
colour1=<span class="string">"red"</span>
colour2=<span class="string">"light blue"</span>
colour3=<span class="string">"dark green"</span>
<span class="keyword">for</span> X <span class="keyword">in</span> <span class="string">"<span class="variable">$colour1</span>"</span> <span class="variable">$colour2</span><span class="string">" <span class="variable">$colour3</span>"</span>
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>Can you guess what would happen if we left out the quotes in the for statement ? This indicates that variable names should be protected with quotes unless you are pretty sure that they do not contain any spaces.
Globbing in for loops</p>
<p>The shell expands a string containing a <em> to all filenames that &quot;match&quot;. A filename matches if and only if it is identical to the match string after replacing the stars </em> with arbitrary strings. For example, the character &quot;*&quot; by itself expands to a space seperated list of all files in the working directory (excluding those that start with a dot &quot;.&quot; ) So</p>
<p>echo <em>
lists all the files and directories in the current directory.
echo </em>.jpg
lists all the jpeg files.
echo ${HOME}/public_html/*.jpg
lists all jpeg files in your public_html directory.
As it happens, this turns out to be very useful for performing operations on the files in a directory, especially used in conjunction with a for loop. For example:</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> *.html
<span class="keyword">do</span>
    grep -L <span class="string">'&lt;UL&gt;'</span> <span class="string">"<span class="variable">$X</span>"</span>
<span class="keyword">done</span></code></pre></div><h3 id="while-loops">While Loops</h3><p>While loops iterate &quot;while&quot; a given condition is true. An example of this:</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">0</span>
<span class="keyword">while</span> [ <span class="variable">$X</span> -le <span class="number">20</span> ]
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
  X=$((X+<span class="number">1</span>))
<span class="keyword">done</span></code></pre></div><p>This raises a natural question: why doesn&#39;t bash allow the C like for loops</p>
<p>for (X=1,X&lt;10; X++)
As it happens, this is discouraged for a reason: bash is an interpreted language, and a rather slow one for that matter. For this reason, heavy iteration is discouraged.
Command Substitution</p>
<p>Command Substitution is a very handy feature of the bash shell. It enables you to take the output of a command and treat it as though it was written on the command line. For example, if you want to set the variable X to the output of a command, the way you do this is via command substitution.</p>
<p>There are two means of command substitution: brace expansion and backtick expansion.</p>
<p>Brace expansion workls as follows: $(commands) expands to the output of commands This permits nesting, so commands can include brace expansions</p>
<p>Backtick expansion expands <code>commands</code> to the output of commands</p>
<p>An example is given;:</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
files=<span class="string">"<span class="variable">$(ls)</span>"</span>
web_files=`ls public_html`
<span class="built_in">echo</span> <span class="string">"<span class="variable">$files</span>"</span>      <span class="comment"># we need the quotes to preserve embedded newlines in $files</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$web_files</span>"</span>  <span class="comment"># we need the quotes to preserve newlines</span>
X=`expr <span class="number">3</span> \* <span class="number">2</span> + <span class="number">4</span>` <span class="comment"># expr evaluate arithmatic expressions. man expr for details.</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$X</span>"</span></code></pre></div><p>The advantage of the $() substitution method is almost self evident: it is very easy to nest. It is supported by most of the bourne shell varients (the POSIX shell or better is OK). However, the backtick substitution is slightly more readable, and is supported by even the most basic shells (any #!/bin/sh version is just fine)</p>
<p>Note that if strings are not quote-protected in the above echo statement, new lines are replaced by spaces in the output.</p>
</div>

  <div class="entry-meta">
    <time class="updated" datetime="2017-02-06T00:00:00.000Z" itemprop="dateModified">Monday, Feb 6th, 2017</time>
    in <span class="entry-tags">
      
      <a href="../tag/bash/">#bash</a>
      
      <a href="../tag/shell/">#shell</a>
      
    </span>
  </div><div style="margin-top: 20px;" class="gh-comments" data-comment-id="" data-title="[译] 使用 bash shell 编写脚本的快速指南（翻译中...）"></div>
<script type="text/javascript">
  (function (){
    if (!'') return false;
    var gh_comments = document.getElementsByClassName('gh-comments')[0];
    var a = document.createElement('a');
    a.href = 'https://github.com/7anshuai/blog/issues';
    var gh_api = 'https://api.github.com/repos' + a.pathname;
    var gh_issue_id = '';
    var gh_issue_url = a.href +  '/' + gh_issue_id;
    var gh_comments_url = gh_api + '/' + gh_issue_id + '/comments';
    fetch(gh_comments_url, {
      headers: new Headers({
        'Accept': 'application/vnd.github.v3.html+json',
        'Content-Type': 'application/json'
      }),
      method: 'GET'
    }).then((res) => {
      if (res.status == 200) return res.json();
      let error = new Error('HTTP Exception[GET]');
      error.status = res.status;
      error.statusText = res.statusText;
      error.url = res.url;
      throw error;
    }).then((json) => {
        gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
          <p>如有需要，请访问 <a href="${gh_issue_url}">GitHub Issue</a> 对文章进行评论。</p>`);
        for (let comment of json) {
          let date = new Date(comment.created_at);
          let c = '<div class="gh-comment">' +
              `<img src="${comment.user.avatar_url}" width="24px"> ` +
              `<a href="${comment.user.html_url}">${comment.user.login}</a>` +
              ' posted at ' +
              `<time>${date.toUTCString()}</time>` +
              '<hr>' +
              comment.body_html +
              '</div>';
          gh_comments.insertAdjacentHTML('beforeend', c);
        }
    }).catch((err) => {
      gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
        <p>获取 GitHub 评论出错，或者还没有评论</p>`);
    })
  })();
</script>
</div>
</section>
      <footer>
 <small>theme <a href='https://github.com/7anshuai/nico-minimal'>nico-minimal</a></small>
        <p class="copyright"><small>powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</small></p>
      </footer>
    </div>
    <script src="https://github.com/themes/minimal/javascripts/scale.fix.js"></script>
    <script src="../static/script.js"></script>
  </body>
</html>