<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="minimal 0.1">
    <title>[译] 使用 bash shell 编写脚本的快速指南 - tanshuai.blog()</title>
    <link rel="shortcut icon" href="http://7anshuai.js.org/favicon.ico" />
    <link rel="apple-touch-icon" href="http://7anshuai.js.org/apple-touch-icon.png" />
    <link rel="stylesheet" href="../static/style.css" />
    <link rel="stylesheet" href="../static/syntax.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59443769-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="../"><h1>tanshuai.blog()</h1></a>
        <nav class="menu" role="navigation">
          <p class="view">
            <a href="./">work</a>
          </p>
          <p class="view">
            <a href="../life/">life of shuai</a>
          </p>
          <p class="view">
            <a href="../feed.xml">feed</a>
          </p>
        </nav>
      </header>
      <section>
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">[译] 使用 bash shell 编写脚本的快速指南</h1>
  <div class="entry-content" itemprop="articleBody"><blockquote>
<p>原文链接：<a href="http://www.panix.com/~elflord/unix/bash-tute.html">A quick guide to writing scripts using the bash shell</a></p>
</blockquote>
<h2 id="简单的-shell-脚本">简单的 shell 脚本</h2><p>一个简单的 shell 脚本只是一点点按顺序执行的命令列表。通常，一个 shell 脚本应该从如下面的一行开始：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span></code></pre></div><p>这表示脚本应该在 bash shell 中运行，无论用户选择了哪个交互式 shell。这是非常重要的，因为不同 shell 的语法可能有很大差异。</p>
<h3 id="简单的例子">简单的例子</h3><p>这是一个非常简单的 shell 脚本示例。 它只是运行一些简单的命令：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> <span class="string">"hello, <span class="variable">$USER</span>. I wish to list some files of yours"</span>
<span class="built_in">echo</span> <span class="string">"listing files in the current directory, <span class="variable">$PWD</span>"</span>
ls  <span class="comment"># list files</span></code></pre></div><p>首先，请注意第4行的注释。在一个 bash 脚本中，任何一个 <code>#</code>（除了第一行的 <a href="https://zh.wikipedia.org/zh-hans/Shebang">shebang</a> 之外）都被视为注释。 即 shell 解释器会忽略它。而对于人们阅读脚本是有益的。</p>
<p><code>$USER</code> 和 <code>$PWD</code> 是<em>变量</em>。这些是由 bash shell 本身定义的标准变量，它们不需要在脚本中定义。请注意，当变量名称在双引号内时，变量是<em>展开的</em>（<code>expanded</code>）。展开（<code>expand</code>）是一个非常合适的词：shell 看到字符串 <code>$USER</code>，并用变量的值替换它，然后执行命令。</p>
<p>下面我们来继续讨论变量...</p>
<h2 id="变量">变量</h2><p>任何编程语言都需要变量。如下定义一个变量：</p>
<div class="highlight"><pre><code class="bash">X=<span class="string">"hello"</span></code></pre></div><p>然后引用它：</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$X</span></code></pre></div><p>更具体地说，<code>$X</code> 用于表示变量 <code>X</code> 的值。 一些要注意的语义：</p>
<ul>
<li>如果你在 <code>=</code> 标志的两边留下空格，bash就会变得不快乐。 例如，以下内容导致了一个错误：<div class="highlight"><pre><code class="bash">X = hello</code></pre></div></li>
</ul>
<ul>
<li>虽然在我的例子中有引号，但并不总是必需的。 当变量的值包含空格时需要引号。 例如：<div class="highlight"><pre><code class="bash">X=hello world <span class="comment"># error</span>
X=<span class="string">"hello world"</span> <span class="comment"># OK</span></code></pre></div></li>
</ul>
<p>这是因为 shell 本质上将命令行看作一堆由空格分隔的命令和命令参数。 <code>foo=baris</code> 被认为是一个命令。 <code>foo = bar</code>的问题是 shell 看到由空格分隔的单词 <code>foo</code>，并把它解释为一个命令。 同样，命令 <code>X=hello world</code> 的问题是 shell 将 <code>X=hello</code> 解释为一个命令，而 <code>world</code> 这个词没有任何意义（因为赋值命令不能携带参数）。</p>
<h3 id="单引号与双引号">单引号与双引号</h3><p>基本上，变量名称只在双引号内展开，单引号里不展开。如果不需要引用变量，单引号很好用，因为结果更可预测。</p>
<p>一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="built_in">echo</span> -n <span class="string">'$USER='</span> <span class="comment"># -n option stops echo from breaking the line</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span>"</span>
<span class="built_in">echo</span> <span class="string">"\$USER=<span class="variable">$USER</span>"</span>  <span class="comment"># this does the same thing as the first two lines</span></code></pre></div><p>输出看起来像这样（假设你的用户名是 elflord）:</p>
<div class="highlight"><pre><code class="bash"><span class="variable">$USER</span>=elflord

<span class="variable">$USER</span>=elflord</code></pre></div><p>双引号更灵活，但是可预测性较低。如果可以在两者之间选择的话，使用单引号。</p>
<h3 id="使用引号括起变量">使用引号括起变量</h3><p>有时，使用双引号保护变量名是个好主意。 如果您的变量值包含空格或是空字符串，则这是很重要的。 一个例子如下：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="variable">$X</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>这段脚本会输出：<code>the variable X is not the empty string</code>。
因为 shell 将 <code>$X</code> 展开为空字符串。 表达式 <code>[ -n ]</code> 返回 <code>true</code>（因为它没有提供参数）。 一个更好的脚本将是：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">""</span>
<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$X</span>"</span> ]; <span class="keyword">then</span>  <span class="comment"># -n tests to see if the argument is non empty</span>
  <span class="built_in">echo</span> <span class="string">"the variable X is not the empty string"</span>
<span class="keyword">fi</span></code></pre></div><p>在这个例子中，表达式展开为 <code>[ -n &quot;&quot; ]</code>，返回 <code>false</code>。因为用双引号括起来的字符串显然是空的。</p>
<h3 id="变量展开实战">变量展开实战</h3><p>只是为了说服你，shell 真的像我之前提到的那样在 “展开” 变量，这里是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
LS=<span class="string">"ls"</span>
LS_FLAGS=<span class="string">"-al"</span>

<span class="variable">$LS</span> <span class="variable">$LS_FLAGS</span> <span class="variable">$HOME</span></code></pre></div><p>这看起来有点神秘。 最后一行会发生什么，它实际上是执行命令
<code>ls -al /home/elflord</code>（假设 <code>/home/elflord</code> 是你的主目录）。 也就是说，shell 只是用它们的值替换变量，然后执行命令。</p>
<h3 id="使用大括号来保护变量">使用大括号来保护变量</h3><p>好了，这里有一个潜在的问题。 假设要 <code>echo</code> 变量 <code>X</code> 的值，紧接着是字母 <code>abc</code>。 问题：你怎么做的？ 我们来试一试：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">$Xabc</span>"</span></code></pre></div><p>这样没有得到输出。哪里出了错？答案是，shell 认为我们引用的是未初始化的变量 <code>Xabc</code>。处理这个问题的方法是把大括号放在 <code>X</code> 上以将其与其他字符分开。以下给出了期望的结果：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=ABC
<span class="built_in">echo</span> <span class="string">"<span class="variable">${X}</span>abc"</span></code></pre></div><h2 id="条件语句">条件语句</h2><p>有时需要检查某些条件。一个字符串是否有0个长度？文件 “foo” 是否存在，它是一个符号链接还是一个真实的文件？首先，我们使用 <code>if</code> 命令来运行测试。 语法如下：</p>
<pre>if condition
then
  statement1
  statement2
  ..........
fi</pre><p>有时您可能希望在条件失败时指定备用操作。这是如何做的：</p>
<pre>if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi</pre><p>或者，如果第一个 <code>if</code> 失败，则可以测试另一个条件。 请注意，可以添加任何数量的 <code>elif</code>。</p>
<pre>if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........    
elif condition3
then
  statement5
  statement6
  ........    

fi</pre><p>如果相应的条件为真，则 <code>if/elif</code> 和下一个 <code>elif</code> 或 <code>fi</code> 之间的块内的语句将被执行。 实际上，任何命令都可以替代条件，并且当且仅当命令返回退出状态为<code>0</code>（换句话说，如果命令退出“成功”），则该块将被执行。 但是，在本文档中，我们只会使用 <code>test</code> 或 <code>[ ]</code> 来测试条件。</p>
<h3 id="测试命令和操作符">测试命令和操作符</h3><p>几乎所有的条件语句使用的命令都是测试命令。 测试返回 <code>true</code> 或 <code>false</code>（更准确地说，退出 <code>0</code> 或非零状态），这取决于测试是通过还是失败。 它大概如下工作：</p>
<pre>test operand1 operator operand2</pre><p>对于某些测试，只需要一个操作数（operand2）测试命令通常以下列形式缩写：</p>
<pre>[ operand1 operator operand2 ]</pre><p>让讨论回到现实，我们举几个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">3</span>
Y=<span class="number">4</span>
empty_string=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> <span class="operator">-lt</span> <span class="variable">$Y</span> ]  <span class="comment"># is $X less than $Y ?</span>
<span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"\$X=<span class="variable">${X}</span>, which is smaller than \$Y=<span class="variable">${Y}</span>"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$empty_string</span>"</span> ]; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"empty string is non_empty"</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [ <span class="operator">-e</span> <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>       <span class="comment"># test to see if ~/.fvwmrc exists</span>
  <span class="built_in">echo</span> <span class="string">"you have a .fvwmrc file"</span>
  <span class="keyword">if</span> [ -L <span class="string">"<span class="variable">${HOME}</span>/.fvwmrc"</span> ]; <span class="keyword">then</span>     <span class="comment"># is it a symlink ?  </span>
    <span class="built_in">echo</span> <span class="string">"it's a symbolic link
  elif [ -f "</span><span class="variable">${HOME}</span>/.fvwmrc<span class="string">" ]; then   # is it a regular file ?
    echo "</span>it<span class="string">'s a regular file"
  fi
else
  echo "you have no .fvwmrc file"
fi</span></code></pre></div><h3 id="值得注意的一些陷阱">值得注意的一些陷阱</h3><p>测试命令需要以“operand1 <space> operator <space> operand2”或“operator <space> operand2”的形式，换句话说，您真的需要这些空格，因为 shell 认为第一个不包含空格的块是运算符（如果以 <code>-</code> 开头）或操作数。例如：</p>
<div class="highlight"><pre><code class="bash"><span class="keyword">if</span> [ <span class="number">1</span>=<span class="number">2</span> ]; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"hello"</span>
<span class="keyword">fi</span></code></pre></div><p>以上会给出准确的 “错误” 输出（即 <code>echo &quot;hello&quot;</code>，因为 shell 看到一个操作数，但没有操作符）。</p>
<p>另一个潜在的陷阱来自于不保护引号中的变量。 我们已经给出了一个例子，说明为什么你必须用引号括起你想要使用在 <code>-n</code> 测试中的操作数。而且，在大部分时候都有很多足够好的理由来使用引号。当您在测试中展开变量时，无法执行此操作可能会导致非常严重的错误。 以下是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="string">"-n"</span>
Y=<span class="string">""</span>
<span class="keyword">if</span> [ <span class="variable">$X</span> = <span class="variable">$Y</span> ] ; <span class="keyword">then</span>
  <span class="built_in">echo</span> <span class="string">"X=Y"</span>
<span class="keyword">fi</span></code></pre></div><p>这将导致错误输出，因为 shell 将我们的表达式展开为<code>[ -n = “=” ]</code>，字符串 “=” 具有非零长度。</p>
<h3 id="测试操作符的简要总结">测试操作符的简要总结</h3><p>以下是测试运算符的快速列表。 这不是全面的，但它可能是所有你需要记住的（如果你需要任何其他的，你可以随时检查 bash 手册页...）</p>
<table>
<thead>
<tr>
<th>operator</th>
<th>produces true if...</th>
<th>number of operands</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>operand non zero length</td>
<td>1</td>
</tr>
<tr>
<td>-z</td>
<td>operand has zero length</td>
<td>1</td>
</tr>
<tr>
<td>-d</td>
<td>there exists a directory whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-f</td>
<td>there exists a file whose name is operand</td>
<td>1</td>
</tr>
<tr>
<td>-eq</td>
<td>the operands are integers and they are equal</td>
<td>2</td>
</tr>
<tr>
<td>-neq</td>
<td>the opposite of -eq</td>
<td>2</td>
</tr>
<tr>
<td>=</td>
<td>the operands are equal (as strings)</td>
<td>2</td>
</tr>
<tr>
<td>!=</td>
<td>opposite of =</td>
<td>2</td>
</tr>
<tr>
<td>-lt</td>
<td>operand1 is strictly less than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-gt</td>
<td>operand1 is strictly greater than operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-ge</td>
<td>operand1 is greater than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
<tr>
<td>-le</td>
<td>operand1 is less than or equal to operand2 (both operands should be integers)</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="循环">循环</h2><p>循环是使得人们可以重复一个过程或对几个不同的项目执行相同的过程的结构。 在bash中有以下种类的循环可用：</p>
<ul>
<li>for 循环</li>
<li>while 循环</li>
</ul>
<h3 id="for-循环">for 循环</h3><p>for 循环的语法最适合通过示例描述：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> red green blue
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>for 循环遍历空白分隔的项。 请注意，如果某些项具有嵌入空白，则需要使用引号保护它们。 以下是一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
colour1=<span class="string">"red"</span>
colour2=<span class="string">"light blue"</span>
colour3=<span class="string">"dark green"</span>
<span class="keyword">for</span> X <span class="keyword">in</span> <span class="string">"<span class="variable">$colour1</span>"</span> <span class="variable">$colour2</span><span class="string">" <span class="variable">$colour3</span>"</span>
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
<span class="keyword">done</span></code></pre></div><p>你能猜测如果我们在 for 语句中省略引号，会发生什么？ 这表明变量名应该用引号保护，除非你确定它们不包含任何空格。</p>
<h4 id="for-循环中的-glob">for 循环中的 glob</h4><p>shell 将包含 <code>*</code> 的字符串扩展为“匹配”的所有文件名。当且仅当与匹配字符串相同时，文件名匹配，用任意字符串替换星号 <code>*</code> 后。 例如，字符 <code>*</code> 本身扩展到工作目录中所有文件的空格分隔列表（不包括以点开头的 <code>.</code>）。所以：</p>
<ul>
<li><code>echo *</code> 列出当前目录中的所有文件和目录</li>
<li><code>echo *.jpg</code> 列出所有 jpeg 文件</li>
<li><code>echo ${HOME}/public_html/*.jpg</code> 列出您的 public_html 目录中的所有 jpeg 文件</li>
</ul>
<p>正因为如此，这对于对目录中的文件执行操作非常有用，特别是与for循环一起使用。 例如：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
<span class="keyword">for</span> X <span class="keyword">in</span> *.html
<span class="keyword">do</span>
    grep -L <span class="string">'&lt;UL&gt;'</span> <span class="string">"<span class="variable">$X</span>"</span>
<span class="keyword">done</span></code></pre></div><h3 id="while-循环">while 循环</h3><p>当一个给定的条件为真 while 循环进行迭代。 一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
X=<span class="number">0</span>
<span class="keyword">while</span> [ <span class="variable">$X</span> -le <span class="number">20</span> ]
<span class="keyword">do</span>
  <span class="built_in">echo</span> <span class="variable">$X</span>
  X=$((X+<span class="number">1</span>))
<span class="keyword">done</span></code></pre></div><p>这提出了一个自然的问题：为什么 bash 不允许 C 语言式的 for 循环 <code>for（X = 1，X &lt;10; X ++）</code> ？</p>
<p>事实上，for 循环不被鼓励使用，因为：bash 是一种解释性语言，而且它的循环是一个相当缓慢的事情。 因此，不鼓励重复迭代。</p>
<h2 id="命令替换">命令替换</h2><p>命令替换是 bash shell 非常方便的功能。 它使您可以获取命令的输出，并将其视为在命令行中写入。 例如，如果要将变量 <code>X</code> 设置为命令的输出，则通过命令替换来执行此操作。</p>
<p>有两种形式的命令替换：括号展开和反向展开。</p>
<p>括号扩展工作如下：<code>$(commands)</code> 展开到命令的输出，允许嵌套。因此命令可以包括括号扩展：</p>
<p>反向扩展将 <code>commands</code> 展开到命令的输出：</p>
<p>给出一个例子：</p>
<div class="highlight"><pre><code class="bash"><span class="shebang">#!/bin/bash</span>
files=<span class="string">"<span class="variable">$(ls)</span>"</span>
web_files=`ls public_html`
<span class="built_in">echo</span> <span class="string">"<span class="variable">$files</span>"</span>      <span class="comment"># we need the quotes to preserve embedded newlines in $files</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$web_files</span>"</span>  <span class="comment"># we need the quotes to preserve newlines</span>
X=`expr <span class="number">3</span> \* <span class="number">2</span> + <span class="number">4</span>` <span class="comment"># expr evaluate arithmatic expressions. man expr for details.</span>
<span class="built_in">echo</span> <span class="string">"<span class="variable">$X</span>"</span></code></pre></div><p><code>$()</code> 替代方法的优点是几乎不言而喻：嵌套很容易。 大部分的 bourne shell 可以支持（或 POSIX shell）。但是，反向替换稍微可读性更好，甚至最基本的 shell 也支持（任何 <code>#!/bin/sh</code> 都很好）。</p>
<p>请注意，如果字符串在上述 <code>echo</code> 语句中没有引号保护，换行符将被输出中的空格替换。</p>
</div>

  <div class="entry-meta">
    <time class="updated" datetime="2017-05-04T00:00:00.000Z" itemprop="dateModified">Thursday, May 4th, 2017</time>
    in <span class="entry-tags">
      
      <a href="../tag/bash/">#bash</a>
      
      <a href="../tag/shell/">#shell</a>
      
    </span>
  </div><div style="margin-top: 20px;" class="gh-comments" data-comment-id="2" data-title="[译] 使用 bash shell 编写脚本的快速指南"></div>
<script type="text/javascript">
  (function (){
    if (!'2') return false;
    var gh_comments = document.getElementsByClassName('gh-comments')[0];
    var a = document.createElement('a');
    a.href = 'https://github.com/7anshuai/blog/issues';
    var gh_api = 'https://api.github.com/repos' + a.pathname;
    var gh_issue_id = '2';
    var gh_issue_url = a.href +  '/' + gh_issue_id;
    var gh_comments_url = gh_api + '/' + gh_issue_id + '/comments';
    fetch(gh_comments_url, {
      headers: new Headers({
        'Accept': 'application/vnd.github.v3.html+json',
        'Content-Type': 'application/json'
      }),
      method: 'GET'
    }).then((res) => {
      if (res.status == 200) return res.json();
      let error = new Error('HTTP Exception[GET]');
      error.status = res.status;
      error.statusText = res.statusText;
      error.url = res.url;
      throw error;
    }).then((json) => {
        gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
          <p>如有需要，请访问 <a href="${gh_issue_url}">GitHub Issue</a> 对文章进行评论。</p>`);
        for (let comment of json) {
          let date = new Date(comment.created_at);
          let c = '<div class="gh-comment">' +
              `<img src="${comment.user.avatar_url}" width="24px" style="margin-bottom: 5px; vertical-align: middle;"> ` +
              `<a href="${comment.user.html_url}">${comment.user.login}</a>` +
              ' posted at ' +
              `<time>${date.toUTCString()}</time>` +
              '<hr>' +
              comment.body_html +
              '</div>';
          gh_comments.insertAdjacentHTML('beforeend', c);
        }
    }).catch((err) => {
      gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
        <p>获取 GitHub 评论出错，或者还没有评论</p>`);
    })
  })();
</script>
</div>
</section>
      <footer>
 <small>theme <a href='https://github.com/7anshuai/nico-minimal'>nico-minimal</a></small>
        <p class="copyright"><small>powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</small></p>
      </footer>
    </div>
    <script src="https://github.com/themes/minimal/javascripts/scale.fix.js"></script>
    <script src="../static/script.js"></script>
  </body>
</html>