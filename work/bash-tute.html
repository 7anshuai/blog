<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="minimal 0.1">
    <title>[译] 使用 bash shell 编写脚本的快速指南（翻译中...）</title>
    <link rel="shortcut icon" href="http://7anshuai.js.org/favicon.ico" />
    <link rel="apple-touch-icon" href="http://7anshuai.js.org/apple-touch-icon.png" />
    <link rel="stylesheet" href="../static/style.css" />
    <link rel="stylesheet" href="../static/syntax.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59443769-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="../"><h1>tanshuai.blog()</h1></a>
        <nav class="menu" role="navigation">
          <p class="view">
            <a href="./">work</a>
          </p>
          <p class="view">
            <a href="../life/">life of shuai</a>
          </p>
          <p class="view">
            <a href="../feed.xml">feed</a>
          </p>
        </nav>
      </header>
      <section>
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">[译] 使用 bash shell 编写脚本的快速指南（翻译中...）</h1>
  <div class="entry-content" itemprop="articleBody"><h2 id="简单的-shell-脚本">简单的 shell 脚本</h2><p>A shell script is little more than a list of commands that are run in sequence. Conventionally, a shellscript should start with a line such as the following:</p>
<pre>#!/bin/bash</pre><p>This indicates that the script should be run in the bash shell regardless of which interactive shell the user has chosen. This is very important, since the syntax of different shells can vary greatly.</p>
<h3 id="a-simple-example">A simple example</h3><p>Here&#39;s a very simple example of a shell script. It just runs a few simple commands</p>
<pre>#!/bin/bash
echo &quot;hello, $USER. I wish to list some files of yours&quot;
echo &quot;listing files in the current directory, $PWD&quot;
ls  # list files</pre><p>Firstly, notice the comment on line 4. In a bash script, anything following a pound sign # (besides the shell name on the first line) is treated as a comment. ie the shell ignores it. It is there for the benifit of people reading the script.</p>
<p><code>$USER</code> and <code>$PWD</code> are <em>variables</em>. These are standard variables defined by the bash shell itself, they needn&#39;t be defined in the script. Note that the variables are <em>expanded</em> when the variable name is inside double quotes. Expanded is a very appropriate word: the shell basically sees the string $USER and replaces it with the variable&#39;s value then executes the command.</p>
<p>We continue the discussion on variables below ...</p>
<h2 id="variables">Variables</h2><p>Any programming language needs variables. You define a variable as follows:</p>
<pre>X=&quot;hello&quot;</pre><p>and refer to it as follows:</p>
<pre>$X</pre><p>More specifically, <code>$X</code> is used to denote the value of the variable <code>X</code>. Some things to take note of regarding semantics:</p>
<ul>
<li>bash gets unhappy if you leave a space on either side of the <code>=</code> sign. For example, the following gives an error message:<pre>X = hello</pre></li>
<li>while I have quotes in my example, they are not always necessary. where you need quotes is when your variable names include spaces. For example,<pre>X=hello world # error
X=&quot;hello world&quot; # OK</pre></li>
</ul>
<p>This is because the shell essentially sees the command line as a pile of commands and command arguments seperated by spaces. <code>foo=baris</code> considered a command. The problem with <code>foo = bar</code> is the shell sees the word <code>foo</code> seperated by spaces and interprets it as a command. Likewise, the problem with the command <code>X=hello world</code> is that the shell interprets <code>X=hello</code> as a command, and the word &quot;world&quot; does not make any sense (since the assignment command doesn&#39;t take arguments).</p>
<h3 id="single-quotes-versus-double-quotes">Single Quotes versus double quotes</h3><p>Basically, variable names are exapnded within double quotes, but not single quotes. If you do not need to refer to variables, single quotes are good to use as the results are more predictable.</p>
<p>An example</p>
<pre>#!/bin/bash
echo -n &#39;$USER=&#39; # -n option stops echo from breaking the line
echo &quot;$USER&quot;
echo &quot;\$USER=$USER&quot;  # this does the same thing as the first two lines</pre><p>The output looks like this (assuming your username is elflord)</p>
<pre>$USER=elflord

$USER=elflord</pre><p>so the double quotes still have a work around. Double quotes are more flexible, but less predictable. Given the choice between single quotes and double quotes, use single quotes.</p>
<h3 id="using-quotes-to-enclose-your-variables">Using Quotes to enclose your variables</h3><p>Sometimes, it is a good idea to protect variable names in double quotes. This is usually the most important if your variables value either (a) contains spaces or (b) is the empty string. An example is as follows:</p>
<pre>#!/bin/bash
X=&quot;&quot;
if [ -n $X ]; then  # -n tests to see if the argument is non empty
  echo &quot;the variable X is not the empty string&quot;
fi</pre><p>This script will give the following output:
the variable X is not the empty string
Why ? because the shell expands $X to the empty string. The expression [ -n ] returns true (since it is not provided with an argument). A better script would have been:</p>
<pre>#!/bin/bash
X=&quot;&quot;
if [ -n &quot;$X&quot; ]; then  # -n tests to see if the argument is non empty
  echo &quot;the variable X is not the empty string&quot;
fi</pre><p>In this example, the expression expands to [ -n &quot;&quot; ] which returns false, since the string enclosed in inverted commas is clearly empty.</p>
<h3 id="variable-expansion-in-action">Variable Expansion in action</h3><p>Just to convince you that the shell really does &quot;expand&quot; variables in the sense I mentioned before, here is an example:</p>
<pre>#!/bin/bash
LS=&quot;ls&quot;
LS_FLAGS=&quot;-al&quot;

$LS $LS_FLAGS $HOME</pre><p>This looks a little enigmatic. What happens with the last line is that it actually executes the command
ls -al /home/elflord
(assuming that /home/elflord is your home directory). That is, the shell simply replaces the variables with their values, and then executes the command.
Using Braces to Protect Your Variables</p>
<p>OK. Here&#39;s a potential problem situation. Suppose you want to echo the value of the variable X, followed immediately by the letters &quot;abc&quot;. Question: how do you do this ? Let&#39;s have a try:</p>
<pre>#!/bin/bash
X=ABC
echo &quot;$Xabc&quot;</pre><p>THis gives no output. What went wrong ? The answer is that the shell thought that we were asking for the variable Xabc, which is uninitialised. The way to deal with this is to put braces around X to seperate it from the other characters. The following gives the desired result:</p>
<pre>#!/bin/bash
X=ABC
echo &quot;${X}abc&quot;</pre><h2 id="conditionals-if-then-elif">Conditionals, if/then/elif</h2><p>Sometimes, it&#39;s necessary to check for certain conditions. Does a string have 0 length ? does the file &quot;foo&quot; exist, and is it a symbolic link , or a real file ? Firstly, we use the if command to run a test. The syntax is as follows:
if condition
then
  statement1
  statement2
  ..........
fi
Sometimes, you may wish to specify an alternate action when the condition fails. Here&#39;s how it&#39;s done.
if condition
then
  statement1
  statement2
  ..........
else
  statement3
fi
alternatively, it is possible to test for another condition if the first &quot;if&quot; fails. Note that any number of elifs can be added.
if condition1
then
  statement1
  statement2
  ..........
elif condition2
then
  statement3
  statement4
  ........<br>elif condition3
then
  statement5
  statement6
  ........    </p>
<p>fi
The statements inside the block between if/elif and the next elif or fi are executed if the corresponding condition is true. Actually, any command can go in place of the conditions, and the block will be executed if and only if the command returns an exit status of 0 (in other words, if the command exits &quot;succesfully&quot; ). However, in the course of this document, we will be only interested in using &quot;test&quot; or &quot;[ ]&quot; to evaluate conditions.</p>
<h2 id="the-test-command-and-operators">The Test Command and Operators</h2><p>The command used in conditionals nearly all the time is the test command. Test returns true or false (more accurately, exits with 0 or non zero status) depending respectively on whether the test is passed or failed. It works like this:
test operand1 operator operand2
for some tests, there need be only one operand (operand2) The test command is typically abbreviated in this form:
[ operand1 operator operand2 ]
To bring this discussion back down to earth, we give a few examples:</p>
<pre>#!/bin/bash
X=3
Y=4
empty_string=&quot;&quot;
if [ $X -lt $Y ]  # is $X less than $Y ?
then
  echo &quot;\$X=${X}, which is smaller than \$Y=${Y}&quot;
fi

if [ -n &quot;$empty_string&quot; ]; then
  echo &quot;empty string is non_empty&quot;
fi

if [ -e &quot;${HOME}/.fvwmrc&quot; ]; then       # test to see if ~/.fvwmrc exists
  echo &quot;you have a .fvwmrc file&quot;
  if [ -L &quot;${HOME}/.fvwmrc&quot; ]; then     # is it a symlink ?  
    echo &quot;it&#39;s a symbolic link
  elif [ -f &quot;${HOME}/.fvwmrc&quot; ]; then   # is it a regular file ?
    echo &quot;it&#39;s a regular file&quot;
  fi
else
  echo &quot;you have no .fvwmrc file&quot;
fi</pre><p>Some pitfalls to be wary of</p>
<p>The test command needs to be in the form &quot;operand1<space>operator<space>operand2&quot; or operator<space>operand2 , in other words you really need these spaces, since the shell considers the first block containing no spaces to be either an operator (if it begins with a &#39;-&#39;) or an operand (if it doesn&#39;t). So for example; this</p>
<p>if [ 1=2 ]; then
  echo &quot;hello&quot;
fi
gives exactly the &quot;wrong&quot; output (ie it echos &quot;hello&quot;, since it sees an operand but no operator.)
Another potential trap comes from not protecting variables in quotes. We have already given an example as to why you must wrap anything you wish to use for a -n test with quotes. However, there are a lot of good reasons for using quotes all the time, or almost all of the time. Failing to do this when you have variables expanded inside tests can result in very wierd bugs. Here&#39;s an example: For example,</p>
<pre>#!/bin/bash
X=&quot;-n&quot;
Y=&quot;&quot;
if [ $X = $Y ] ; then
  echo &quot;X=Y&quot;
fi</pre><p>This will give misleading output since the shell expands our expression to
[ -n = ]
and the string &quot;=&quot; has non zero length.</p>
<h3 id="a-brief-summary-of-test-operators">A brief summary of test operators</h3><p>Here&#39;s a quick list of test operators. It&#39;s by no means comprehensive, but its likely to be all you&#39;ll need to remember (if you need anything else, you can always check the bash manpage ... )
operator  produces true if... number of operands
-n  operand non zero length 1
-z  operand has zero length 1
-d  there exists a directory whose name is operand  1
-f  there exists a file whose name is operand 1
-eq the operands are integers and they are equal  2
-neq  the opposite of -eq 2
= the operands are equal (as strings) 2
!=  opposite of = 2
-lt operand1 is strictly less than operand2 (both operands should be integers)  2
-gt operand1 is strictly greater than operand2 (both operands should be integers) 2
-ge operand1 is greater than or equal to operand2 (both operands should be integers)  2
-le operand1 is less than or equal to operand2 (both operands should be integers) 2</p>
<h2 id="loops">Loops</h2><p>Loops are constructions that enable one to reiterate a procedure or perform the same procedure on several different items. There are the following kinds of loops available in bash</p>
<ul>
<li>for loops</li>
<li>while loops</li>
</ul>
<h3 id="for-loops">For loops</h3><p>The syntax for the for loops is best demonstrated by example.</p>
<pre>#!/bin/bash
for X in red green blue
do
  echo $X
done</pre><p>THe for loop iterates the loop over the space seperated items. Note that if some of the items have embedded spaces, you need to protect them with quotes. Here&#39;s an example:</p>
<pre>#!/bin/bash
colour1=&quot;red&quot;
colour2=&quot;light blue&quot;
colour3=&quot;dark green&quot;
for X in &quot;$colour1&quot; $colour2&quot; $colour3&quot;
do
  echo $X
done</pre><p>Can you guess what would happen if we left out the quotes in the for statement ? This indicates that variable names should be protected with quotes unless you are pretty sure that they do not contain any spaces.
Globbing in for loops</p>
<p>The shell expands a string containing a <em> to all filenames that &quot;match&quot;. A filename matches if and only if it is identical to the match string after replacing the stars </em> with arbitrary strings. For example, the character &quot;*&quot; by itself expands to a space seperated list of all files in the working directory (excluding those that start with a dot &quot;.&quot; ) So</p>
<p>echo <em>
lists all the files and directories in the current directory.
echo </em>.jpg
lists all the jpeg files.
echo ${HOME}/public_html/*.jpg
lists all jpeg files in your public_html directory.
As it happens, this turns out to be very useful for performing operations on the files in a directory, especially used in conjunction with a for loop. For example:</p>
<pre>#!/bin/bash
for X in *.html
do
    grep -L &#39;&lt;UL&gt;&#39; &quot;$X&quot;
done</pre><h3 id="while-loops">While Loops</h3><p>While loops iterate &quot;while&quot; a given condition is true. An example of this:</p>
<pre>#!/bin/bash
X=0
while [ $X -le 20 ]
do
  echo $X
  X=$((X+1))
done</pre><p>This raises a natural question: why doesn&#39;t bash allow the C like for loops</p>
<p>for (X=1,X&lt;10; X++)
As it happens, this is discouraged for a reason: bash is an interpreted language, and a rather slow one for that matter. For this reason, heavy iteration is discouraged.
Command Substitution</p>
<p>Command Substitution is a very handy feature of the bash shell. It enables you to take the output of a command and treat it as though it was written on the command line. For example, if you want to set the variable X to the output of a command, the way you do this is via command substitution.</p>
<p>There are two means of command substitution: brace expansion and backtick expansion.</p>
<p>Brace expansion workls as follows: $(commands) expands to the output of commands This permits nesting, so commands can include brace expansions</p>
<p>Backtick expansion expands <code>commands</code> to the output of commands</p>
<p>An example is given;:</p>
<pre>#!/bin/bash
files=&quot;$(ls)&quot;
web_files=`ls public_html`
echo &quot;$files&quot;      # we need the quotes to preserve embedded newlines in $files
echo &quot;$web_files&quot;  # we need the quotes to preserve newlines
X=`expr 3 \* 2 + 4` # expr evaluate arithmatic expressions. man expr for details.
echo &quot;$X&quot;</pre><p>The advantage of the $() substitution method is almost self evident: it is very easy to nest. It is supported by most of the bourne shell varients (the POSIX shell or better is OK). However, the backtick substitution is slightly more readable, and is supported by even the most basic shells (any #!/bin/sh version is just fine)</p>
<p>Note that if strings are not quote-protected in the above echo statement, new lines are replaced by spaces in the output.</p>
</div>

  <div class="entry-meta">
    <time class="updated" datetime="2017-02-06T00:00:00.000Z" itemprop="dateModified">Monday, Feb 6th, 2017</time>
    in <span class="entry-tags">
      
      <a href="../tag/bash/">#bash</a>
      
      <a href="../tag/shell/">#shell</a>
      
    </span>
  </div><div style="margin-top: 20px;" class="gh-comments" data-comment-id="" data-title="[译] 使用 bash shell 编写脚本的快速指南（翻译中...）"></div>
<script type="text/javascript">
  (function (){
    if (!'') return false;
    var gh_comments = document.getElementsByClassName('gh-comments')[0];
    var a = document.createElement('a');
    a.href = 'https://github.com/7anshuai/blog/issues';
    var gh_api = 'https://api.github.com/repos' + a.pathname;
    var gh_issue_id = '';
    var gh_issue_url = a.href +  '/' + gh_issue_id;
    var gh_comments_url = gh_api + '/' + gh_issue_id + '/comments';
    fetch(gh_comments_url, {
      headers: new Headers({
        'Accept': 'application/vnd.github.v3.html+json',
        'Content-Type': 'application/json'
      }),
      method: 'GET'
    }).then((res) => {
      if (res.status == 200) return res.json();
      let error = new Error('HTTP Exception[GET]');
      error.status = res.status;
      error.statusText = res.statusText;
      error.url = res.url;
      throw error;
    }).then((json) => {
        gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
          <p>如有需要，请访问 <a href="${gh_issue_url}">GitHub Issue</a> 对文章进行评论。</p>`);
        for (let comment of json) {
          let date = new Date(comment.created_at);
          let c = '<div class="gh-comment">' +
              `<img src="${comment.user.avatar_url}" width="24px"> ` +
              `<a href="${comment.user.html_url}">${comment.user.login}</a>` +
              ' posted at ' +
              `<time>${date.toUTCString()}</time>` +
              '<hr>' +
              comment.body_html +
              '</div>';
          gh_comments.insertAdjacentHTML('beforeend', c);
        }
    }).catch((err) => {
      gh_comments.insertAdjacentHTML('afterbegin', `<h3>GitHub Comments</h3>
        <p>获取 GitHub 评论出错，或者还没有评论</p>`);
    })
  })();
</script>
</div>
</section>
      <footer>
 <small>theme <a href='https://github.com/7anshuai/nico-minimal'>nico-minimal</a></small>
        <p class="copyright"><small>powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</small></p>
      </footer>
    </div>
    <script src="https://github.com/themes/minimal/javascripts/scale.fix.js"></script>
    <script src="../static/script.js"></script>
  </body>
</html>